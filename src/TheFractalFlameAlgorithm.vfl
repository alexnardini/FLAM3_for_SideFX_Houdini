/*  
 /  Title:      SideFX Houdini FRACTAL FLAME generator: 2D
 /  Author:     Alessandro Nardini
 /  date:       October 2020, Last revised January 2022
 /
 /  info:       Based on the original: "The Fractal Flame Algorithm"
 /  Authors:    Scott Draves, Erik Reckase
 /  Weblink:    https://flam3.com/flame_draves.pdf
 /  Date:       September 2003, Last revised November 2008
 /
 /  Name:       TheFractalFlameAlgorithm    "VEX"
 /
 /  Comment:    The chaos game
*/

#ifndef VOP_OP
#define VOP_OP
#endif
#ifndef VOP_CVEX
#define VOP_CVEX
#endif

#pragma opname  "FLAME"
#pragma oplabel "FLAME"
#pragma opmininputs 1
#pragma opmaxinputs 1

#include <flame.h>

void _TheFractalFlameAlgorithm(int _bound_ptnum; const int _bound_VACTIVE[], _bound_XAOS; const float _bound_XAOS_TO[]; float _bound_pscale, _bound_COORD, _bound_Alpha; vector _bound_P)
{
    // ftype = 0 -> LOCAL
    // ftype = 1 -> FF
    // ftype = 2 -> POST
    
    int idx, n, SL;
    vector2 __tmp;
    float CLR, PREV_CLR; PREV_CLR = 0;
    // Build genomes
    gemSYS SYS; SYS->gemSYSBuild();
    gem GEM; GEM->gemBuild(_bound_VACTIVE, SYS);
    gemPrm v1GMP, v2GMP, v3GMP, v4GMP;
    v1GMP->gemPrmBuild(GEM.sIDX, GEM.v1type);
    v2GMP->gemPrmBuild(GEM.sIDX, GEM.v2type);
    v3GMP->gemPrmBuild(GEM.sIDX, GEM.v3type);
    v4GMP->gemPrmBuild(GEM.sIDX, GEM.v4type);
    // CHAOS game
    int XAOS = _bound_XAOS;
    float XAOS_TO[] = _bound_XAOS_TO;
    if(XAOS){
        n = len(GEM.sIDX);
        idx = (int)(nrandom("twister")*n);
    }
    vector2 __mem = biunit();
    for(int i=0; i<SYS.iter; i++){
        __tmp = 0;
        if(XAOS){ SL=idx*n; idx=sample_cdf(slice(XAOS_TO,SL,SL+n), nrandom('twister')); } // Surprisingly, slicing into a small array is really slow.
        else idx=sample_cdf(XAOS_TO, nrandom('twister'));
        if(GEM.PBW[idx]>0) V_PREBLUR(__mem, GEM.PBW[idx]);
        if(GEM.v1w[idx]!=0) __tmp += FLAME(v1GMP, 0, idx, GEM.v1type[idx], __mem, GEM.x[idx], GEM.y[idx], GEM.o[idx], GEM.v1w[idx]);
        if(GEM.v2w[idx]!=0) __tmp += FLAME(v2GMP, 0, idx, GEM.v2type[idx], __mem, GEM.x[idx], GEM.y[idx], GEM.o[idx], GEM.v2w[idx]);
        if(GEM.v3w[idx]!=0) __tmp += FLAME(v3GMP, 0, idx, GEM.v3type[idx], __mem, GEM.x[idx], GEM.y[idx], GEM.o[idx], GEM.v3w[idx]);
        if(GEM.v4w[idx]!=0) __tmp += FLAME(v4GMP, 0, idx, GEM.v4type[idx], __mem, GEM.x[idx], GEM.y[idx], GEM.o[idx], GEM.v4w[idx]);
        if(GEM.POSTL[idx]) affine(__tmp, GEM.px[idx], GEM.py[idx], GEM.po[idx]);
        if(SYS.TMG) __tmp *= (matrix2)maketransform(0, 0, 0, set(0, 0, GEM.grt), (vector)GEM.gsc, 0);
        PREV_CLR = CLR = GEM.CLR[idx] + GEM.ONEMINUS[idx] * PREV_CLR;
        __mem = __tmp;
    }
    if(SYS.FF){
        __tmp = 0;
        if(GEM.ffv1w!=0) __tmp += FLAME(v1GMP, 1, 0, GEM.ffv1type, __mem, GEM.fx, GEM.fy, GEM.fo, GEM.ffv1w);
        if(GEM.ffv2w!=0) __tmp += FLAME(v1GMP, 1, 0, GEM.ffv2type, __mem, GEM.fx, GEM.fy, GEM.fo, GEM.ffv2w);
        if(GEM.ffv3w!=0) __tmp += FLAME(v1GMP, 1, 0, GEM.ffv3type, __mem, GEM.fx, GEM.fy, GEM.fo, GEM.ffv3w);
        if(SYS.PFF) affine(__tmp, GEM.pfx, GEM.pfy, GEM.pfo);
        if(GEM.ffp1w!=0) __mem  = FLAME(v1GMP, 2, 0, GEM.ffp1type, __tmp, GEM.fx, GEM.fy, GEM.fo, GEM.ffp1w);
        else __mem = __tmp;
    }
    if(chkNAN_v(SYS.RIP, __mem, GEM.ALPHA[idx])) removepoint(0, _bound_ptnum);
    else{
        float pscl = 0.001;
        float ALPHA = GEM.ALPHA[idx];
        if(SYS.SYM) V_SYM(__mem, SYS.sym_mode);
        if(SYS.MB){ pscl *= SYS.mb_mod; setpointattrib(0, "mb_modulate", _bound_ptnum, SYS.mb_mod, "set"); }
        _bound_P = (vector)__mem;
        _bound_COORD = CLR;
        _bound_pscale = pscl * ALPHA;
        _bound_Alpha = ALPHA;
    }
}

cvex
TheFractalFlameAlgorithm( export int    ptnum     = 0;
                          const  int    VACTIVE[] = {};
                          const  int    XAOS      = 0;
                          const  float  XAOS_TO[] = {};
	                      export float  pscale    = 0;
	                      export float  COORD     = 0;
                          export float  Alpha     = 0;
	                      export vector P         = 0)
{
    _TheFractalFlameAlgorithm(ptnum, VACTIVE, XAOS, XAOS_TO, pscale, COORD, Alpha, P);
}
