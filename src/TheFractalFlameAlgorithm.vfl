/*  
 /  Title:      SideFX Houdini FLAM3: 2D
 /  Author:     Alessandro Nardini
 /  date:       October 2020, Last revised May 2022
 /
 /  info:       Based on the original: "The Fractal Flame Algorithm"
 /  Authors:    Scott Draves, Erik Reckase
 /  Weblink:    https://flam3.com/flame_draves.pdf
 /  Date:       September 2003, Last revised November 2008
 /
 /  Name:       TheFractalFlameAlgorithm    "CVEX"
 /
 /  Comment:    The chaos game
 /
*/


#define PSCL 0.001
#define FFL "../_"
#define FFP "../_p1"
#define X {1,0}
#define Y {0,1}
#define O {0,0}

#pragma opname  "FLAM3"
#pragma oplabel "FLAM3"
#pragma opmininputs 1
#pragma opmaxinputs 1

#include <flame.h>
#include <flamepp.h>
#include <flameff.h>

void _TheFractalFlameAlgorithm(int _bound_ptnum; const string _bound_sIDX[]; const int _bound_XAOS; const float _bound_IW[], _bound_XAOS_TO[]; float _bound_pscale, _bound_clr, _bound_Alpha; vector _bound_P)
{
    // ft = 1 -> FF
    // ft = 2 -> FF POST
    
    int     sl, idx;
    float   pscl, clr, prev_clr, alpha, XAOS_TO[]; prev_clr=0; pscl=PSCL;
    vector2 tmp;
    // Build genomes
    string sIDX[]=_bound_sIDX;
    gem GEM; GEM->gemBuild(sIDX);
    // cast FLAME
    int     res, iter, v1t[], v2t[], v3t[], v4t[], p1t[], ppt[], PPL[], TM, FF, PFF, RIP, SM, MB, sm_mod; res=GEM.res; iter=GEM.iter; v1t=GEM.v1t; v2t=GEM.v2t; v3t=GEM.v3t; v4t=GEM.v4t; p1t=GEM.p1t; ppt=GEM.ppt; PPL=GEM.PPL; TM=GEM.TM; FF=GEM.FF; PFF=GEM.PFF; RIP=GEM.RIP; SM=GEM.SM; MB=GEM.MB; sm_mod=GEM.sm_mod;
    float   v1w[], v2w[], v3w[], v4w[], p1w[], pbw[], ppw[], _CLR[], OM[], A[], mb_mod; v1w=GEM.v1w; v2w=GEM.v2w; v3w=GEM.v3w; v4w=GEM.v4w; p1w=GEM.p1w; pbw=GEM.pbw; ppw=GEM.ppw; _CLR=GEM.CLR; OM=GEM.OM; A=GEM.A; mb_mod=GEM.mb_mod;
    vector2 x[], y[], o[], px[], py[], po[]; x=GEM.x; y=GEM.y; o=GEM.o; px=GEM.px; py=GEM.py; po=GEM.po;
    // cast TM
    matrix2 TMm2=GEM.TMm2;
    // cast FF
    int     ffv1t, ffv2t, ffv3t, ffp1t; ffv1t=GEM.ffv1t; ffv2t=GEM.ffv2t; ffv3t=GEM.ffv3t; ffp1t=GEM.ffp1t;
    float   ffv1w, ffv2w, ffv3w, ffp1w; ffv1w=GEM.ffv1w; ffv2w=GEM.ffv2w; ffv3w=GEM.ffv3w; ffp1w=GEM.ffp1w;
    vector2 fx, fy, fo, pfx, pfy, pfo; fx=GEM.fx; fy=GEM.fy; fo=GEM.fo; pfx=GEM.pfx; pfy=GEM.pfy; pfo=GEM.pfo;
    // Build genome's parametrics
    gemPrm v1GMP, v2GMP, v3GMP, v4GMP, p1GMP;
    v1GMP->gemPrmBuild(sIDX, res, v1t, v1w);
    v2GMP->gemPrmBuild(sIDX, res, v2t, v2w);
    v3GMP->gemPrmBuild(sIDX, res, v3t, v3w);
    v4GMP->gemPrmBuild(sIDX, res, v4t, v4w);
    p1GMP->gemPrmBuild(sIDX, res, p1t, p1w);
    // CHAOS game
    float IW[]=_bound_IW; int XAOS=_bound_XAOS;
    if(XAOS){ XAOS_TO=_bound_XAOS_TO; idx=sample_cdf(IW, nrandom('twister')); }
    vector2 mem=biunit();
    for(int i=0; i<iter; ++i){
        tmp=0;
        if(XAOS){ sl=idx*res; idx=sample_cdf(XAOS_TO[sl:sl+res], nrandom('twister')); }
        else idx=sample_cdf(IW, nrandom("twister"));
        if(pbw[idx] >0) V_PREBLUR(mem, pbw[idx]);
        if(ppw[idx] >0) mem  = FLAMEPP(ppt[idx], mem, X, Y, O, ppw[idx]);
        if(v1w[idx]!=0) tmp += FLAME(v1GMP, idx, v1t[idx], mem, x[idx], y[idx], o[idx], v1w[idx]);
        if(v2w[idx]!=0) tmp += FLAME(v2GMP, idx, v2t[idx], mem, x[idx], y[idx], o[idx], v2w[idx]);
        if(v3w[idx]!=0) tmp += FLAME(v3GMP, idx, v3t[idx], mem, x[idx], y[idx], o[idx], v3w[idx]);
        if(v4w[idx]!=0) tmp += FLAME(v4GMP, idx, v4t[idx], mem, x[idx], y[idx], o[idx], v4w[idx]);
        if(p1w[idx]!=0) tmp  = FLAME(p1GMP, idx, p1t[idx], tmp, X, Y, O, p1w[idx]);
        if(PPL[idx]) affine(tmp, px[idx], py[idx], po[idx]);
        if(TM) tmp*=TMm2;
        prev_clr=clr=_CLR[idx]+OM[idx]*prev_clr;
        mem=tmp;
    }
    // FF
    if(FF){
        tmp=0;
        if(ffv1w!=0) tmp += FLAMEFF(FFL, ffv1t, mem, fx, fy, fo, ffv1w);
        if(ffv2w!=0) tmp += FLAMEFF(FFL, ffv2t, mem, fx, fy, fo, ffv2w);
        if(ffv3w!=0) tmp += FLAMEFF(FFL, ffv3t, mem, fx, fy, fo, ffv3w);
        if(ffp1w!=0) tmp  = FLAMEFF(FFP, ffp1t, tmp, X, Y, O, ffp1w);
        if(PFF) affine(tmp, pfx, pfy, pfo);
        mem=tmp;
    }
    alpha=A[idx];
    if(chkPT(RIP, mem, alpha)) removepoint(0, _bound_ptnum);
    else{
        // OUT
        pscl*=alpha;
        if(SM) V_SYM(mem, sm_mod);
        if(MB){ pscl*=mb_mod; setpointattrib(0, "mb_mod", _bound_ptnum, mb_mod, "set"); }
        _bound_P=(vector)mem;
        _bound_clr=clr;
        _bound_pscale=pscl;
        _bound_Alpha=alpha;
    }
}

cvex
TheFractalFlameAlgorithm( export int    ptnum     = 0;
                          const  string sIDX[]    = {};
                          const  int    XAOS      = 0;
                          const  float  IW[]      = {};
                          const  float  XAOS_TO[] = {};
	                      export float  pscale    = 0;
	                      export float  clr       = 0;
                          export float  Alpha     = 0;
	                      export vector P         = 0)
{
    _TheFractalFlameAlgorithm(ptnum, sIDX, XAOS, IW, XAOS_TO, pscale, clr, Alpha, P);
}
