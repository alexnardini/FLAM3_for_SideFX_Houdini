/*  
 /  Title:      SideFX Houdini FLAM3: 2D
 /  Author:     Alessandro Nardini
 /  date:       October 2020, Last revised May 2022
 /
 /  info:       Based on the original: "The Fractal Flame Algorithm"
 /  Authors:    Scott Draves, Erik Reckase
 /  Weblink:    https://flam3.com/flame_draves.pdf
 /  Date:       September 2003, Last revised November 2008
 /
 /  Name:       TheFractalFlameAlgorithm    "VEX"
 /
 /  Comment:    The chaos game
*/

#ifndef VOP_OP
#define VOP_OP
#endif
#ifndef VOP_CVEX
#define VOP_CVEX
#endif

#pragma opname  "FLAME"
#pragma oplabel "FLAME"
#pragma opmininputs 1
#pragma opmaxinputs 1

#include <flame.h>
#include <flamepp.h>
#include <flameff.h>

void _TheFractalFlameAlgorithm(int _bound_ptnum; const int _bound_VACTIVE[], _bound_XAOS; const float _bound_XAOS_TO[]; float _bound_pscale, _bound_COORD, _bound_Alpha; vector _bound_P)
{
    // ftype = 1 -> FF
    // ftype = 2 -> POST
    
    int SL, idx, n;
    vector2 __tmp;
    float CLR, PREV_CLR, ALPHA; PREV_CLR = 0;
    // Build genomes
    int ACTV[] = _bound_VACTIVE;
    gem GEM; GEM->gemBuild(ACTV);
    int res, iter, v1type[], v2type[], v3type[], v4type[], p1type[], pp1type[], POSTL[], TMG, FF, PFF, RIP, SYM, MB, sym_mod; res=GEM.res; iter=GEM.iter; v1type=GEM.v1type; v2type=GEM.v2type; v3type=GEM.v3type; v4type=GEM.v4type; p1type=GEM.p1type; pp1type=GEM.pp1type; POSTL=GEM.POSTL; TMG=GEM.TMG; FF=GEM.FF; PFF=GEM.PFF; RIP=GEM.RIP; SYM=GEM.SYM; MB=GEM.MB; sym_mod=GEM.sym_mod;
    float v1w[], v2w[], v3w[], v4w[], p1w[], grt, pp1w[], _CLR[], ONEMINUS[], _ALPHA[], mb_mod; v1w=GEM.v1w; v2w=GEM.v2w; v3w=GEM.v3w; v4w=GEM.v4w; p1w=GEM.p1w; grt=GEM.grt; pp1w=GEM.pp1w; _CLR=GEM.CLR; ONEMINUS=GEM.ONEMINUS; _ALPHA=GEM.ALPHA; mb_mod=GEM.mb_mod;
    vector2 x[], y[], o[], px[], py[], po[]; x=GEM.x; y=GEM.y; o=GEM.o; px=GEM.px; py=GEM.py; po=GEM.po;
    string sIDX[]=GEM.sIDX;
    gemPrm v1GMP, v2GMP, v3GMP, v4GMP, p1GMP;
    v1GMP->gemPrmBuild(sIDX, res, v1type, v1w);
    v2GMP->gemPrmBuild(sIDX, res, v2type, v2w);
    v3GMP->gemPrmBuild(sIDX, res, v3type, v3w);
    v4GMP->gemPrmBuild(sIDX, res, v4type, v4w);
    p1GMP->gemPrmBuild(sIDX, res, p1type, p1w);
    // CHAOS game
    int XAOS = _bound_XAOS;
    float XAOS_TO[] = _bound_XAOS_TO;
    if(XAOS) idx=(int)(nrandom('twister')*res);
    vector2 __mem = biunit();
    for(int i=0; i<iter; ++i){
        __tmp = 0;
        if(XAOS){ SL=idx*res; idx=sample_cdf(XAOS_TO[SL:SL+res], nrandom('twister')); }
        else idx=sample_cdf(XAOS_TO, nrandom("twister"));
        // The following is a good idea and faster but for some reasons it miss to produce correct results. Check TFFAvactive.vfl to see the other bit of it.
        //else idx=(int)XAOS_TO[(int)(nrandom("twister")*4096)];
        if(pp1w[idx]>0) __mem  = FLAMEPP(pp1type[idx], __mem, {1, 0}, {0, 1}, {0, 0}, pp1w[idx]);
        if(v1w[idx]!=0) __tmp += FLAME(v1GMP, idx, v1type[idx], __mem, x[idx], y[idx], o[idx], v1w[idx]);
        if(v2w[idx]!=0) __tmp += FLAME(v2GMP, idx, v2type[idx], __mem, x[idx], y[idx], o[idx], v2w[idx]);
        if(v3w[idx]!=0) __tmp += FLAME(v3GMP, idx, v3type[idx], __mem, x[idx], y[idx], o[idx], v3w[idx]);
        if(v4w[idx]!=0) __tmp += FLAME(v4GMP, idx, v4type[idx], __mem, x[idx], y[idx], o[idx], v4w[idx]);
        if(p1w[idx]!=0) __tmp  = FLAME(p1GMP, idx, p1type[idx], __tmp, {1, 0}, {0, 1}, {0, 0}, p1w[idx]);
        if(POSTL[idx]) affine(__tmp, px[idx], py[idx], po[idx]);
        if(TMG) __tmp *= (matrix2)maketransform(0, 0, 0, set(0, 0, grt), 1, 0);
        PREV_CLR = CLR = _CLR[idx] + ONEMINUS[idx] * PREV_CLR;
        __mem = __tmp;
    }
    if(FF){
        int ffv1type, ffv2type, ffv3type, ffp1type; ffv1type=GEM.ffv1type; ffv2type=GEM.ffv2type; ffv3type=GEM.ffv3type; ffp1type=GEM.ffp1type;
        float ffv1w, ffv2w, ffv3w, ffp1w; ffv1w=GEM.ffv1w; ffv2w=GEM.ffv2w; ffv3w=GEM.ffv3w; ffp1w=GEM.ffp1w;
        vector2 fx, fy, fo, pfx, pfy, pfo; fx=GEM.fx; fy=GEM.fy; fo=GEM.fo; pfx=GEM.pfx; pfy=GEM.pfy; pfo=GEM.pfo;
        __tmp = 0;
        if(ffv1w!=0) __tmp += FLAMEFF(v1GMP, 1, ffv1type, __mem, fx, fy, fo, ffv1w);
        if(ffv2w!=0) __tmp += FLAMEFF(v1GMP, 1, ffv2type, __mem, fx, fy, fo, ffv2w);
        if(ffv3w!=0) __tmp += FLAMEFF(v1GMP, 1, ffv3type, __mem, fx, fy, fo, ffv3w);
        if(ffp1w!=0) __tmp  = FLAMEFF(v1GMP, 2, ffp1type, __tmp, {1, 0}, {0, 1}, {0, 0}, ffp1w);
        if(PFF) affine(__tmp, pfx, pfy, pfo);
        __mem = __tmp;
    }
    ALPHA = _ALPHA[idx];
    if(chkNAN_v(RIP, __mem, ALPHA)) removepoint(0, _bound_ptnum);
    else{
        float pscl = 0.001;
        if(SYM) V_SYM(__mem, sym_mod);
        if(MB){ pscl *= mb_mod; setpointattrib(0, "mb_modulate", _bound_ptnum, mb_mod, "set"); }
        _bound_P = (vector)__mem;
        _bound_COORD = CLR;
        _bound_pscale = pscl * ALPHA;
        _bound_Alpha = ALPHA;
    }
}

cvex
TheFractalFlameAlgorithm( export int    ptnum     = 0;
                          const  int    VACTIVE[] = {};
                          const  int    XAOS      = 0;
                          const  float  XAOS_TO[] = {};
	                      export float  pscale    = 0;
	                      export float  COORD     = 0;
                          export float  Alpha     = 0;
	                      export vector P         = 0)
{
    _TheFractalFlameAlgorithm(ptnum, VACTIVE, XAOS, XAOS_TO, pscale, COORD, Alpha, P);
}
