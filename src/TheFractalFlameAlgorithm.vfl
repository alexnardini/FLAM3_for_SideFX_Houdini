/*  
 /  Title:      SideFX Houdini FRACTAL FLAME generator: 2D
 /  Author:     Alessandro Nardini
 /  date:       October 2020, Last revised April 2021
 /
 /  info:       Based on the original: "The Fractal Flame Algorithm"
 /  Authors:    Scott Draves, Erik Reckase
 /  Weblink:    https://flam3.com/flame_draves.pdf
 /  Date:       September 2003, Last revised November 2008
 /
 /  Name:       TheFractalFlameAlgorithm    "VEX"
 /
 /  Comment:    The chaos game
*/

#ifndef VOP_OP
#define VOP_OP
#endif
#ifndef VOP_CVEX
#define VOP_CVEX
#endif

#pragma opname  "FLAME"
#pragma oplabel "FLAME"
#pragma opmininputs 1
#pragma opmaxinputs 1

#include <flame.h>

void _TheFractalFlameAlgorithm(int _bound_ptnum, _bound_VACTIVE[]; float _bound_pscale; vector _bound_Cd; vector _bound_P)
{

    int idx;
    float pscale_bg, pscale_ac, fnum_n, fnum_n_bg, fnum_n_ac;
    vector __mem, col_ac, rmp_ac, _col_ac, col_bg, rmp_bg, _col_bg;
    col_bg = rmp_bg = _col_bg = fnum_n_bg = pscale_bg = 0;
    // Build genomes
    genomeSYS SYS; SYS->genomeSYSBuild();
    genome GEM; GEM->genomeBuild(_bound_VACTIVE, SYS);
    genomeParametrics v1GMP, v2GMP, v3GMP, v4GMP;
    v1GMP->genomeParametricsBuild("LOCAL", GEM.sIDX, GEM.v1type);
    v2GMP->genomeParametricsBuild("LOCAL", GEM.sIDX, GEM.v2type);
    v3GMP->genomeParametricsBuild("LOCAL", GEM.sIDX, GEM.v3type);
    v4GMP->genomeParametricsBuild("LOCAL", GEM.sIDX, GEM.v4type);
    // Start the chaos game
    float cdf[] = create_cdf(GEM.IW);
    int iter_f = len(GEM.v1type);
    __mem = biunitcube();
    for(int i=0; i<SYS.iter; i++){
        idx = sample_cdf(cdf, nrandom('twister'));
        vector __tmp = 0;
        if(GEM.PBWEIGHT[idx]>0) VAR_PREBLUR(__mem, GEM.PBWEIGHT[idx]);
        if(GEM.v1weight[idx]!=0) __tmp += FLAME(v1GMP, "LOCAL", __mem, idx, GEM.v1type[idx], GEM.x[idx], GEM.y[idx], GEM.o[idx], GEM.v1weight[idx]);
        if(GEM.v2weight[idx]!=0) __tmp += FLAME(v2GMP, "LOCAL", __mem, idx, GEM.v2type[idx], GEM.x[idx], GEM.y[idx], GEM.o[idx], GEM.v2weight[idx]);
        if(GEM.v3weight[idx]!=0) __tmp += FLAME(v3GMP, "LOCAL", __mem, idx, GEM.v3type[idx], GEM.x[idx], GEM.y[idx], GEM.o[idx], GEM.v3weight[idx]);
        if(GEM.v4weight[idx]!=0) __tmp += FLAME(v4GMP, "LOCAL", __mem, idx, GEM.v4type[idx], GEM.x[idx], GEM.y[idx], GEM.o[idx], GEM.v4weight[idx]);
        if(GEM.POSTL[idx]) affinePOST(__tmp, GEM.px[idx], GEM.py[idx], GEM.po[idx]);
        if(SYS.TMG) __tmp *= maketransform(0, 0, (vector)GEM.gtr, set(0, 0, GEM.grt), (vector)GEM.gsc, 0);
        // @Cd && @pscale
        if(!checkNAN_vector(SYS.DELINVALIDPT, _bound_ptnum, __mem)){
            if((SYS.USEPSCALE + SYS.USEPSCALEVIZ)<2){
                vector  fcol, frmp;
                if(SYS.USEPALETTE){
                    fnum_n    = (float)idx/(float)(iter_f-1);
                    fnum_n_ac = 0.5 * (fnum_n_bg + fnum_n);
                    fnum_n_bg = fnum_n_ac;
                    if(!SYS.PALETTEMODE){
                        col_ac = 0.5 * (col_bg + GEM.vcol[idx]);
                        col_bg = col_ac;
                    }
                    else if(SYS.PALETTEMODE){
                        if(SYS.BLENDWITHVCOL){
                            if(GEM.cvar_override[idx]) frmp = GEM.vcol[idx];
                            else frmp = chramp("../palette", fnum_n_ac);
                            rmp_ac = 0.5 * (rmp_bg + frmp);
                            if(!GEM.cvar_override[idx]){
                                vector paletteHSV  = chv("../palettehsv_");
                                vector rmp_acHSV = rgbtohsv(rmp_ac);
                                rmp_acHSV[0] += paletteHSV[0];
                                rmp_acHSV[1] *= paletteHSV[1];
                                rmp_acHSV[2] *= paletteHSV[2];
                                rmp_ac = hsvtorgb(rmp_acHSV);
                            }
                            rmp_bg = rmp_ac;
                            float vblend = chf("../vblend");
                            if(vblend>0){
                                _col_ac = 0.5 * (_col_bg + GEM.vcol[idx]);
                                _col_bg = _col_ac;
                                col_ac  = lerp(rmp_ac, _col_ac, vblend);
                            }
                            else col_ac=rmp_bg;
                            }
                        else{
                            if(GEM.cvar_override[idx]) fcol = GEM.vcol[idx];
                            else fcol = chramp("../palette", fnum_n_ac);
                            col_ac  = 0.5 * (col_bg + fcol);
                            if(!GEM.cvar_override[idx]){
                                vector paletteHSV  = chv("../palettehsv_");
                                vector col_acHSV   = rgbtohsv(col_ac);
                                col_acHSV[0] += paletteHSV[0];
                                col_acHSV[1] *= paletteHSV[1];
                                col_acHSV[2] *= paletteHSV[2];
                                col_ac = hsvtorgb(col_acHSV);
                            }
                            col_bg=col_ac;
                        }
                    }
                }
                else{
                    col_ac = 0.5 * (col_bg + GEM.vcol[idx]);
                    col_bg = col_ac;
                }
            }
            if(SYS.USEPSCALE){
                pscale_ac = 0.5 * (pscale_bg +  GEM.vpscale[idx]);
                pscale_bg = pscale_ac;
            }
        }
        else{ removepoint(0, _bound_ptnum); break; }

        __mem = __tmp;
    }
    if(SYS.FF){
        vector __tmp = 0;
        if(GEM.ffv1weight!=0) __tmp += FLAME(v1GMP, "FINAL", __mem, 0, GEM.ffv1type, GEM.fx, GEM.fy, GEM.fo, GEM.ffv1weight);
        if(GEM.ffv2weight!=0) __tmp += FLAME(v1GMP, "FINAL", __mem, 0, GEM.ffv2type, GEM.fx, GEM.fy, GEM.fo, GEM.ffv2weight);
        if(GEM.ffv3weight!=0) __tmp += FLAME(v1GMP, "FINAL", __mem, 0, GEM.ffv3type, GEM.fx, GEM.fy, GEM.fo, GEM.ffv3weight);
        if(SYS.POSTF) affinePOST(__tmp, GEM.pfx, GEM.pfy, GEM.pfo);
        __mem = __tmp;
        removeNAN_vector(SYS.DELINVALIDPT, _bound_ptnum, __mem);
        }
    // If the remaining attribs are valid
    if(!checkNAN_vector(SYS.DELINVALIDPT, _bound_ptnum, col_ac) && !checkNAN_float(SYS.DELINVALIDPT, _bound_ptnum, pscale_ac)){
        if(SYS.symmetry) VAR_SYMMETRY(__mem, chv("../symgpivot"), SYS.sym_mode, SYS.sym_global);
        if(!SYS.USEPSCALE) pscale_ac=1;
        if(SYS.domb) pscale_ac*=SYS.mb_modulate;
        _bound_pscale = pscale_ac;
        if(SYS.USEPSCALE && SYS.USEPSCALEVIZ) _bound_Cd=pscale_ac;
        else{
            if(SYS.USEPALETTE){
                if(SYS.PALETTEMODE==0){
                    if(!checkNAN_float(SYS.DELINVALIDPT, _bound_ptnum, fnum_n_ac)){
                        setpointattrib(0, "iter_n", _bound_ptnum, fnum_n_ac, "set");
                        if(SYS.domb) setpointattrib(0, "mb_modulate", _bound_ptnum, SYS.mb_modulate, "set");
                    }
                    else removepoint(0, _bound_ptnum);
                }
            }
            if(SYS.domb && SYS.vizmb) col_ac*=SYS.mb_modulate;
            _bound_Cd = col_ac;
        }
        _bound_P = __mem;
    }
    else removepoint(0, _bound_ptnum);
}

cvex
TheFractalFlameAlgorithm( export int    ptnum     = 0;
                          const  int    VACTIVE[] = {};
	                      export float  pscale    = 0;
	                      export vector Cd        = 1;
	                      export vector P         = 0)
{
    _TheFractalFlameAlgorithm(ptnum, VACTIVE, pscale, Cd, P);
}
