/*  
 /  Title:      SideFX Houdini FLAM3: 2D
 /  Author:     Alessandro Nardini
 /  date:       October 2020, Last revised May 2022
 /
 /  info:       Based on the original: "The Fractal Flame Algorithm"
 /  Authors:    Scott Draves, Erik Reckase
 /  Weblink:    https://flam3.com/flame_draves.pdf
 /  Date:       September 2003, Last revised November 2008
 /
 /  Name:       TheFractalFlameAlgorithm    "CVEX"
 /
 /  Comment:    Collect variation ACTIVE and XAOS.
 /              This file wont compile on H18.5 and below as the resize() array function
 /              got upgraded in H19 with an optional argument to set a default value for the new indexes.
 /
*/


#pragma opname  "TFFAvactive"
#pragma oplabel "TFFAvactive"
#pragma opmininputs 1
#pragma opmaxinputs 1


#include <functions.h>


void
_TFFAvactive(int _bound_VACTIVE[]; int _bound_XAOS; float _bound_IW[], _bound_XAOS_TO[], _bound_XAOS_FROM[])
{
    int iter_f = chi("../flamefunc");
    int vactive[];
    string sIDX[];
    float IW[];
    
    // ACTIVE vars
    //
    for(int i=0; i<iter_f; ++i){
        string iIDX = itoa(i+1);
        append(vactive, chi(concat("../vactive_", iIDX)));
        float IWcheck = chf(concat("../iw_", iIDX));
        if(IWcheck==0) vactive[i]=0;
        if(!vactive[i]) continue;
        append(IW, chf(concat("../iw_", iIDX)));
        append(sIDX, iIDX);
    }

    // XAOS
    //
    int xaos_chk = 0;
    int size = len(sIDX);
    float _XAOS_TO[], XAOS_TO[], _XAOS_FROM[], XAOS_FROM[];
    for(int i=0; i<size; ++i){

        string varnote = chs(concat("../varnote_", sIDX[i]));
        string varxaos[] = split(varnote, ":");
        float xaos[];

        if(toupper(varxaos[0])=="XAOS"){
            pop(varxaos, 0);
            foreach(string n; varxaos){
                append(xaos, max(atof(n), EPS));
            }
            resize(xaos, iter_f, 1);
        }
        else resize(xaos, iter_f, 1);
        for(int j=0; j<iter_f; ++j){
            if(!vactive[j]) pop(xaos, j);
        }
        
        float IW_xaos[];
        for(int k=0; k<size; ++k){
            append(IW_xaos, IW[i]*IW[k]*xaos[k]);
        }
        if(min(xaos)==max(xaos)){ append(XAOS_TO, create_cdf(IW)); append(_XAOS_TO, IW); }
        else{ append(XAOS_TO, create_cdf(IW_xaos)); append(_XAOS_TO, IW_xaos); xaos_chk=1; }
    }

    _bound_VACTIVE = vactive;
    if(xaos_chk){
        _bound_XAOS = xaos_chk;
        _bound_XAOS_TO = XAOS_TO;
        _bound_IW = create_cdf(IW);
        /*
        // Just in case I need this later
        XAOS_transpose(_XAOS_TO, _XAOS_FROM, size);
        for(int i=0; i<size; ++i){
            int SL = i*size;
            append(XAOS_FROM, create_cdf(_XAOS_FROM[SL:SL+size]));
        }
        _bound_XAOS_FROM = XAOS_FROM;
        */
    }
    else{
        _bound_XAOS = 0;
        _bound_IW = create_cdf(IW);
    }
}

cvex
TFFAvactive(export int VACTIVE[]     = {};
            export int XAOS          = 0;
            export float IW[]        = {};
            export float XAOS_TO[]   = {};
            export float XAOS_FROM[] = {};)
{
    _TFFAvactive(VACTIVE, XAOS, IW, XAOS_TO, XAOS_FROM);
}
