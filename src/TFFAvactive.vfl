/*  
 /  Title:      SideFX Houdini FRACTAL FLAME generator: 2D
 /  Author:     Alessandro Nardini
 /  date:       October 2020, Last revised January 2022
 /
 /  info:       Based on the original: "The Fractal Flame Algorithm"
 /  Authors:    Scott Draves, Erik Reckase
 /  Weblink:    https://flam3.com/flame_draves.pdf
 /  Date:       September 2003, Last revised November 2008
 /
 /  Name:       TheFractalFlameAlgorithm    "VEX"
 /
 /  Comment:    Collect variation ACTIVE and simple XAOS.
 /
*/


#ifndef VOP_OP
#define VOP_OP
#endif
#ifndef VOP_CVEX
#define VOP_CVEX
#endif

#pragma opname  "TFFAvactive"
#pragma oplabel "TFFAvactive"
#pragma opmininputs 1
#pragma opmaxinputs 1


void
_TFFAvactive(int _bound_VACTIVE[]; float _bound_XAOS[])
{
    int iter_f = chi("../flamefunc");
    string sIDX[];
    int vactive[];
    float IW[];
    // ACTIVE vars
    //
    for(int i=0; i<iter_f; i++){
        string iIDX = itoa(i+1);
        append(vactive, chi(concat("../vactive_", iIDX)));
        float IWcheck = chf(concat("../iw_", iIDX));
        if(IWcheck==0) vactive[i]=0;
        if(!vactive[i]) continue;
        append(IW, chf(concat("../iw_", iIDX)));
        append(sIDX, iIDX);
    }

    // XAOS
    //
    float XAOS[], _xaos[];
    for(int i=0; i<len(sIDX); i++){

        string varnote = chs(concat("../varnote_", sIDX[i]));
        string note[] = split(varnote, ":");
        float notef[], xaos[];

        if(toupper(note[0])=="XAOS"){
            pop(note, 0);
            foreach(string n; note){
                append(notef, atof(n));
            }
            resize(notef, iter_f, 1);
        }
        else resize(notef, iter_f, 1);

        for(int j=0; j<iter_f;j++){
            if(!vactive[j]) pop(notef, j);
        }
        
        for(int j=0; j<len(sIDX); j++){
            append(xaos, notef[j]);
        }

        float IW_xaos[];
        for(int k=0; k<len(sIDX); k++){
            append(IW_xaos, IW[i]*IW[k]*xaos[k]);
        }
        append(XAOS, create_cdf(IW_xaos));
    }

    _bound_VACTIVE = vactive;
    _bound_XAOS = XAOS;
}

cvex
TFFAvactive(export int VACTIVE[] = {};
            export float XAOS[] = {})
{
    _TFFAvactive(VACTIVE, XAOS);
}
