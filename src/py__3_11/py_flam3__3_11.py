from __future__ import division
from __future__ import annotations

__author__ = "F stands for liFe ( made in Italy )"
__copyright__ = "© 2021 F stands for liFe"

__py_version__ = "3.11.7" # H20.5
__license__ = "GPL v3.0"
__maintainer__ = "Alessandro Nardini"

import hou
import nodesearch

import os
import json
import colorsys
import traceback
import lxml.etree as lxmlET

import builtins

__pyside_version__: int | None = None
try:
    from PySide6 import QtWidgets, QtGui, QtCore
    __pyside_version__ = 6
except ImportError:
    try:
        from PySide2 import QtWidgets, QtGui, QtCore
        __pyside_version__ = 2
    except ImportError:
        pass
    else:
        from PySide2.QtSvg import QSvgRenderer
        from PySide2.QtGui import QPainter
else:
    from PySide6.QtSvg import QSvgRenderer
    from PySide6.QtGui import QPainter

from math import sin
from math import cos
from copy import copy
from platform import python_version
from platform import system as platform_system
from collections.abc import Iterable
from collections.abc import Callable
from collections.abc import KeysView
from typing import Any
from typing import Type
from typing import Final
from typing import Never
from typing import TypeVar
from typing import Protocol
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from typing import TypeAlias
    
from sys import stdout as sys_stdout
from itertools import count as it_count
from itertools import islice as it_islice
from textwrap import wrap
from datetime import datetime
from re import sub as re_sub
from re import search as re_search
from numpy import pad as np_pad
from numpy import resize as np_resize
from numpy import array as np_array
from numpy import float32 as np_float32
from numpy.typing import NDArray
from numpy import transpose as np_transpose
from numpy import searchsorted as np_searchsorted
from webbrowser import open as www_open
from inspect import cleandoc as i_cleandoc

F3H_NODE_TYPE_NAME_CATEGORY: str = 'alexnardini::Sop/FLAM3H'
nodetype: hou.SopNodeType = hou.nodeType(F3H_NODE_TYPE_NAME_CATEGORY)
__version__: str = nodetype.hdaModule().__version__
__status__: str = nodetype.hdaModule().__status__
__module_filename__: str = nodetype.hdaModule().__module_filename__
__range_type__: bool = nodetype.hdaModule().__range_type__  # True for closed range. False for open range
__h_version_min__: int = nodetype.hdaModule().__h_version_min__
__h_version_max__: int = nodetype.hdaModule().__h_version_max__


'''
    Tested on:  PYTHON v3.11.7  (H21)

    Title:      FLAM3H™ H205. SideFX Houdini FLAM3: PYTHON
    Author:     F stands for liFe ( made in Italy )
    date:       April 2025, Last revised February 2026 (cloned from: py_flam3__3_7.py)
                Source file start date: January 2022

    Name:       PY_FLAM3__3_11 "PYTHON" ( The ending filename digits represent the least python version needed to run this code )

    Comment:    Python classes and definitions for:
                - General UX
                - Menus builder
                - Copy/Paste iterator's data
                - Load/Save flame files
                - Load/Save palettes
                - Fully automated UX Xaos
                - Tool's user experience
                - and more...
                
                This code will be turned into a module from within Houdini.

                Note:
                    Some definitions run directly from inside the FLAM3H™ parameters.
                    Please check the file: ../py_flam3__UI_PARM_map_H19_to_H205.md
                    to see if any of the definition you are curious about is being used inside any of the FLAM3H™ parameters directly.
                    The file include a list/map of all the definitions used directly inside FLAM3H™ and categorized as:
                        
                        - callback script
                        - menu script
                        - action button script

                INTERACTIVE Section:
                    The interactive python side for this tool is not done;
                    If you select a FLAM3H™ node and press the "enter" key over a viewer nothing will happen.
                    It is something nice to try to implement at some point but as of now, it is not a deal breaker at all
                    and the current implementation of the UX is far more than enough to enjoy the fractal art workflow.

                DOC-STRINGS
                    To distinguish class @staticmethods from the class @methods, the class @methods doc-string Args list always start with the argument: (self):
                    This make it easier to distinguish them when typing their name while checking their infos like for example in VSCode. 


                GLOBALS -> hou.session.*

                    hou.session.F3H_FIRST_INSTANCE_32BIT
                    hou.session.F3H_FIRST_INSTANCE_64BIT
                    hou.session.F3H_SYS_UPDATE_MODE
                    hou.session.F3H_MARKED_ITERATOR_NODE
                    hou.session.F3H_MARKED_ITERATOR_MP_IDX
                    hou.session.F3H_MARKED_FF_NODE
                    hou.session.F3H_MARKED_FF_CHECK
                    hou.session.F3H_SENSOR_CAM_STASH
                    hou.session.F3H_SENSOR_CAM_STASH_TYPE
                    hou.session.F3H_SENSOR_CAM_STASH_COUNT
                    hou.session.F3H_SENSOR_CAM_STASH_DICT
                    hou.session.F3H_SENSOR_CAM_STASH_TYPE_DICT
                    hou.session.H_XF_VIZ_WIRE_WIDTH_STASH_DICT
                    hou.session.H_VIEWPORT_WIRE_WIDTH
                    hou.session.H_CS_STASH_DICT
                    hou.session.F3H_H_VERSION_ALLOWED


                LIST OF CLASSES: (classes names that start with a lowercase: "f3h" are just for namespace purposes)
                
                    f3h_char
                    f3h_HDAsections
                    f3h_userData
                    f3h_cachedUserData
                    f3h_affineDefaults
                    f3h_ffPrmPrx
                    f3h_varsIdentifiers
                    f3h_copyPaste
                    f3h_nodeNames
                    
                    f3h_tabs
                        GLB
                        SYS
                        CP
                        MB
                        IN
                        OUT
                        PREFS
                        ABOUT
                        
                    f3h_pvt

                    F3H_Error(Exception)
                    F3H_Exception
                    
                    flam3h_iterator_prm_names
                    flam3h_iterator_prm_names_collections
                    flam3h_varsPRM
                    flam3h_iterator
                    flam3h_varsPRM_FF
                    flam3h_iterator_FF
                    flam3h_prm_utils
                    flam3h_scripts
                    flam3h_general_utils
                    
                    f3h_icons
                    f3h_menus
                    
                    flam3h_iterator_utils
                    flam3h_palette_utils
                    flam3h_about_utils
                    flam3h_ui_msg_utils
                    
                    xml_keys
                        f3h

                    flam3h_varsPRM_APO
                    
                    _xml
                    _xml_tree
                    in_flame(_xml_tree)
                    in_flame_iter_data(in_flame)
                    in_flame_utils
                    in_flame_checks

                    out_flame_utils
                    out_flame_render_properties(out_flame_utils)
                    out_flame_xforms_data(out_flame_utils)
                    
                    SvgIcon
                    pyside_master_app_names
                    pyside_master_base_proto(Protocol)
                    pyside_utils
                    
                    pyside_master
                        F3H_msg_panel(QtWidgets.QWidget)

                    Note:
                        - Class @properties (or @cached_slot_property) are always defined inbetween the @staticmethods and the class methods.
                        - Global variables are all upper cases. Every upper case variable's name created inside any definition always start with an underscore (_)

'''


# File lock prefix
FLAM3H_LIB_LOCK = 'F3H_LOCK'


# @Decorator
def cached_slot_property(func):
    name = func.__name__

    @property
    def cached(self):
        cache = getattr(self, "_cached_data", None)
        if cache is None:
            cache = {}
            object.__setattr__(self, "_cached_data", cache)
        if name not in cache:
            cache[name] = func(self)
        return cache[name]

    return cached


'''
I'll put the aliases and TypeVars into their own class for namespace
once and if SideFX update to python 3.12 or higher, for now just here.
'''

# TypeVar
T = TypeVar('T')

# TypeAlias
TA_PrmData: TypeAlias = int | float | str | tuple | hou.Ramp | hou.Vector3 | hou.Vector2
TA_Affine: TypeAlias = list[Iterable[float]]
TA_OUT_Pre_Affine: TypeAlias = tuple[tuple[str, ...], tuple[str, ...], tuple[str, ...]]
TA_OUT_Post_Affine: TypeAlias = tuple[tuple[str | list[Never], ...], tuple[str | list[Never], ...], tuple[str | list[Never], ...]]
TA_OUT_Affine_FF: TypeAlias = tuple[str, str, str]
TA_STR_ListUnflattened: TypeAlias = list[list[str]]
TA_XAOS_Collect: TypeAlias = list[list[str | float] | list[Never]]
TA_RoundFloats: TypeAlias = Iterable[Iterable[str | float]]
TA_TypeVarCollection: TypeAlias = str | list | tuple | KeysView
TA_XformVarKeys: TypeAlias = Iterable[str] | dict[str, int] | dict[str, Iterable[str]] | KeysView | None
TA_TypeMaker: TypeAlias = list | float | hou.Vector2 | hou.Vector3 | hou.Vector4
TA_F3H_Init: TypeAlias = tuple[str | None, bool, int, str, bool, bool]
TA_MNode: TypeAlias = hou.SopNode | None
TA_M: TypeAlias = int | None
TA_Menu: TypeAlias = list[int | str]


class f3h_char:
    '''
    Attributes representing allowed characters in various contexts.</br>
    
    '''
    ALLOWED: Final = "_-().:"
    ALLOWED_OUT_AUTO_ADD_ITER_NUM: Final = "_-+!?().: "
    ALLOWED_XFORM_VAL: Final = "0123456789.-e"
    
    
class f3h_HDAsections:
    '''
    HDA section names being used.</br>
    
    '''
    HDA_SECTION_IMG_BANNER: Final = 'FLAM3H_DOC_intro.jpg'
    HDA_SECTION_SVG_LOGO_WHITE: Final = 'iconSVGW.svg'
    HDA_SECTION_SVG_LOGO_RED: Final = 'iconSVGR.svg'


class f3h_userData:
    '''
    FLAM3H™ User data keys used for storing custom information on nodes.</br>
    
    '''
    # Node user data (nodeinfo)
    PRX: Final = 'nodeinfo'
    MARKED_ITER: Final = 'Marked iterator'
    MARKED_FF: Final = 'Marked FF'
    XFVIZ_SOLO: Final = 'XF VIZ'
    # Node user data
    XML_LAST: Final = 'XML_last_loaded'
    
    
class f3h_cachedUserData:
    '''
    FLAM3H™ cached user data keys used for storing custom information on nodes.</br>
    
    '''
    iter_sel: Final = 'iter_sel'
    iter_sel_n: Final = 'iter_sel_n'
    iter_sel_a: Final = 'iter_sel_a'
    iter_sel_w: Final = 'iter_sel_w'
    iter_sel_o: Final = 'iter_sel_o'
    iter_sel_id: Final = 'iter_sel_id'
    iter_xfviz_solo_idx: Final = 'iter_xfviz_solo_idx'
    iter_xfviz_out_sensor: Final = 'iter_xfviz_out_sensor'
    mem_id: Final = 'mem_id'
    edge_case_01: Final = 'edge_case_01'
    cp_presets_menu: Final = 'cp_presets_menu'
    cp_presets_menu_idx: Final = 'cp_presets_menu_idx'
    cp_presets_menu_off: Final = 'cp_presets_menu_off'
    cp_presets_menu_off_idx: Final = 'cp_presets_menu_off_idx'
    cp_presets_filepath: Final = 'cp_presets_filepath'
    in_presets_menu: Final = 'in_presets_menu'
    in_presets_menu_idx: Final = 'in_presets_menu_idx'
    in_presets_menu_off: Final = 'in_presets_menu_off'
    in_presets_menu_off_idx: Final = 'in_presets_menu_off_idx'
    in_presets_filepath: Final = 'in_presets_filepath'
    out_presets_menu: Final = 'out_presets_menu'
    out_presets_filepath: Final = 'out_presets_filepath'
    vars_menu_all_simple: Final = 'vars_menu_all_simple'


class f3h_affineDefaults:
    '''
    FLAM3H™ Affine default values in various formats.</br>
    
    '''
    # Default affine values
    DEFAULT_DICT: Final[dict[str, hou.Vector2 | float]] = {"affine_x": hou.Vector2((1.0, 0.0)), "affine_y": hou.Vector2((0.0, 1.0)), "affine_o": hou.Vector2((0.0, 0.0)), "angle": float(0.0)} # X, Y, O, ANGLE
    DEFAULT_VALS: Final[list[tuple[float, ...] | float]] = [(1.0, 0.0), (0.0, 1.0), (0.0, 0.0), 0.0]
    DEFAULT_IDENT: Final[list[float]] = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]


class f3h_ffPrmPrx:
    '''
    FLAM3H™ FF parametric parameter's name prefixes.</br>
    
    '''
    # FF parametric parameter's prefixes
    # FF posses two sets of parametric variations parameters, one for the VAR named "VARS" and one for the PRE and POST, named "PP: VARS"
    PRM: Final = 'ff'
    PRM_PP: Final = 'fp1'


class f3h_varsIdentifiers:
    '''
    FLAM3H™ Variation identifiers for dependants and parametrics.</br>
    
    '''
    DPT: Final = '*'
    PRM: Final = '...'


class f3h_copyPaste:
    '''
    FLAM3H™ Copy/Paste sections names and messages strings.</br>
    Sections are used as part of the message after performing a copy/paste operation.</br>
    
    '''
    # Message Mark iterators
    DEFAULT_MSG_MARK_ITER: Final = 'Please, mark an iterator first'
    DEFAULT_MSG_MARK_ITER_STATUS_BAR: Final = f"{DEFAULT_MSG_MARK_ITER} to copy parameter's values from."
    DEFAULT_MSG_MARK_FF: Final = 'Please, mark the FF first'
    DEFAULT_MSG_MARK_FF_STATUS_BAR: Final = f"{DEFAULT_MSG_MARK_FF} to copy parameter's values from."

    # copy/paste set note sections names
    DEFAULT_SEC_ALL: Final = '.ALL'
    DEFAULT_SEC_MAIN: Final = '.main'
    DEFAULT_SEC_XAOS: Final = '.xaos'
    DEFAULT_SEC_SHADER: Final = '.shader'
    DEFAULT_SEC_PREVARS: Final = '.PRE'
    DEFAULT_SEC_VARS: Final = '.VAR'
    DEFAULT_SEC_POSTVARS: Final = '.POST'
    DEFAULT_SEC_PREAFFINE: Final = '.pre affine'
    DEFAULT_SEC_POSTAFFINE: Final = '.post affine'
    
    
class f3h_nodeNames:
    '''
    FLAM3H™ OTL contents node names used in various cases.</br>
    
    '''
    # Those node names are hard coded here.
    # If you change those node names inside the FLAM3H™ houdini HDA network, update those global variables as well.
    # If not, some functionalities will stop working.
    DEFAULT_OUT_BBOX_SENSOR: Final = 'OUT_bbox_sensor' # prefix
    DEFAULT_OUT_BBOX_REFRAME: Final = 'OUT_bbox_reframe' # prefix
    DEFAULT_XFVIZGL: Final = 'XFVIZ_GL'
    DEFAULT_TFFA_XAOS: Final = '_TFFAxaos'


class f3h_tabs:
    '''
    FLAM3H™ tabs and parameters names used throughout the code.</br>
    Additionally some miscellaneous constants used throughout the code as well.</br></br>
    
    Mainly for organizational purposes and namespace.</br></br>
    
    * Parameters names always start with the prefix: <b>PRM_</b>
    * Private parameters names always start with the prefix: <b>PVT_PRM_</b>
    * Message parameters names always start with the prefix: <b>MSG_PRM_</b>
    * Default values always start with the prefix: <b>DEFAULT_</b>
    * Message strings always start with the prefix: <b>MSG_</b>
    * Miscellaneous constants can be anything else.</b>

    '''
    # Main FLAME tab in the UI
    PRM_ITERATORS_TAB: Final = 'f_flam3h'
    # Iterators count number parameter
    PRM_ITERATORS_COUNT: Final = 'flamefunc'
    # Node descriptive parameter
    PRM_DESCRIPTIVE: Final = 'descriptive_msg'
    
    # The following dictionaires are to speed up the pairing of the variation type and their weight parameter's names.
    # They are hard coded so they will need to be changed if the parameters names change in the FLAM3H™ UI.
    # PRM_FLAME_TAB_MENU_T_W_MATCH uses the full name without the multi parm index which is then computed on the fly.
    #
    # Inside:
    #           def menu_T_get_var_data(self) -> tuple[int, float]:
    #           def menu_T_FF_get_var_data(self) -> tuple[int, float]:
    PRM_FLAME_TAB_MENU_T_W_MATCH: Final[dict[str, str]] = { 'pre1type_': 'pre1weight_', 
                                                            'pre2type_': 'pre2weight_', 
                                                            'v1type_': 'v1weight_', 
                                                            'v2type_': 'v2weight_', 
                                                            'v3type_': 'v3weight_', 
                                                            'v4type_': 'v4weight_', 
                                                            'p1type_': 'p1weight_'
                                                            }

    PRM_FF_TAB_MENU_T_W_MATCH: Final[dict[str, str]] = {'ffpre1type': 'ffpre1weight', 
                                                        'ffv1type': 'ffv1weight', 
                                                        'ffv2type': 'ffv2weight', 
                                                        'ffp1type': 'ffp1weight', 
                                                        'ffp2type': 'ffp2weight'
                                                        }
    
    # MISC
    # Flash messages timer - This should probably be moved into somwhere else later.
    DEFAULT_FLASH_MESSAGE_TIMER: Final = 2
    DEFAULT_MSG_ZERO_ITERATORS: Final = 'Iterators count set to Zero.'
    
    
    # UI TABS (Most of the FLAME and FF tabs are handled directly by their own classes)
    
    class GLB:
        '''
        Everything related to the GLB tab parameters names and miscellaneous constants.</br>
        
        '''
        # Default globals
        DEFAULT_DENSITY: Final = 500000
        DEFAULT_ITERATIONS: Final = 10
        
        PRM_DENSITY: Final = 'ptcount'
        PRM_DENSITY_PRESETS: Final = 'ptcount_presets'
        PRM_ITERATIONS: Final = 'iter'
        
        
    class SYS:
        '''
        Everything related to the SYS tab parameters names and miscellaneous constants.</br>
        
        '''
        PRM_SELECT_ITERATOR: Final = 'iterlist'
        PRM_XF_VIZ_OFF: Final = 'xfviz_off'
        PRM_XF_VIZ_ON: Final = 'xfviz_on'
        PRM_TAG_SIZE: Final = 'tagsize'
        PRM_FRAME_VIEW_SENSOR: Final = 'frameviewsensor'
        
        
    class CP:
        '''
        Everything related to the CP tab parameters names and miscellaneous constants.</br>
        
        '''
        PRM_PATH: Final = 'palettefile'
        PRM_PALETTE_PRESET_NAME: Final = 'palettename'
        PRM_PALETTE_PRESETS: Final = 'palettepresets'
        PRM_PALETTE_PRESETS_OFF: Final = 'palettepresets_off'
        PRM_SYS_PALETTE_PRESETS: Final = 'sys_palettepresets'
        PRM_SYS_PALETTE_PRESETS_OFF: Final = 'sys_palettepresets_off'
        PRM_RAMP_LOOKUP_SAMPLES_BASES: Final = 'cp_bases'
        PRM_RAMP_LOOKUP_SAMPLES_BASES_DICT: Final[dict[int, str]] = {0: 'linear', 1: 'constant', 2: 'cubic', 3: 'bezier', 4: 'bspline', 5: 'hermite'}
        PRM_RAMP_LOOKUP_SAMPLES: Final = 'cp_lookupsamples'
        PRM_RAMP_SRC_NAME: Final = 'palette'
        PRM_RAMP_TMP_NAME: Final = 'palettetmp'
        PRM_RAMP_HSV_NAME: Final = 'palettehsv'
        PRM_PALETTE_256_PLUS: Final = 'cppaletteplus'
        PRM_RAMP_SAVE_HSV: Final = 'savehsv'
        PRM_RAMP_HSV_KEEP_ON_LOAD: Final = 'keephsv'
        PRM_RAMP_HSV_VAL_NAME: Final = 'hsv'
        # CP tab: PRIVATE SYSTEM
        PVT_PRM_ISVALID_FILE: Final = 'cpisvalidfile'
        PVT_PRM_ISVALID_PRESET: Final = 'cpisvalidpreset'

        # CP message parameters
        MSG_PRM_PALETTE: Final = 'palettemsg'
        
        # CP MISC
        DEFAULT_FILE_EXT: Final = '.json'
        DEFAULT_AUTO_NAME: Final = 'Palette'
        DEFAULT_COUNT_64: Final = '64' # not used
        DEFAULT_COUNT_128: Final = '128'
        DEFAULT_COUNT_256: Final = '256'
        DEFAULT_COUNT_512: Final = '512' # not used
        DEFAULT_COUNT_1024: Final = '1024'
        DEFAULT_MENU_OPTIONS_ALL: Final[tuple[int, ...]] = (16, 32, 64, 128, 256, 512, 1024) # not used
        DEFAULT_MENU_OPTIONS_PLUS: Final[tuple[int, ...]] = (256, 512, 1024)
        DEFAULT_MSG_PLUS: Final = '[256+]'
        # The following will always be used for now
        # even tho we check for the XML palette format on load.
        DEFAULT_MSG_COLOR_FORMAT: Final = 'RGB'
        DEFAULT_MSG_PALETTE_LOCK: Final = 'Palette lib file: LOCKED'
        
        # CP JSON data keys
        DEFAULT_JSON_KEY_NAME_HEX: Final = 'f3h_hex'
        DEFAULT_JSON_KEY_NAME_HSV: Final = 'f3h_hsv'

    class MB:
        '''
        Everything related to the MB tab parameters names and miscellaneous constants.</br>
        
        '''
        PRM_DO: Final = 'domb'
        PRM_FPS: Final = 'fps'
        PRM_SAMPLES: Final = 'mbsamples'
        PRM_SHUTTER: Final = 'shutter'
        PRM_VIZ: Final = 'vizmb'
        
        
    class IN:
        '''
        Everything related to the IN tab parameters names and miscellaneous constants.</br>
        
        '''
        # On IN Flame preset load set the iteration number to use to this value.
        # This setting will be overwritten if the IN Tab "force iterations on Load" option is turned ON.
        # All of the above settings will be overwritten if the iteration number to use is baked into the Flame preset's name.
        DEFAULT_ITERATIONS_ON_LOAD: Final[int] = 64
        
        PRM_PATH: Final = 'inpath'
        PRM_PRESETS: Final = 'inpresets'
        PRM_PRESETS_OFF: Final = 'inpresets_disabled'
        PRM_SYS_PRESETS: Final = 'sys_inpresets'
        PRM_SYS_PRESETS_OFF: Final = 'sys_inpresets_disabled'
        PRM_USE_ITER_ON_LOAD: Final = 'useiteronload'
        PRM_OVERRIDE_ITER_FLAME_NAME: Final = 'oritername'
        PRM_ITER_NUM_ON_LOAD: Final = 'iternumonload'
        PRM_FLAM3H_AFFINE_STYLE: Final = 'in_f3h_affine'
        PRM_COPY_RENDER_PROPERTIES_ON_LOAD: Final = 'propertiescp'

        # IN tab: PRIVATE SYSTEM
        PVT_PRM_ISVALID_FILE: Final = 'inisvalidfile'
        PVT_PRM_ISVALID_PRESET: Final = 'inisvalidpreset'
        PVT_PRM_CLIPBOARD_TOGGLE: Final = 'inclipboard'

        # IN message parameters
        MSG_PRM_STATS_HEADING: Final = 'flamestats_heading'
        DEFAULT_MSG_PRM_STATS_HEADING: Final = 'IN flame preset infos'
        MSG_PRM_SETTINGS_HEADING: Final = 'flamerender_heading'
        DEFAULT_MSG_PRM_SETTINGS_HEADING: Final = 'IN flame preset render properties'
        MSG_PRM_FLAMESTATS: Final = 'flamestats_msg'
        MSG_PRM_FLAMESENSOR: Final = 'flamesensor_msg'
        MSG_PRM_FLAMERENDER: Final = 'flamerender_msg'
        
        # IN MISC
        DEFAULT_ITERATIONS_FLAME_NAME_DIV: Final = '::' # Divider between the Flame name and the Iterations number baked into the Flame name.
        DEFAULT_MSG_CLIPBOARD_LABEL: Final = '[CLIPBOARD]'
        DEFAULT_MSG_HSV_LABEL: Final = '[HSV]'
        DEFAULT_MSG_FLAMESTATS_LOCK: Final = '-> LOCKED'
        
        
    class OUT:
        '''
        Everything related to the OUT tab parameters names and miscellaneous constants.</br>
        
        '''
        PRM_PATH: Final = 'outpath'
        PRM_PRESETS: Final = 'outpresets'
        PRM_SYS_PRESETS: Final = 'sys_outpresets'
        PRM_FLAME_PRESET_NAME: Final = 'outname'
        PRM_AUTO_ADD_ITER_NUM: Final = 'autoadditer'
        PRM_UPDATE_SENSOR: Final = 'outsensorupdate'
        PRM_HSV_PALETTE_DO: Final = 'outpalette'
        PRM_FLAM3H_AFFINE_STYLE: Final = 'out_f3h_affine'
        PRM_IN_FLAME_NAME_AUTO_FILL: Final = 'out_in_flame_name'
        PRM_USE_FRACTORIUM_PRM_NAMES: Final = 'outfractoriumprm'
        PRM_RENDER_PROPERTIES_EDIT: Final = 'outedit'
        PRM_RENDER_PROPERTIES_SENSOR_ENTER: Final = 'out_sensorviz_disabled'
        PRM_RENDER_PROPERTIES_RES_PRESETS_MENU: Final = 'outrespresets'
        
        PRM_RENDER_SIZE: Final = 'outres'
        PRM_RENDER_CENTER: Final = 'outcenter'
        PRM_RENDER_ROTATE: Final = 'outrotate'
        PRM_RENDER_SCALE: Final = 'outscale'
        PRM_RENDER_QUALITY: Final = 'outquality'
        PRM_RENDER_BRIGHTNESS: Final = 'outbrightness'
        PRM_RENDER_GAMMA: Final = 'outgamma'
        PRM_RENDER_POWER: Final = 'outhighlight'
        PRM_RENDER_K2: Final = 'outk2'
        PRM_RENDER_VIBRANCY: Final = 'outvibrancy'

        # OUT tab: Curves
        PRM_TOGGLE_CC_DEFAULTS_MSG: Final = 'outccdefault'
        PRM_LABEL_CC_DEFAULTS_MSG: Final = 'label_outccdefault'
        PRM_RENDER_PROPERTIES_CURVES: Final = 'outcurvesval'
        PRM_RENDER_PROPERTIES_CURVE_OVERALL: Final = 'outcurveoverallval'
        PRM_RENDER_PROPERTIES_CURVE_RED: Final = 'outcurveredval'
        PRM_RENDER_PROPERTIES_CURVE_GREEN: Final = 'outcurvegreenval'
        PRM_RENDER_PROPERTIES_CURVE_BLUE: Final = 'outcurveblueval'

        # OUT tab: PRIVATE SYSTEM
        PVT_PRM_ISVALID_FILE: Final = 'outisvalidfile'
        PVT_PRM_RENDER_PROPERTIES_SENSOR: Final = 'outsensor'
        
        # OUT message parameters
        MSG_PRM_OUT: Final = 'outmsg'

        # OUT MISC
        DEFAULT_AUTO_NAME: Final = 'Flame'
        DEFAULT_FILE_EXT: Final = '.flame'
        DEFAULT_MSG_OUT_LOCK: Final = 'Flame lib file: LOCKED'
        
        
    class PREFS:
        '''
        Everything related to the PREFS tab parameters names and miscellaneous constants.</br>
        
        '''
        PRM_PALETTE_256_PLUS: Final = 'paletteplus'
        PRM_SOLO_FOLLOW: Final = 'solo_follow'
        PRM_FLASH_MSG: Final = 'flashmsg'
        PRM_ITERATOR_BOOKMARK_ICONS: Final = 'itericons'
        PRM_ENUMERATE_MENU: Final = 'enumeratemenu'
        PRM_CVEX_PRECISION: Final = 'vex_precision'
        PRM_XAOS_MODE: Final = 'xm'
        PRM_CAMERA_HANDLE: Final = 'camhandle'
        PRM_CAMERA: Final= 'fcam'
        PRM_CAMERA_CULL: Final = 'camcull'
        PRM_CAMERA_CULL_AMOUNT: Final = 'cullamount'
        PRM_VIEWPORT_DARK: Final = 'setdark'
        PRM_VIEWPORT_WIRE_WIDTH: Final = 'vpww'
        PRM_VIEWPORT_PT_TYPE: Final = 'vptype'
        PRM_VIEWPORT_PT_SIZE: Final = 'vpptsize'
        # PREFS tab: PRIVATE SYSTEM
        PVT_PRM_H_VALID: Final = 'h_valid'
        PVT_PRM_DOFF: Final = 'doff'
        PVT_PRM_RIP: Final = 'rip'
        PVT_PRM_F3C: Final = 'f3c'
        PVT_PRM_TAG: Final = 'tag'
        PVT_PRM_XAOS_AUTO_SPACE: Final = 'xaosdiv'
        PVT_PRM_AUTO_PATH_CORRECTION: Final = 'autopath'
        PVT_PRM_XF_VIZ: Final = 'vizhandles'
        PVT_PRM_XF_VIZ_SOLO: Final = 'vizhandles_solo'
        PVT_PRM_XF_VIZ_SOLO_MP_IDX: Final = 'vizhandles_solo_mpidx'
        PVT_PRM_XF_FF_VIZ_SOLO: Final = 'vizhandlesff_solo'
        # PREFS tab: PRIVATE SYSTEM MEM
        PVT_PRM_VIEWPORT_PT_SIZE_MEM: Final = 'vpptsize_mem'
        PVT_PRM_VIEWPORT_PT_TYPE_MEM: Final = 'vptype_mem'
        PVT_PRM_VIEWPORT_WIRE_WIDTH_MEM: Final = 'vpww_mem'
        # PREFS tab: PRIVATE SYSTEM CC CURVES
        PVT_PRM_RENDER_CC_CURVES: Final = 'outcurves'
        PVT_PRM_RENDER_CC_CURVE_OVERALL: Final = 'outcurveoverall'
        PVT_PRM_RENDER_CC_CURVE_RED: Final = 'outcurvered'
        PVT_PRM_RENDER_CC_CURVE_GREEN: Final = 'outcurvegreen'
        PVT_PRM_RENDER_CC_CURVE_BLUE: Final = 'outcurveblue'
        # PREFS tab: PRIVATE SYSTEM TEMP PARMS
        PVT_PRM_INT_0: Final = 'tmp_int_0'
        PVT_PRM_INT_1: Final = 'tmp_int_1'
        PVT_PRM_FLOAT_0: Final = 'tmp_float_0'
        PVT_PRM_FLOAT_1: Final= 'tmp_float_1'
        # PREFS tab: PRIVATE self prm names for user data
        PVT_PRM_DATA_PRM_XAOS_MP_MEM: Final = 'flam3h_data_mpmem'
        PVT_PRM_DATA_PRM_XAOS_PREV: Final = 'flam3h_data_xaos'
        PVT_PRM_DATA_PRM_MPIDX: Final = 'flam3h_data_mpidx'


    class ABOUT:
        '''
        Everything related to the ABOUT tab parameters names and miscellaneous constants.</br>
        
        '''
        # ABOUT tab: Message parameters
        MSG_PRM_F3H_ABOUT: Final = 'flam3about_msg'
        MSG_PRM_F3H_PLUGINS: Final = 'flam3plugins_msg'
        MSG_PRM_F3H_WEB: Final = 'flam3h_heading_web'
        MSG_PRM_F3H_GIT: Final = 'flam3h_heading_git'
        MSG_PRM_F3H_INSTA: Final = 'flam3h_heading_insta'
        MSG_PRM_F3H_YOUTUBE: Final = 'flam3h_heading_youtube'
        MSG_PRM_FLAM3_PDF: Final = 'flam3_heading_pdf'
        MSG_PRM_FLAM3_GIT: Final = 'flam3_heading_git'
        MSG_PRM_FRACT_GITHUB: Final = 'fract_heading_git'
        MSG_PRM_FRACT_WEB: Final = 'fract_heading_web'
        
        
class f3h_pvt:
    '''
    All FLAM3H™ private parameters names that are supposed to always stay private.</br>
    
    '''
    PVT_ALL: tuple[str,...] = (  
                                f3h_tabs.CP.PVT_PRM_ISVALID_FILE, 
                                f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 
                                f3h_tabs.IN.PVT_PRM_ISVALID_FILE, 
                                f3h_tabs.IN.PVT_PRM_ISVALID_PRESET, 
                                f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE, 
                                f3h_tabs.OUT.PVT_PRM_ISVALID_FILE, 
                                f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 
                                f3h_tabs.PREFS.PVT_PRM_F3C, 
                                f3h_tabs.PREFS.PVT_PRM_XAOS_AUTO_SPACE,
                                f3h_tabs.PREFS.PVT_PRM_INT_0,
                                f3h_tabs.PREFS.PVT_PRM_INT_1,
                                f3h_tabs.PREFS.PVT_PRM_FLOAT_0,
                                f3h_tabs.PREFS.PVT_PRM_FLOAT_1,
                                f3h_tabs.PREFS.PVT_PRM_H_VALID,
                                f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_SIZE_MEM,
                                f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_TYPE_MEM,
                                f3h_tabs.PREFS.PVT_PRM_VIEWPORT_WIRE_WIDTH_MEM,
                                # The following are FLAM3H™ UI utility parameters
                                # hence they do not have a class attribute and only hard coded here.
                                "cpdisable",
                                "hide_palette",
                                "indisable",
                                "outdisable",
                                "prefsdisable",
                                "aboutdisable"
                                )


# FLAM3H™ EXCEPTIONS start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class F3H_Error(Exception):
    """
class F3H_Error(Exception)

If I find more time I'd like to expand on this</br>
and make this entire file more verbose and friendly.

For now just here as the beginning of something.</br>
Need to review this entire file again and carefully grow from there.

@STATICMETHODS
*

@METHODS
*

    """    
    
    __slots__ = ("_message")
    
    def __init__(self, message: str) -> None:
        """
        Args:
            (self):
            message(str): CustomError message
            
        Returns:
            (None):
        """  
        super().__init__(message)
        self._message: str = message
        
        
    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @property
    def message(self) -> str:
        return self._message
    
    
class F3H_Exception:
    """
class F3H_Exception

@STATICMETHODS
F3H_traceback_print_infos(e: Any, traceback_info: bool = False, extra_info: str | None = None) -> None:

@METHODS


    """    
    
    __slots__ = ("_kwargs", "_node")
    
    def __init__(self, kwargs: dict) -> None:
        """
        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """  
        self._kwargs: dict[str, Any] = kwargs
        self._node: hou.SopNode = kwargs['node']
        
    
    @staticmethod
    def F3H_traceback_print_infos(e: Any, traceback_info: bool = False, extra_info: str | None = None) -> None:
        """ Simple print exception infos.</br>
        Additionally it can print also the full traceback infos.
        
        Args:
            e(Any): Any of the exceptions type.
            traceback_info(bool): Default to: False</br>If True, it will print also the full traceback.
            extra_info(str | None): Default to: None</br>Add a string message to print it under a: "Extra info" message
            
        Returns:
            (None):
        """  
        exc_type: str = type(e).__name__

        # Extract detailed traceback information
        tb = traceback
        tb_info: traceback.StackSummary = tb.extract_tb(e.__traceback__)

        filename = lineno = None
        # If traceback info is available
        if tb_info:
            last_frame: traceback.FrameSummary = tb_info[-1]
            filename: str | None = last_frame.filename
            lineno: int | None = last_frame.lineno
            
        print(f"FLAM3H™ Exception Type: {exc_type}")
        print(f"\tPY filename: {__module_filename__}")
        print(f"\tModule name: {filename}")
        print(f"\tCode line: {lineno}")
        print(f"\tMessage: {str(e)}")
        if extra_info is not None:
            print(f"\tExtra info: {extra_info}")
        
        # Optional
        if traceback_info:
            print("\nFull Traceback:")
            tb.print_exc(file=sys_stdout)
            
            
    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @property
    def kwargs(self) ->  dict[str, Any]:
        return self._kwargs
    
    @property
    def node(self) -> hou.SopNode:
        return self._node


# FLAM3H™ ITERATOR PRM NAMES start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class flam3h_iterator_prm_names:

    '''
    Mostly, handy to have all those packed into one class
    for easy access everywhere is needed and better readability.
    
    The parameter names for the FF(finalXform) are the same but with a string prefix: 'ff'
    The FF parametric parameter names are as well the same but with a string prefix: 'ff_'
    Main, Xaos and Shader parameters are not included in the FF but only: PRE, VAR, POST, pre affine and post affine.
    
    Note:
        The following definitions:
        
        * def iterator_vactive_and_update(self) -> None:
        * def menu_select_iterator_data(self, data_now: tuple[list[Any] | Any, ...], data_names: tuple[str, ...]) -> TA_Menu:
        * def menu_copypaste(self) -> TA_Menu:
        * def menu_copypaste_FF(self) -> TA_Menu:
        * def iterator_affine_scale(self) -> None:
        * def iterator_post_affine_scale(self) -> None:
        * def iterator_FF_affine_scale(self) -> None:
        * def iterator_FF_post_affine_scale(self) -> None:
        * def menu_T_get_var_data(self) -> tuple[int, float]:
        * def menu_T_FF_get_var_data(self) -> tuple[int, float]:
        * f3h_tabs.PRM_FLAME_TAB_MENU_T_W_MATCH
        * f3h_tabs.PRM_FF_TAB_MENU_T_W_MATCH
        .
        are not using this class
        but have Houdini parameter's names hard coded inside in an attempt to try to speed up a tiny, tiny bit.
            
        If you update/change the following values and the FLAM3H™ HDA parameter's names,
        please update inside the above mentioned definitions as well.
    
    '''
    
    __slots__ = ("main_xf_viz", "main_mpmem", "main_note", "main_prmpastesel", "main_selmem", "main_vactive", "main_weight", 
                 "xaos", 
                 "shader_color", "shader_speed", "shader_alpha", 
                 "prevar_blur", "prevar_weight_blur", "prevar_type_1", "prevar_type_2", "prevar_weight_1", "prevar_weight_2", 
                 "var_type_1", "var_type_2", "var_type_3", "var_type_4", "var_weight_1", "var_weight_2", "var_weight_3", "var_weight_4", 
                 "postvar_type_1", "postvar_type_2", "postvar_weight_1", "postvar_weight_2", 
                 "preaffine_scale", "preaffine_x", "preaffine_y", "preaffine_o", "preaffine_ang", 
                 "postaffine_do", "postaffine_scale", "postaffine_x", "postaffine_y", "postaffine_o", "postaffine_ang")
    
    def __init__(self) -> None:
        """
        Args:
            (self):
            
        Returns:
            (None):
        """  
        # ITERATOR
        #
        # Main
        self.main_xf_viz: Final = 'xfviz'
        self.main_mpmem: Final = 'mpmem' # auto set xaos: custom data
        self.main_note: Final = 'note'
        self.main_prmpastesel: Final = 'prmpastesel'
        self.main_selmem: Final = 'selmem' # custom data
        self.main_vactive: Final = 'vactive'
        self.main_weight: Final = 'iw'
        # Xaos
        self.xaos: Final[str] = 'xaos'
        # Shader
        self.shader_color: Final = 'clr'
        self.shader_speed: Final = 'clrspeed'
        self.shader_alpha: Final = 'alpha'
        # PRE 
        self.prevar_blur: Final = 'preblurtype' # this can be omitted as it is always zero
        self.prevar_weight_blur: Final = 'preblurweight'
        self.prevar_type_1: Final = 'pre1type'
        self.prevar_type_2: Final = 'pre2type'
        self.prevar_weight_1: Final = 'pre1weight'
        self.prevar_weight_2: Final = 'pre2weight'
        # VAR
        self.var_type_1: Final = 'v1type'
        self.var_type_2: Final = 'v2type'
        self.var_type_3: Final = 'v3type'
        self.var_type_4: Final = 'v4type'
        self.var_weight_1: Final = 'v1weight'
        self.var_weight_2: Final = 'v2weight'
        self.var_weight_3: Final = 'v3weight'
        self.var_weight_4: Final = 'v4weight'
        # POST
        self.postvar_type_1: Final = 'p1type'
        self.postvar_type_2: Final = 'p2type'
        self.postvar_weight_1: Final = 'p1weight'
        self.postvar_weight_2: Final = 'p2weight'
        # pre affine
        self.preaffine_scale: Final = 'scl' # this do not really need to be stored/copied as it modify the pre affine only.
        self.preaffine_x: Final = 'x'
        self.preaffine_y: Final = 'y'
        self.preaffine_o: Final = 'o'
        self.preaffine_ang: Final = 'ang'
        # post affine
        self.postaffine_do: Final = 'dopost'
        self.postaffine_scale: Final = 'pscl' # this do not really need to be stored/copied as it modify the post affine only.
        self.postaffine_x: Final = 'px'
        self.postaffine_y: Final = 'py'
        self.postaffine_o: Final = 'po'
        self.postaffine_ang: Final = 'pang'
    

# FLAM3H™ ITERATOR PRM NAMES COLLECTIONS start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class flam3h_iterator_prm_names_collections(flam3h_iterator_prm_names):
    """
    Args:
        flam3h_iterator_prm_names ([class]): [inherit properties methods from the flam3h_iterator_prm_names class]
    """    
    
    '''
    Mostly, handy to have all those packed into one class.
    They are split into tuple parameters (vector, vector2, vector4...) and not (int, float, string..)
    
    The parametric's parameter names for the FF(finalXform) are the same but with a string prefix: 'ff_' ( f"{f3h_ffPrmPrx.PRM}_{...}" )
    The FF PRE and POST parametric parameter names are as well the same but with a string prefix: 'fp1_' ( f"{PRX_FF_PRM_POST}_{...}" )
    
    If you add new parametric variations add their base parameter's names here accordingly (tuple or not tuple).
    
    '''
    
    __slots__ = ("_prm_iterator_tuple", "_prm_iterator", "_prm_iterator_vars_all", "_prm_FF_tuple", "_prm_FF", "_prm_FF_vars_all", 
                 "_prm_parametrics_tuple", "_prm_parametrics")
    
    def __init__(self) -> None:
        """
        Args:
            (self):
            
        Returns:
            (None):
        """  
        super().__init__()
        
        self._prm_iterator_tuple: tuple[str, ...] = (self.preaffine_x, self.preaffine_y, self.preaffine_o, self.postaffine_x, self.postaffine_y, self.postaffine_o)
        self._prm_iterator: tuple[str, ...] = (self.main_note, self.main_weight, self.xaos, self.shader_color, self.shader_speed, self.shader_alpha, self.prevar_blur, self.prevar_weight_blur, self.prevar_type_1, self.prevar_weight_1, self.prevar_type_2, self.prevar_weight_2, self.var_type_1, self.var_weight_1, self.var_type_2, self.var_weight_2, self.var_type_3, self.var_weight_3, self.var_type_4, self.var_weight_4, self.postvar_type_1, self.postvar_weight_1, self.preaffine_scale, self.preaffine_ang, self.postaffine_do, self.postaffine_scale, self.postaffine_ang)
        self._prm_iterator_vars_all: tuple[str, ...] = (self.prevar_blur, self.prevar_weight_blur, self.prevar_type_1, self.prevar_weight_1, self.prevar_type_2, self.prevar_weight_2, self.var_type_1, self.var_weight_1, self.var_type_2, self.var_weight_2, self.var_type_3, self.var_weight_3, self.var_type_4, self.var_weight_4, self.postvar_type_1, self.postvar_weight_1)
        self._prm_FF_tuple: tuple[str, ...] = (self.preaffine_x, self.preaffine_y, self.preaffine_o, self.postaffine_x, self.postaffine_y, self.postaffine_o)
        self._prm_FF: tuple[str, ...] = (self.main_note, self.prevar_type_1, self.prevar_weight_1, self.var_type_1, self.var_weight_1, self.var_type_2, self.var_weight_2, self.postvar_type_1, self.postvar_weight_1, self.postvar_type_2, self.postvar_weight_2, self.preaffine_scale, self.preaffine_ang, self.postaffine_do, self.postaffine_scale, self.postaffine_ang)
        self._prm_FF_vars_all: tuple[str, ...] = (self.prevar_type_1, self.prevar_weight_1, self.var_type_1, self.var_weight_1, self.var_type_2, self.var_weight_2, self.postvar_type_1, self.postvar_weight_1, self.postvar_type_2, self.postvar_weight_2)
        # Hard coded as this may be the only case with need those parameters.
        # Those are the houdini parametric variations parameters base names.
        self._prm_parametrics_tuple: tuple[str, ...] = ("curlc", "ngon", "pdjw", "blob", "julian", "juliascope", "fan2", "rectangles", "pie", "disc2", "supershape", "supershapen", "flower", "conic", "parabola", "bent2xy", "cpow", "lazysusanxyz", "lazysusan", "modulusXYZ", "oscope", "popcorn2xyz", "separationxyz", "separationinsidexyz", "splitxyz", "splitsxyz", "stripes", "wedge", "wedgejulia", "wedgesph", "whorl", "waves2scalexyz", "waves2freqxyz", "auger", "mobiusre", "mobiusim", "curvexyzlenght", "curvexyzamp", "persp", "bwraps", "bwrapstwist", "polynomialpow", "polynomiallc", "polynomialsc", "cropltrb", "cropaz", "ptsym")
        self._prm_parametrics: tuple[str, ...] = ("rings2val", "radialblur", "bipolarshift", "cellsize", "escherbeta", "popcorn2c", "fluxspread")
        
    
    # CLASS: PROPERTIES
    ##########################################
    ##########################################
    
    @property
    def prm_iterator_tuple(self) -> tuple[str, ...]:
        return self._prm_iterator_tuple
    
    @property
    def prm_iterator(self) -> tuple[str, ...]:
        return self._prm_iterator
    
    @property
    def prm_iterator_vars_all(self) -> tuple[str, ...]:
        return self._prm_iterator_vars_all
    
    @property
    def prm_FF_tuple(self) -> tuple[str, ...]:
        return self._prm_FF_tuple
    
    @property
    def prm_FF(self) -> tuple[str, ...]:
        return self._prm_FF
    
    @property
    def prm_FF_vars_all(self) -> tuple[str, ...]:
        return self._prm_FF_vars_all
    
    @property
    def prm_parametrics_tuple(self) -> tuple[str, ...]:
        return self._prm_parametrics_tuple
    
    @property
    def prm_parametrics(self) -> tuple[str, ...]:
        return self._prm_parametrics


# FLAM3H™ VARSPRM start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class flam3h_varsPRM:
    """
class flam3h_varsPRM

@STATICMETHODS
* __populate_keys_and_values(keys: list, values: list, item: int | str, id: int) -> None:
* __populate_linear_list(linear: list, item: str, id: int, spacer: bool = True) -> None:

@METHODS
* vars_all(self) -> list[str]:
* menu_vars_all(self, _PB: bool = False) -> list[tuple[int, str]]:
* menu_vars_no_PRM(self, _PB: bool = False) -> list[tuple[int, str]]:
* build_menu_vars_all_linear(self, _PB: bool = False) -> TA_Menu:
* build_menu_vars_all_indexes(self, _PB: bool = False) -> dict[int, int]:

    """ 
    
    __slots__ = ("varsPRM",)
    
    def __init__(self) -> None:
        """
        Args:
            (self):
            
        Returns:
            (None):
        """  
        # Collect all variations and their parametric parameters properly ordered as per flame*.h files
        # Those names are what it will appear inside each variation's menu.
        self.varsPRM: tuple = ( ("Linear", 0), 
                                ("Sinusoidal", 0), 
                                ("Spherical", 0), 
                                ("Swirl", 0), 
                                ("Horseshoe", 0), 
                                ("Polar", 0), 
                                ("Handkerchief", 0), 
                                ("Heart", 0), 
                                ("Disc", 0), 
                                ("Spiral", 0), 
                                ("Hyperbolic", 0), 
                                ("Diamond", 0), 
                                ("Ex", 0), 
                                ("Julia", 0), 
                                ("Bent", 0), 
                                (f"Waves{f3h_varsIdentifiers.DPT}", 0), 
                                ("Fisheye", 0), 
                                (f"Popcorn{f3h_varsIdentifiers.DPT}", 0), 
                                ("Exponential", 0), 
                                ("Power", 0), 
                                ("Cosine", 0), 
                                (f"Rings{f3h_varsIdentifiers.DPT}", 0), 
                                (f"Fan{f3h_varsIdentifiers.DPT}", 0), 
                                ("Bubble", 0), 
                                ("Cylinder", 0), 
                                ("Eyefish", 0), 
                                ("Blur", 0), 
                                (f"Curl{f3h_varsIdentifiers.PRM}", ("curlc_", 1), 1), 
                                (f"Ngon{f3h_varsIdentifiers.PRM}", ("ngon_", 1), 1), 
                                (f"Pdj{f3h_varsIdentifiers.PRM}", ("pdjw_", 1), 1), 
                                (f"Blob{f3h_varsIdentifiers.PRM}", ("blob_", 1), 1), 
                                (f"JuliaN{f3h_varsIdentifiers.PRM}", ("julian_", 1), 1), 
                                (f"Juliascope{f3h_varsIdentifiers.PRM}", ("juliascope_", 1), 1), 
                                ("Gaussian blur", 0), 
                                (f"Fan2{f3h_varsIdentifiers.PRM}", ("fan2_", 1), 1), 
                                (f"Rings2{f3h_varsIdentifiers.PRM}", ("rings2val_", 0), 1), 
                                (f"Rectangles{f3h_varsIdentifiers.PRM}", ("rectangles_", 1), 1), 
                                (f"Radialblur{f3h_varsIdentifiers.PRM}", ("radialblur_", 0), 1), 
                                (f"Pie{f3h_varsIdentifiers.PRM}", ("pie_", 1), 1), 
                                ("Arch", 0), 
                                ("Tangent", 0), 
                                ("Square", 0), 
                                ("Rays", 0), 
                                ("Blade", 0), 
                                ("Secant2", 0), 
                                ("Twintrian", 0), 
                                ("Cross", 0), 
                                (f"Disc2{f3h_varsIdentifiers.PRM}", ("disc2_", 1), 1), 
                                (f"Supershape{f3h_varsIdentifiers.PRM}", ("supershape_", 1), ("supershapen_", 1), 1), 
                                (f"Flower{f3h_varsIdentifiers.PRM}", ("flower_", 1), 1), 
                                (f"Conic{f3h_varsIdentifiers.PRM}", ("conic_", 1), 1), 
                                (f"Parabola{f3h_varsIdentifiers.PRM}", ("parabola_", 1), 1), 
                                (f"Bent2{f3h_varsIdentifiers.PRM}", ("bent2xy_", 1), 1),
                                (f"Bipolar{f3h_varsIdentifiers.PRM}", ("bipolarshift_", 0), 1),
                                ("Boarders", 0),
                                ("Butterfly", 0), 
                                (f"Cell{f3h_varsIdentifiers.PRM}", ("cellsize_", 0), 1), 
                                (f"Cpow{f3h_varsIdentifiers.PRM}", ("cpow_", 1), 1), 
                                ("Edisc", 0), 
                                ("Elliptic", 0), 
                                ("Noise", 0), 
                                (f"Escher{f3h_varsIdentifiers.PRM}", ("escherbeta_", 0), 1), 
                                ("Foci", 0), 
                                (f"Lazysusan{f3h_varsIdentifiers.PRM}", ("lazysusanxyz_", 1), ("lazysusan_", 1), 1), 
                                ("Loonie", 0), 
                                ("Pre blur", 0), 
                                (f"Modulus{f3h_varsIdentifiers.PRM}", ("modulusXYZ_", 1), 1), 
                                (f"Oscope{f3h_varsIdentifiers.PRM}", ("oscope_", 1), 1), 
                                ("Polar2", 0), 
                                (f"Popcorn2{f3h_varsIdentifiers.PRM}", ("popcorn2xyz_", 1), ("popcorn2c_", 0), 1), 
                                ("Scry", 0), 
                                (f"Separation{f3h_varsIdentifiers.PRM}", ("separationxyz_", 1), ("separationinsidexyz_", 1), 1), 
                                (f"Split{f3h_varsIdentifiers.PRM}", ("splitxyz_", 1), 1), 
                                (f"Splits{f3h_varsIdentifiers.PRM}", ("splitsxyz_", 1), 1), 
                                (f"Stripes{f3h_varsIdentifiers.PRM}", ("stripes_", 1), 1), 
                                (f"Wedge{f3h_varsIdentifiers.PRM}", ("wedge_", 1), 1), 
                                (f"Wedgejulia{f3h_varsIdentifiers.PRM}", ("wedgejulia_", 1), 1),
                                (f"Wedgesph{f3h_varsIdentifiers.PRM}", ("wedgesph_", 1), 1), 
                                (f"Whorl{f3h_varsIdentifiers.PRM}", ("whorl_", 1), 1), 
                                (f"Waves2{f3h_varsIdentifiers.PRM}", ("waves2scalexyz_", 1), ("waves2freqxyz_", 1), 1), 
                                ("Exp", 0), 
                                ("Log", 0), 
                                ("Sin", 0), 
                                ("Cos", 0), 
                                ("Tan", 0), 
                                ("Sec", 0), 
                                ("Csc", 0), 
                                ("Cot", 0), 
                                ("Sinh", 0), 
                                ("Cosh", 0), 
                                ("Tanh", 0), 
                                ("Sech", 0), 
                                ("Csch", 0), 
                                ("Coth", 0), 
                                (f"Auger{f3h_varsIdentifiers.PRM}", ("auger_", 1), 1), 
                                (f"Flux{f3h_varsIdentifiers.PRM}", ("fluxspread_", 0), 1), 
                                (f"Mobius{f3h_varsIdentifiers.PRM}", ("mobiusre_", 1), ("mobiusim_", 1), 1),
                                (f"Curve{f3h_varsIdentifiers.PRM}", ("curvexyzlenght_", 1), ("curvexyzamp_", 1), 1), 
                                (f"Perspective{f3h_varsIdentifiers.PRM}", ("persp_", 1), 1), 
                                (f"Bwraps{f3h_varsIdentifiers.PRM}", ("bwraps_", 1), ("bwrapstwist_", 1), 1),
                                ("Hemisphere", 0), 
                                (f"Polynomial{f3h_varsIdentifiers.PRM}", ("polynomialpow_", 1), ("polynomiallc_", 1), ("polynomialsc_", 1), 1),
                                (f"Crop{f3h_varsIdentifiers.PRM}", ("cropltrb_", 1), ("cropaz_", 1), 1),
                                ("Unpolar", 0), 
                                ("Glynnia", 0),
                                (f"Point sym{f3h_varsIdentifiers.PRM}", ("ptsym_", 1), 1) # point symmetry
                                )
            
    
    @staticmethod
    def __populate_keys_and_values(keys: list, values: list, item: int | str, id: int) -> None:
        """ Populate the keys and values lists. This is to be used inside a loop.</br>
        Specifically designed to be used in a list comprehension inside:
        * def build_menu_vars_all_indexes(self) -> dict[int, int]:
        
        Args:
            keys(str): the keys empty list to populate
            values(str): the values empty list to populate
            item(str): The current loop iteration item
            id(int): The current loop iteration index
            
        Returns:
            (None):
        """
        try:
            int(item)
            
        except ValueError:
            values.append(id)
            
        else:
            keys.append(item)
            
            
    @staticmethod
    def __populate_linear_list(menu: TA_Menu, item: str, id: int, spacer: bool = True) -> None:
        """ Populate linear list. This is to be used inside a loop.</br>
        Specifically designed to be used in a list comprehension inside:
        * def build_menu_vars_all_linear(self, _PB: bool = False) -> TA_Menu:
        
        Args:
            menu(TA_Menu): the empty menu to populate
            item(str): The current loop iteration item
            id(int): The current loop iteration index
            spacer(bool): Default to: True</br>Add a spacer to the ent of the item to conform with the desired menu label length
            
        Returns:
            (None):
        """
        menu.append(id)
        if spacer: menu.append(f"{item}                    ") # 20 times \s, so we can clamp later during the build of the menus
        else: menu.append(item)
    
    
    def vars_all(self) -> list[str]:
        """Build a list of all the variation names properly ordered as per flame*.h files.</br>
        
        Args:
            (self):
            
        Returns:
            (list): return a list of all the variation names properly ordered as per flame*.h files
        """

        return list(map(lambda x: x[0], self.varsPRM))
    
    
    def menu_vars_all(self, _PB: bool = False) -> list[tuple[int, str]]:
        """This is used to generate the following list: MENU_VARS_ALL</br>
        
        Args:
            (self):
            _PB(bool): Default to: False</br>When set to True it will include the pre_blur variation in the menu variation lists.
            
        Returns:
            (list[tuple[int, str]]): return an enumerated variations menu list with "linear" being the first one for convenience
        """

        vars_no_lin: list[tuple[int, str]] = list(enumerate(self.vars_all()))[1:]
        if not _PB: vars_no_lin.remove((65, 'Pre blur')) # remove "pre blur" as it is hard coded into the chaos game.
        vars_sorted: list[tuple[int, str]] = sorted(vars_no_lin, key=lambda var: var[1])
        return list(enumerate(['Linear'])) + vars_sorted
    
    
    def menu_vars_no_PRM(self, _PB: bool = False) -> list[tuple[int, str]]:
        """Build a list of all the variation names properly ordered as per flame*.h files without the parametric variations in it.</br>
        
        Args:
            (self):
            _PB(bool): Default to: False</br>When set to True it will include the pre_blur variation in the menu variation lists.
            
        Returns:
            (list[tuple[int, str]]): return a list of all the variation names properly ordered as per flame*.h files without the parametric variations in it.
        """   
        return list(map(lambda x: x, filter(lambda x: x[1][-3:] != f3h_varsIdentifiers.PRM, self.menu_vars_all(_PB))))
    
    
    def build_menu_vars_all_linear(self, _PB: bool = False) -> TA_Menu:
        """This is used to generate the following list: f3h_menus.VARS_ALL_SIMPLE</br>
        
        Args:
            (self):
            _PB(bool): Default to: False</br>When set to True it will include the pre_blur variation in the menu variation lists.
            
        Returns:
            (TA_Menu): return an linearly composed list with the var index followed by the var name as if it was a Houdini valid menu data
        """  
        menu: TA_Menu = []
        for id, item in self.menu_vars_all(_PB): self.__populate_linear_list(menu, item, id)
        return menu
    
    
    def build_menu_vars_all_indexes(self, _PB: bool = False) -> dict[int, int]:
        """This is used to generate the following dict: f3h_menus.VARS_ALL_INDEXES</br>
        
        Args:
            (self):
            _PB(bool): Default to: False</br>When set to True it will include the pre_blur variation in the menu variation lists.
            
        Returns:
            (dict): a dictionary for the variation indexes used by the menu_T_ICONS definitions
        """   
        keys: list = []
        values: list = []
        for id, item in enumerate(self.build_menu_vars_all_linear(_PB)): self.__populate_keys_and_values(keys, values, item, id)
        return dict(zip(keys, values))


class flam3h_iterator(flam3h_iterator_prm_names):
    """Note that the underscore (_) before the iterator number</br>
    has been included already for convenience.</br>
    
    Args:
        flam3h_iterator_prm_names ([class]): [inherit properties methods from the flam3h_iterator_prm_names class]
    """   
    
    __slots__ = ("_sec_main", "_sec_xaos", "_sec_shader", "_sec_prevarsT", "_sec_prevarsW", "_sec_varsT", "_sec_varsW", "_sec_postvarsT", "_sec_postvarsW", "_sec_preAffine", "_sec_postAffine", 
                 "_allT", "_allMisc")

    def __init__(self) -> None:
        """
        Args:
            (self):
            
        Returns:
            (None):
        """  
        super().__init__()
        
        # SECTIONS method lists
        #
        # (*T)Types have no signature and always to be used with: pastePRM_T_from_list() for now.
        
        # sec_main = ( (f"{n.main_vactive}_", 0), (f"{n.main_weight}_", 0) )
        
        self._sec_main: tuple[tuple[str, int], ...] = ( (f"{self.main_weight}_", 0),) # When copy/paste the main section it will not copy the ON/OFF(vactive) iterator parameter anymore.
        self._sec_xaos: tuple[tuple[str, int], ...] = ( (f"{self.xaos}_", 0),)
        self._sec_shader: tuple[tuple[str, int], ...] = ( (f"{self.shader_color}_", 0), (f"{self.shader_speed}_", 0), (f"{self.shader_alpha}_", 0) )
        self._sec_prevarsT: tuple[str, ...] = ( f"{self.prevar_type_1}_", f"{self.prevar_type_2}_" ) # preblur is omitted as it is always ZERO
        self._sec_prevarsW: tuple[tuple[str, int], ...] = ( (f"{self.prevar_weight_blur}_", 0), (f"{self.prevar_weight_1}_", 0), (f"{self.prevar_weight_2}_", 0) )
        self._sec_varsT: tuple[str, ...] = ( f"{self.var_type_1}_", f"{self.var_type_2}_", f"{self.var_type_3}_", f"{self.var_type_4}_" )
        self._sec_varsW: tuple[tuple[str, int], ...] = ( (f"{self.var_weight_1}_", 0), (f"{self.var_weight_2}_", 0), (f"{self.var_weight_3}_", 0), (f"{self.var_weight_4}_", 0) )
        self._sec_postvarsT: tuple[str, ...] = ( f"{self.postvar_type_1}_",)
        self._sec_postvarsW: tuple[tuple[str, int], ...] = ( (f"{self.postvar_weight_1}_", 0),)
        self._sec_preAffine: tuple[tuple[str, int], ...] = ( (f"{self.preaffine_x}_", 1), (f"{self.preaffine_y}_", 1), (f"{self.preaffine_o}_", 1), (f"{self.preaffine_ang}_", 0) )
        self._sec_postAffine: tuple[tuple[str, int], ...] = ( (f"{self.postaffine_do}_", 0), (f"{self.postaffine_x}_", 1), (f"{self.postaffine_y}_", 1), (f"{self.postaffine_o}_", 1), (f"{self.postaffine_ang}_", 0) )
        
        # ALL method lists
        self._allT: tuple[str, ...] = self._sec_prevarsT + self._sec_varsT + self._sec_postvarsT
        self._allMisc: tuple[tuple[str, int], ...] = self._sec_main + self._sec_shader + self._sec_prevarsW + self._sec_varsW + self._sec_postvarsW + self._sec_preAffine + self._sec_postAffine


    # CLASS: PROPERTIES
    ##########################################
    ##########################################
    
    @property
    def sec_main(self) -> tuple[tuple[str, int], ...]:
        return self._sec_main
    
    @property
    def sec_xaos(self) -> tuple[tuple[str, int], ...]:
        return self._sec_xaos
    
    @property
    def sec_shader(self) -> tuple[tuple[str, int], ...]:
        return self._sec_shader
    
    @property
    def sec_prevarsT(self) -> tuple[str, ...]:
        return self._sec_prevarsT
    
    @property
    def sec_prevarsW(self) -> tuple[tuple[str, int], ...]:
        return self._sec_prevarsW
    
    @property
    def sec_varsT(self) -> tuple[str, ...]:
        return self._sec_varsT
    
    @property
    def sec_varsW(self) -> tuple[tuple[str, int], ...]:
        return self._sec_varsW
    
    @property
    def sec_postvarsT(self) -> tuple[str, ...]:
        return self._sec_postvarsT
    
    @property
    def sec_postvarsW(self) -> tuple[tuple[str, int], ...]:
        return self._sec_postvarsW
    
    @property
    def sec_preAffine(self) -> tuple[tuple[str, int], ...]:
        return self._sec_preAffine
    
    @property
    def sec_postAffine(self) -> tuple[tuple[str, int], ...]:
        return self._sec_postAffine
    
    @property
    def allT(self) -> tuple[str, ...]:
        return self._allT
    
    @property
    def allMisc(self) -> tuple[tuple[str, int], ...]:
        return self._allMisc


# FLAM3H™ VARSPRM FF start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class flam3h_varsPRM_FF(flam3h_varsPRM):
    """
    Args:
        flam3h_varsPRM ([class]): [inherit properties methods from the flam3h_varsPRM class]
    """    
    
    __slots__ = ("prx",)
    
    def __init__(self, prx: str) -> None:
        """
        Args:
            prx (str): The variation's name prefix. This can be any of:
            * f3h_ffPrmPrx.PRM -> ff
            * PRX_FF_PRM_POST -> fp1

        Returns:
            (None):
        """       
        
        super().__init__()
        
        # The FF posses two sets of parameteric parameters; 
        # One for the VAR variations and one for the PRE and POST variations.
        # This prefix will help us pick either one or the other. 
        self.prx = prx

    def varsPRM_FF(self) -> tuple:
        
        px: str = self.prx
        vPRM: tuple = self.varsPRM
        varsPRM_FF: tuple = ( # Linear
                              vPRM[0], 
                              # Sinusoidal
                              vPRM[1], 
                              # Spherical
                              vPRM[2], 
                              # Swirl
                              vPRM[3], 
                              # Horseshoe
                              vPRM[4], 
                              # Polar
                              vPRM[5], 
                              # Handkerchief
                              vPRM[6], 
                              # Heart
                              vPRM[7], 
                              # Disc
                              vPRM[8], 
                              # Spiral
                              vPRM[9], 
                              # Hyperbolic
                              vPRM[10], 
                              # Diamond
                              vPRM[11], 
                              # Ex
                              vPRM[12], 
                              # Julia
                              vPRM[13], 
                              # Bent
                              vPRM[14], 
                              # Waves*
                              vPRM[15], 
                              # Fisheye
                              vPRM[16], 
                              # Popcorn*
                              vPRM[17], 
                              # Exponential
                              vPRM[18], 
                              # Power
                              vPRM[19], 
                              # Cosine
                              vPRM[20], 
                              # Rings*
                              vPRM[21], 
                              # Fan*
                              vPRM[22], 
                              # Bubble
                              vPRM[23], 
                              # Cylinder
                              vPRM[24], 
                              # Eyefish
                              vPRM[25], 
                              # Blur
                              vPRM[26], 
                              # Curl
                              (vPRM[27][0], (f"{px}_{vPRM[27][1][0][:-1]}", 1), 1), 
                              # Ngon
                              (vPRM[28][0], (f"{px}_{vPRM[28][1][0][:-1]}", 1), 1), 
                              # Pdj
                              (vPRM[29][0], (f"{px}_{vPRM[29][1][0][:-1]}", 1), 1), 
                              # Blob
                              (vPRM[30][0], (f"{px}_{vPRM[30][1][0][:-1]}", 1), 1), 
                              # JuliaN
                              (vPRM[31][0], (f"{px}_{vPRM[31][1][0][:-1]}", 1), 1), 
                              # Juliascope
                              (vPRM[32][0], (f"{px}_{vPRM[32][1][0][:-1]}", 1), 1), 
                              # Gaussian blur
                              (vPRM[33][0], 0), 
                              # Fan2
                              (vPRM[34][0], (f"{px}_{vPRM[34][1][0][:-1]}", 1), 1), 
                              # Rings2
                              (vPRM[35][0], (f"{px}_{vPRM[35][1][0][:-1]}", 0), 1), 
                              # Rectangles
                              (vPRM[36][0], (f"{px}_{vPRM[36][1][0][:-1]}", 1), 1), 
                              # Radialblur
                              (vPRM[37][0], (f"{px}_{vPRM[37][1][0][:-1]}", 1), 1), 
                              # Pie
                              (vPRM[38][0], (f"{px}_{vPRM[38][1][0][:-1]}", 1), 1), 
                              # Arch
                              vPRM[39], 
                              # Tangent
                              vPRM[40], 
                              # Square
                              vPRM[41], 
                              # Rays
                              vPRM[42], 
                              # Blade
                              vPRM[43], 
                              # Secant2
                              vPRM[44], 
                              # Twintrian
                              vPRM[45], 
                              # Cross
                              vPRM[46], 
                              # Disc2
                              (vPRM[47][0], (f"{px}_{vPRM[47][1][0][:-1]}", 1), 1), 
                              # Supershape
                              (vPRM[48][0], (f"{px}_{vPRM[48][1][0][:-1]}", 1), (f"{px}_{vPRM[48][2][0][:-1]}", 1), 1), 
                              # Flower
                              (vPRM[49][0], (f"{px}_{vPRM[49][1][0][:-1]}", 1), 1), 
                              # Conic
                              (vPRM[50][0], (f"{px}_{vPRM[50][1][0][:-1]}", 1), 1), 
                              # Parabola
                              (vPRM[51][0], (f"{px}_{vPRM[51][1][0][:-1]}", 1), 1), 
                              # Bent2
                              (vPRM[52][0], (f"{px}_{vPRM[52][1][0][:-1]}", 1), 1), 
                              # Bipolar
                              (vPRM[53][0], (f"{px}_{vPRM[53][1][0][:-1]}", 0), 1), 
                              # Boarders
                              vPRM[54], 
                              # Butterfly
                              vPRM[55], 
                              # Cell
                              (vPRM[56][0], (f"{px}_{vPRM[56][1][0][:-1]}", 0), 1), 
                              # Cpow
                              (vPRM[57][0], (f"{px}_{vPRM[57][1][0][:-1]}", 1), 1), 
                              # Edisc
                              vPRM[58], 
                              # Elliptic
                              vPRM[59], 
                              # Noise
                              vPRM[60], 
                              # Escher
                              (vPRM[61][0], (f"{px}_{vPRM[61][1][0][:-1]}", 0), 1), 
                              # Foci
                              vPRM[62], 
                              # Lazysusan
                              (vPRM[63][0], (f"{px}_{vPRM[63][1][0][:-1]}", 1), (f"{px}_{vPRM[63][2][0][:-1]}", 1), 1), 
                              # Loonie
                              vPRM[64], 
                              # Pre blur
                              vPRM[65], 
                              # Modulus
                              (vPRM[66][0], (f"{px}_{vPRM[66][1][0][:-1]}", 1), 1), 
                              # Oscope
                              (vPRM[67][0], (f"{px}_{vPRM[67][1][0][:-1]}", 1), 1), 
                              # Polar2
                              vPRM[68], 
                              # Popcorn2
                              (vPRM[69][0], (f"{px}_{vPRM[69][1][0][:-1]}", 1), (f"{px}_{vPRM[69][2][0][:-1]}", 0), 1), 
                              # Scry
                              vPRM[70], 
                              # Separation
                              (vPRM[71][0], (f"{px}_{vPRM[71][1][0][:-1]}", 1), (f"{px}_{vPRM[71][2][0][:-1]}", 1), 1), 
                              # Split
                              (vPRM[72][0], (f"{px}_{vPRM[72][1][0][:-1]}", 1), 1), 
                              # Splits
                              (vPRM[73][0], (f"{px}_{vPRM[73][1][0][:-1]}", 1), 1), 
                              # Stripes
                              (vPRM[74][0], (f"{px}_{vPRM[74][1][0][:-1]}", 1), 1), 
                              # Wedge
                              (vPRM[75][0], (f"{px}_{vPRM[75][1][0][:-1]}", 1), 1), 
                              # Wedgejulia
                              (vPRM[76][0], (f"{px}_{vPRM[76][1][0][:-1]}", 1), 1), 
                              # Wedgesph
                              (vPRM[77][0], (f"{px}_{vPRM[77][1][0][:-1]}", 1), 1), 
                              # Whorl
                              (vPRM[78][0], (f"{px}_{vPRM[78][1][0][:-1]}", 1), 1), 
                              # Waves2
                              (vPRM[79][0], (f"{px}_{vPRM[79][1][0][:-1]}", 1), (f"{px}_{vPRM[79][2][0][:-1]}", 1), 1), 
                              # Exp
                              vPRM[80], 
                              # Log
                              vPRM[81], 
                              # Sin
                              vPRM[82], 
                              # Cos
                              vPRM[83], 
                              # Tan
                              vPRM[84], 
                              # Sec
                              vPRM[85], 
                              # Csc
                              vPRM[86], 
                              # Cot
                              vPRM[87], 
                              # Sinh
                              vPRM[88], 
                              # Cosh
                              vPRM[89], 
                              # Tanh
                              vPRM[90], 
                              # Sech
                              vPRM[91], 
                              # Csch
                              vPRM[92], 
                              # Coth
                              vPRM[93], 
                              # Auger
                              (vPRM[94][0], (f"{px}_{vPRM[94][1][0][:-1]}", 1), 1), 
                              # Flux
                              (vPRM[95][0], (f"{px}_{vPRM[95][1][0][:-1]}", 0), 1), 
                              # Mobius
                              (vPRM[96][0], (f"{px}_{vPRM[96][1][0][:-1]}", 1), (f"{px}_{vPRM[96][2][0][:-1]}", 1), 1),
                              # Curve
                              (vPRM[97][0], (f"{px}_{vPRM[97][1][0][:-1]}", 1), (f"{px}_{vPRM[97][2][0][:-1]}", 1), 1), 
                              # Perspective
                              (vPRM[98][0], (f"{px}_{vPRM[98][1][0][:-1]}", 1), 1), 
                              # Bwraps
                              (vPRM[99][0], (f"{px}_{vPRM[99][1][0][:-1]}", 1), (f"{px}_{vPRM[99][2][0][:-1]}", 1), 1), 
                              # Hemisphere
                              vPRM[100], 
                              # Polynomial
                              (vPRM[101][0], (f"{px}_{vPRM[101][1][0][:-1]}", 1), (f"{px}_{vPRM[101][2][0][:-1]}", 1), (f"{px}_{vPRM[101][3][0][:-1]}", 1), 1),
                              # Crop
                              (vPRM[102][0], (f"{px}_{vPRM[102][1][0][:-1]}", 1), (f"{px}_{vPRM[102][2][0][:-1]}", 1), 1), 
                              # Unpolar
                              vPRM[103],
                              # Glynnia
                              vPRM[104], 
                              # Point symmetry
                              (vPRM[105][0], (f"{px}_{vPRM[105][1][0][:-1]}", 1), 1)
                              )
        
        return varsPRM_FF


# FLAM3H™ ITERATOR FF start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class flam3h_iterator_FF(flam3h_iterator_prm_names):
    """
    Args:
        flam3h_iterator_prm_names ([class]): [inherit properties methods from the flam3h_iterator_prm_names class]
    """    
    
    """
        Note that every parameters inside the FF have the same name as the iterator parameters 
        plus the string "ff" added at the beginning of their names. parametric variation's parameters have the string  "ff_" instead.
        If you create new parameters inside the FF, or change the parameters names inside the FLAM3H™ iterator,
        please be sure to follow the same nameing convetion so to keep the flam3h_varsPRM: class as the only source for their names.
    """
    
    __slots__ = ("_sec_prevarsT_FF", "_sec_prevarsW_FF", "_sec_varsT_FF", "_sec_varsW_FF", "_sec_postvarsT_FF", "_sec_postvarsW_FF", "_sec_preAffine_FF", "_sec_postAffine_FF", 
                 "_allMisc_FF")
    
    def __init__(self) -> None:
        """
        Args:
            (self):
            
        Returns:
            (None):
        """  
        super().__init__()
        
        # SECTIONS method lists
        #
        # (*T)Types have no signature and always to be used with: pastePRM_T_from_list()
        self._sec_prevarsT_FF: tuple[str, ...] = ( f"{f3h_ffPrmPrx.PRM}{self.prevar_type_1}",)
        self._sec_prevarsW_FF: tuple[tuple[str, int], ...] = ( (f"{f3h_ffPrmPrx.PRM}{self.prevar_weight_1}", 0),)
        self._sec_varsT_FF: tuple[str, ...] = ( f"{f3h_ffPrmPrx.PRM}{self.var_type_1}", f"{f3h_ffPrmPrx.PRM}{self.var_type_2}" )
        self._sec_varsW_FF: tuple[tuple[str, int], ...] = ( (f"{f3h_ffPrmPrx.PRM}{self.var_weight_1}", 0), (f"{f3h_ffPrmPrx.PRM}{self.var_weight_2}", 0) )
        self._sec_postvarsT_FF: tuple[str, ...] = ( f"{f3h_ffPrmPrx.PRM}{self.postvar_type_1}", f"{f3h_ffPrmPrx.PRM}{self.postvar_type_2}" )
        self._sec_postvarsW_FF: tuple[tuple[str, int], ...] = ( (f"{f3h_ffPrmPrx.PRM}{self.postvar_weight_1}", 0), (f"{f3h_ffPrmPrx.PRM}{self.postvar_weight_2}", 0) )
        self._sec_preAffine_FF: tuple[tuple[str, int], ...] = ( (f"{f3h_ffPrmPrx.PRM}{self.preaffine_x}", 1), (f"{f3h_ffPrmPrx.PRM}{self.preaffine_y}", 1), (f"{f3h_ffPrmPrx.PRM}{self.preaffine_o}", 1), (f"{f3h_ffPrmPrx.PRM}{self.preaffine_ang}", 0) )
        self._sec_postAffine_FF: tuple[tuple[str, int], ...] = ( (f"{f3h_ffPrmPrx.PRM}{self.postaffine_do}", 0), (f"{f3h_ffPrmPrx.PRM}{self.postaffine_x}", 1), (f"{f3h_ffPrmPrx.PRM}{self.postaffine_y}", 1), (f"{f3h_ffPrmPrx.PRM}{self.postaffine_o}", 1), (f"{f3h_ffPrmPrx.PRM}{self.postaffine_ang}", 0) )
        
        # ALL method lists
        # allT_FF list is omitted here because FF PRE VARS, FF VARS and FF POST VARS have their own unique parametric parameters
        # so I need to handle them one by one inside: def prm_paste_FF(kwargs).prm_paste_FF() and prm_paste_FF(kwargs).def prm_paste_sel_FF()
        self._allMisc_FF: tuple[tuple[str, int], ...] = self._sec_varsW_FF + self._sec_prevarsW_FF + self._sec_postvarsW_FF + self._sec_preAffine_FF + self._sec_postAffine_FF


    # CLASS: PROPERTIES
    ##########################################
    ##########################################
    
    @property
    def sec_prevarsT_FF(self) -> tuple[str, ...]:
        return self._sec_prevarsT_FF
    
    @property
    def sec_prevarsW_FF(self) -> tuple[tuple[str, int], ...]:
        return self._sec_prevarsW_FF
    
    @property
    def sec_varsT_FF(self) -> tuple[str, ...]:
        return self._sec_varsT_FF
    
    @property
    def sec_varsW_FF(self) -> tuple[tuple[str, int], ...]:
        return self._sec_varsW_FF
    
    @property
    def sec_postvarsT_FF(self) -> tuple[str, ...]:
        return self._sec_postvarsT_FF
    
    @property
    def sec_postvarsW_FF(self) -> tuple[tuple[str, int], ...]:
        return self._sec_postvarsW_FF
    
    @property
    def sec_preAffine_FF(self) -> tuple[tuple[str, int], ...]:
        return self._sec_preAffine_FF
    
    @property
    def sec_postAffine_FF(self) -> tuple[tuple[str, int], ...]:
        return self._sec_postAffine_FF
    
    @property
    def allMisc_FF(self) -> tuple[tuple[str, int], ...]:
        return self._allMisc_FF
    
    
# FLAM3H™ PRM UTILS start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################

  
class flam3h_prm_utils:
    """
class f3h_prm_utils

@STATICMETHODS
* set(node: hou.SopNode, _prm: hou.Parm | hou.ParmTuple | str, data: TA_PrmData) -> None:
* setParms(node: hou.SopNode, parms_dict: dict) -> None:
* private_prm_set(node: hou.SopNode, _prm: str | hou.Parm, data: str | int | float) -> None:
* private_prm_deleteAllKeyframes(node: hou.SopNode, _prm: str | hou.Parm) -> None:

@METHODS

    """  
    
    @staticmethod
    def set(node: hou.SopNode, _prm: hou.Parm | hou.ParmTuple | str, data: TA_PrmData) -> None:
        """Set a single parameter using the folloing hou methods:</br>
        * <b>node.parm("name").set(val)</b>
        * <b>node.parmTuple("name").set(val)</b></br>
        
        while unlocking them and deleting their keyframes first.</br>
        
        Note:
            * In this code base, many parameter uses the raw version from the hou module to set parameters data.</br>
            * When you find some, it mean a definition prior to that code did unlock and cleared their keyframes already.</br>
        
        Args:
            node(hou.SopNode): this FLAM3H™ node.
            _prm( hou.Parm | hou.ParmTuple | str): Either a <b>hou.Parm</b>, <b>hou.ParmTuple</b> or a <b>parm name string</b>.
            data(TA_PrmData): the data to set the parameter to.
            
        Returns:
            (None):
        """ 
        prm: hou.Parm | hou.ParmTuple | None = None
        if isinstance(_prm, str):
            prm = node.parm(_prm)
            if prm is None:
                prm = node.parmTuple(_prm)
            
        elif isinstance(_prm, (hou.Parm, hou.ParmTuple)):
            prm = _prm
            
        if prm is not None:
            prm.lock(False)
            prm.deleteAllKeyframes()
            prm.set(data) # type: ignore
            
        else:
            raise F3H_Error(f"{node.name()}: The passed in parameter is not valid:\n{_prm}")
    
    
    @staticmethod
    def setParms(node: hou.SopNode, parms_dict: dict) -> None:
        """Set a group of parameters using the hou node.setParms method.</br>
        while unlocking them and deleting their keyframes first .</br>
        
        Args:
            node(hou.SopNode): this FLAM3H™ node.
            parms_dict(dict): A dictionary specifying the parm names and their values.</br>Usually the dict is composed as [str, int | float | str]
            
        Returns:
            (None):
        """ 
        prm: hou.Parm | hou.ParmTuple | None = None
        for key in parms_dict.keys():
            prm = node.parm(key)
            if prm is None:
                prm = node.parmTuple(key)
            
            if prm is not None:
                prm.lock(False)
                prm.deleteAllKeyframes()
        
        if prm is not None:
            node.setParms(  # type: ignore
                            parms_dict
                            ) 
        else:
            raise F3H_Error(f"{node.name()}: The passed in parameters dictionary is not valid:\n{parms_dict}")


    @staticmethod
    def private_prm_set(node: hou.SopNode, _prm: str | hou.Parm, data: TA_PrmData) -> None:
        """Set a parameter value while making sure to unlock and lock it right after.</br>
        This is being introduced to add an extra level of security so to speak to certain parameters</br>
        that are not meant to be changed by the user, so at least it will require some step before allowing them to do so.</br>
        
        Args:
            node(hou.SopNode): this FLAM3H™ node.
            prm_name(str | hou.Parm): the parameter name or the parameter hou.Parm directly.
            data(TA_PrmData): The value to set the parameter to.
            
        Returns:
            (None):
        """ 
        if isinstance(_prm, str): prm: hou.Parm | None = node.parm(_prm)
        elif isinstance(_prm, hou.Parm): prm: hou.Parm | None = _prm
        else: prm: hou.Parm | None = None
        if prm is not None:
            prm.lock(False)
            prm.deleteAllKeyframes()
            prm.set(data) # type: ignore # the set method for the hou.Parm exist but it is not recognized
            prm.lock(True)
            
        else:
            if isinstance(_prm, str):
                print(f"{node.name()}: PVT parameter not found to Set: {_prm}")
            else:
                print(f"{node.name()}: PVT parameter not found to Set.")
        
        
    @staticmethod
    def private_prm_deleteAllKeyframes(node: hou.SopNode, _prm: str | hou.Parm) -> None:
        """Delete all parameter's keyframes while making sure to unlock and lock it right after.</br>
        This is being introduced to add an extra level of security so to speak to certain parameters</br>
        that are not meant to be changed by the user, so at least it will require some step before allowing them to do so.</br>
        
        Args:
            node(hou.SopNode): this FLAM3H™ node.
            prm_name(str | hou.Parm):  the parameter name or the parameter hou.Parm directly.
            
        Returns:
            (None):
        """ 
        if isinstance(_prm, str): prm: hou.Parm | None = node.parm(_prm)
        elif isinstance(_prm, hou.Parm): prm: hou.Parm | None = _prm
        else: prm: hou.Parm | None = None
        if prm is not None and len(prm.keyframes()):
            prm.lock(False)
            prm.deleteAllKeyframes()
            prm.lock(True)
            
        elif prm is None:
            if isinstance(_prm, str):
                print(f"{node.name()}: PVT parameter not found to DeleteAllKeyFrames: {_prm}")
            else:
                print(f"{node.name()}: PVT parameter not found to DeleteAllKeyFrames.")
    


# FLAM3H™ SCRIPTS start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class flam3h_scripts:
    """
class flam3h_scripts

@STATICMETHODS
* flam3h_h_versions_build_data(__h_versions__: tuple[int, ...] | int, last_index: bool = False) -> str:
* flam3h_compatible_h_versions_msg(this_h_versions: tuple[int, ...], msg: bool = True, ps_cls_about: bool = False) -> str:
* flam3h_compatible(h_version: int, this_h_versions: tuple[int, ...], kwargs: dict | None, msg: bool) -> bool:
* flam3h_compatible_range_close(kwargs: dict | None, msg: bool) -> bool:
* flam3h_compatible_range_open(kwargs: dict | None, msg: bool) -> bool:
* flam3h_on_create_lock_parms(node: hou.SopNode) -> None:
* set_first_instance_global_var(cvex_precision: int) -> None:
* flam3h_check_first_node_instance_msg_status_bar_display_flag(node: hou.SopNode, cvex_precision: int, _MSG_INFO: str, _MSG_DONE: str, sys_updated_mode: hou.EnumValue) -> None:
* flam3h_check_first_node_instance_msg_status_bar_no_display_flag(node: hou.SopNode, cvex_precision: int, _MSG_INFO: str, _MSG_DONE: str, sys_updated_mode: hou.EnumValue) -> None:
* flam3h_set_first_instance_global_var(cvex_precision: int, first_instance_32bit: bool, first_instance_64bit: bool) -> None:
* is_post_affine_default_on_load(node: hou.SopNode) -> None:
* unpin_parameter_editor_with_f3h_node(f3h_node: hou.SopNode) -> None:
* hou_session_data_clear_and_restore() -> None:

@METHODS
* flam3h_compatible_type(self, range_type: bool, kwargs: dict | None = None, msg: bool = True) -> bool:
* flam3h_check_first_node_instance_msg(self, FIRST_TIME_MSG: bool = True) -> None:
* flam3h_check_first_node_instance_prefs_cvex_precision_msg(self) -> None:
* flam3h_on_create_set_houdini_session_data(self) -> None:
* flam3h_on_create_set_prefs_viewport(self, default_value_pt: float = 1, default_value_ww: float = 3) -> None:
* flam3h_on_create_init_viewportWireWidth(self) -> None:
* flam3h_presets_cache_filepath_on_load(self) -> None:
* flam3h_on_create_compatible_false(self, iterators_count_zero: bool = True, descriptive_prm: bool = True) -> None:
* flam3h_on_create(self) -> None:
* flam3h_on_loaded_compatible_false(self) -> None:
* flam3h_on_loaded_compatible_true(self) -> None:
* flam3h_on_loaded(self) -> None:
* flam3h_on_deleted(self) -> None:

    """    
    
    __slots__ = ("_kwargs", "_node")
    
    def __init__(self, kwargs: dict) -> None:
        """
        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """  
        self._kwargs: dict[str, Any] = kwargs
        self._node: hou.SopNode = kwargs['node']
        
        
    @staticmethod
    def flam3h_h_versions_build_data(__h_versions__: tuple[int, ...] | int, last_index: bool = False) -> str:
        """Get the houdini version number from the gloabl: __h_versions__</br>

        Args:
            __h_versions__(tuple[int, ...] | int): a tuple containing all the compatible Houdini versions or an int of the desired Houdini version.</br>When a tuple, it will be coming from the HDA's PythonModule: __h_versions__
            last_index(bool): Default to: False</br>as it will return the first in the tuple.</br>If True, it will return the last in the tuple.</br>This is done because some FLAM3H™ HDA version run on multiple Houdinin versions or it can also be a 3 digits int

        Returns:
            (None):
        """ 
        if isinstance(__h_versions__, tuple):
            
            num_str: str | None = None
            if len(__h_versions__) > 1:
                if last_index:
                    num_str = str(__h_versions__[-1])
                    
                else:
                    num_str = str(__h_versions__[0])
                
            elif __h_versions__:
                num_str = str(__h_versions__[0])

            if num_str is not None:
                return f"{num_str[:2]}.{num_str[-1]}"
            else:
                return f"**N/A**"
        
        elif isinstance(__h_versions__, int):
            
            if len(str(__h_versions__)) == 3:
                return f"{str(__h_versions__)[:2]}.{str(__h_versions__)[-1]}"
            
            elif len(str(__h_versions__)) == 2:
                return f"**{str(__h_versions__)}**"
            
            else:
                return f"**N/A**"
            
        return f"**N/A**"


    @staticmethod
    def flam3h_compatible_h_versions_msg(this_h_versions: tuple[int, ...], msg: bool = True, ps_cls_about: bool = False) -> str:
        """Build and fire a message letting the user know the Houdini version/s needed to run the installed FLAM3H™ HDA version.</br>

        Args:
            this_h_versions(tuple[int, ...]): a tuple containing all the Houdini version numbers. This is coming from the HDA's PythonModule: __h_versions__
            msg(bool): Default to: True</br>When False it will not execute the: hou.ui.displayMessage
            ps_cls_about(bool): Default to False. If True, will build the message string for the pyside about panel.

        Returns:
            (str): Only the part of the message string with the allowed Houdini versions, to be used to compose the final message.
        """ 
        if len(this_h_versions) > 1:
            if __range_type__ is True: 
                               
                if ps_cls_about:
                    _MSG_H_VERSIONS = f"H{flam3h_scripts.flam3h_h_versions_build_data(this_h_versions)} to H{flam3h_scripts.flam3h_h_versions_build_data(this_h_versions, True)}"
                else:
                    _MSG_H_VERSIONS = f"from H{flam3h_scripts.flam3h_h_versions_build_data(this_h_versions)} to H{flam3h_scripts.flam3h_h_versions_build_data(this_h_versions, True)}"
                    
            else:
                if ps_cls_about:
                    _MSG_H_VERSIONS = f"H{flam3h_scripts.flam3h_h_versions_build_data(this_h_versions)} to H{flam3h_scripts.flam3h_h_versions_build_data(this_h_versions, True)}*"
                else:
                    _MSG_H_VERSIONS = f"from H{flam3h_scripts.flam3h_h_versions_build_data(this_h_versions)} to H{flam3h_scripts.flam3h_h_versions_build_data(this_h_versions, True)} and up"
                    
        else:
            if __range_type__ is True:
                _MSG_H_VERSIONS = f"H{flam3h_scripts.flam3h_h_versions_build_data(this_h_versions)}"
                
            else:
                if ps_cls_about:
                    _MSG_H_VERSIONS = f"H{flam3h_scripts.flam3h_h_versions_build_data(this_h_versions)}*"
                else:
                    _MSG_H_VERSIONS = f"H{flam3h_scripts.flam3h_h_versions_build_data(this_h_versions)} and up"
    
        if msg and hou.isUIAvailable():
            hou.ui.displayMessage(f"Sorry, You need {_MSG_H_VERSIONS} to run this FLAM3H™ version", buttons=("Got it, thank you",), severity=hou.severityType.Error, default_choice=0, close_choice=-1, help=None, title="FLAM3H™ Houdini version check", details=None, details_label=None, details_expanded=False) # type: ignore

        return _MSG_H_VERSIONS


    @staticmethod
    def flam3h_compatible(h_version: int, this_h_versions: tuple[int, ...], kwargs: dict | None, msg: bool) -> bool:
        """This is to be run inside:</br>
        
        * def flam3h_compatible_range_close(kwargs: dict | None, msg: bool) -> bool:
        * def flam3h_compatible_range_open(kwargs: dict | None, msg: bool) -> bool:
        
        It is for when FLAM3H™ is allowed to run inside the current Houdini version.
        
        Args:
            h_version(int): This Houdini version.
            this_h_versions(tuple[int, ...]): The allowed Houdini versions this FLAM3H™ can run with.
            kwargs(dict | None): When needed, this must be the class' self.kwargs.</br>In the case of this definition, it will be passed in from the containing definition args. Or None.
            msg(bool): When False it will not run the hou display messages.

        Returns:
            (bool): True if compatible otherwise False.
        """ 
        
        # If it is a match
        if h_version in this_h_versions:
            return True
        
        # We never know what will happen with the next major release of Houdini
        # but we allow it to run regardless for now.
        # If the current Houdini version is newer than the latest version supported by FLAM3H™
        # we allow it to run anyway letting the user know that something can go wrong.
        elif h_version > __h_version_max__:
            
            try:
                _H_VERSION_ALLOWED: bool =  hou.session.F3H_H_VERSION_ALLOWED # type: ignore
                
            except AttributeError:
                _H_VERSION_ALLOWED: bool = False
            
            if _H_VERSION_ALLOWED is False:
            
                # Do not show me this Display Message window again when creating succesive instances of this HDA
                hou.session.F3H_H_VERSION_ALLOWED = True # type: ignore
                    
                return True
            
            return True
        
        else:
            
            if msg: flam3h_scripts.flam3h_compatible_h_versions_msg(this_h_versions)
            
            if kwargs is not None:
                # Just in case I will need to do something
                ...
                
            return False
        

    @staticmethod
    def flam3h_compatible_range_close(kwargs: dict | None, msg: bool) -> bool:
        """Tell if this FLAM3H™ version is compatible with this Houdini version</br>
        
        * range_close -> mean FLAM3H™ will run only on Houdini versions included inside:</br>nodetype.hdaModule().__h_versions__
        
        Args:
            kwargs(dict | None): When needed, this must be the class' self.kwargs, or None
            msg(bool): When False it will not run the hou display messages.

        Returns:
            (bool): True if compatible otherwise False.
        """ 
        h_version: int = flam3h_general_utils.houdini_version(2)
        this_h_versions: tuple[int, ...] = nodetype.hdaModule().__h_versions__ # type: ignore # This is set inside each FLAM3H™ HDA PythonModule module.
        
        # checks the full available range in the tuple
        if h_version < this_h_versions[0] or h_version > this_h_versions[-1]:
            
            if msg: flam3h_scripts.flam3h_compatible_h_versions_msg(this_h_versions)
            
            if kwargs is not None:
                # Just in case I will need to do something
                ...
            
            return False
        
        # This will probably never evaluate with the range close, but just in case.
        return flam3h_scripts.flam3h_compatible(h_version, this_h_versions, kwargs, msg)


    @staticmethod
    def flam3h_compatible_range_open(kwargs: dict | None, msg: bool) -> bool:
        """Tell if this FLAM3H™ version is compatible with this Houdini version</br>
        
        * range_open -> mean it allow FLAM3H™ to run on newer versions of Houdini than the versions included inside:</br>nodetype.hdaModule().__h_versions__ before being properly fine tuned.

        Args:
            kwargs(dict | None): When needed, this must be the class' self.kwargs, or None
            msg(bool): When False it will not run the hou display messages.

        Returns:
            (bool): True if compatible otherwise False.
        """ 
        h_version: int = flam3h_general_utils.houdini_version(2)
        this_h_versions: tuple[int, ...] = nodetype.hdaModule().__h_versions__ # type: ignore # This is set inside each FLAM3H™ HDA PythonModule module.
        
        # Only for the latest FLAM3H™ on the latest Houdini version (and its latest python module version), otherwise the full range is checked.
        #
        # We never know what will happen with the next major release of Houdini
        # but we allow it to run regardless for now.
        # the files: "py_flam3__3_11.py" and "py_flam3__3_7.py" checks the full available range in the tuple:
        # e.g.
        # if h_version < this_h_versions[0] or h_version > this_h_versions[-1]:
        #   ... 
        # Most likely the range will be closed again once SideFX update the vcc compiler and LLVM.
        if h_version < this_h_versions[0]:
            
            if msg: flam3h_scripts.flam3h_compatible_h_versions_msg(this_h_versions)
            
            if kwargs is not None:
                # Just in case I will need to do something
                ...
            
            return False
            
        return flam3h_scripts.flam3h_compatible(h_version, this_h_versions, kwargs, msg)


    @staticmethod
    def flam3h_on_create_lock_parms(node: hou.SopNode) -> None:
        """lock private parameters not being locked on creation by other definitions.</br>
        
        Args:
            node(hou.SopNode): This FLAM3H™ node
            
        Returns:
            (None):
        """
        
        for prm_name in f3h_pvt.PVT_ALL:
            parm = node.parm(prm_name)
            if parm is not None and not parm.isLocked():
                parm.lock(True)


    @staticmethod
    def set_first_instance_global_var(cvex_precision: int) -> None:
        """Set the hou.session variable to hold the cvex precision being used on first instance node creation time.</br>

        Args:
            cvex_precision(int): 32bit or 64bit - This is the cvex precision preference's option parameter
            
        Returns:
            (None):
        """  
        if cvex_precision == 32:
            hou.session.F3H_FIRST_INSTANCE_32BIT: bool = False # type: ignore
        elif cvex_precision == 64:
            hou.session.F3H_FIRST_INSTANCE_64BIT: bool = False # type: ignore


    @staticmethod
    def flam3h_check_first_node_instance_msg_status_bar_display_flag(node: hou.SopNode, cvex_precision: int, _MSG_INFO: str, _MSG_DONE: str, sys_updated_mode: hou.EnumValue) -> None:
        """This is temporary</br>
        until I dnt have time to find a better solution to advice the user about the first node compile time</br>
        without having any leftover messages in the Houdini status bar.</br></br>
        
        This definition will cook and updated the FLAM3H™ node on creation</br>
        based on its CVEX precision preference's setting if its display flag is True.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node
            cvex_precision(int): 32bit or 64bit - This is the cvex precision preference's option parameter
            _MSG_INFO(str): The message to print in the status bar
            _MSG_DONE(str): The message to print in the hou window 
            sys_updated_mode(hou.EnumValue): houdini updated mode before dropping a FLAM3H™ node for the first time ( stored from the preFirstCreate script )
            
        Returns:
            (None):
        """
        flam3h_general_utils.set_status_msg(_MSG_INFO, 'WARN')
        if hou.isUIAvailable():
            
            # If there are not any Sop viewer lets cook it since this is the first node instance of FLAM3H™
            if flam3h_general_utils.util_is_context_available_viewer('Sop') is False and flam3h_general_utils.util_is_context_available_viewer('Object') is False: node.cook(force=True)
            elif sys_updated_mode == hou.updateMode.Manual: # type: ignore
                node.cook(force=True)
                
            if hou.ui.displayMessage(_MSG_DONE, buttons=("Got it, thank you",), severity = hou.severityType.Message, default_choice = 0, close_choice = -1, help = None, title = "FLAM3H™ CVEX 32bit compile", details = None, details_label = None, details_expanded = False) == 0: # type: ignore
                flam3h_scripts.set_first_instance_global_var(cvex_precision)
                hou.setUpdateMode(sys_updated_mode)
                # Close pyside panel if open from first time (splash screen)
                pyside_utils.pyside_panels_safe_launch(pyside_master.F3H_msg_panel, run=False)
                # Print to the Houdini console
                print(f"\n-> FLAM3H™ CVEX nodes compile: DONE\n")
                
            flam3h_general_utils.set_status_msg(_MSG_DONE, 'IMP')
            
        else:
            flam3h_scripts.set_first_instance_global_var(cvex_precision)
            hou.setUpdateMode(sys_updated_mode) # type: ignore


    @staticmethod
    def flam3h_check_first_node_instance_msg_status_bar_no_display_flag(node: hou.SopNode, cvex_precision: int, _MSG_INFO: str, _MSG_DONE: str, sys_updated_mode: hou.EnumValue) -> None:
        """This is temporary</br>
        until I dnt have time to find a better solution to advice the user about the first node compile time</br>
        without having any leftover messages in the Houdini status bar.</br></br>
        
        This definition will cook and updated the FLAM3H™ node on creation</br>
        based on its CVEX precision preference's setting if its display flag is False.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node
            cvex_precision(int): 32bit or 64bit - This is the cvex precision preference's option parameter
            _MSG_INFO(str): The message to print in the status bar
            _MSG_DONE(str): The message to print in the hou window 
            sys_updated_mode(hou.EnumValue): houdini updated mode before dropping a FLAM3H™ node for the first time ( stored from the preFirstCreate script )
            
        Returns:
            (None):
        """
        # m = nodesearch.State("Display", True)
        # _display_node = m.nodes(node.parent(), recursive=False)[0]
        flam3h_general_utils.set_status_msg(_MSG_INFO, 'WARN')
        node.cook(force=True)
        flam3h_scripts.set_first_instance_global_var(cvex_precision)
        hou.setUpdateMode(sys_updated_mode)
        # Close pyside panel if open from first time (splash screen)
        pyside_utils.pyside_panels_safe_launch(pyside_master.F3H_msg_panel, run=False)
        
        flam3h_general_utils.set_status_msg(_MSG_DONE, 'IMP')
        print(f"\nFLAM3H CVEX node compile: DONE\n")
        
        
    @staticmethod
    def flam3h_set_first_instance_global_var(cvex_precision: int, first_instance_32bit: bool, first_instance_64bit: bool) -> None:
        """Set the hou.session variable to hold the cvex precision being used during the Houdini session.</br>

        Args:
            cvex_precision(int): 32bit or 64bit - This is the cvex precision preference's option parameter
            first_instance_32bit(bool): 32bit or 64bit - Was this FLAM3H™ node instance created with this cvex precision ?
            first_instance_64bit(bool): 32bit or 64bit - Was this FLAM3H™ node instance created with this cvex precision ?
            
        Returns:
            (None):
        """  
        if cvex_precision == 32 and first_instance_32bit is True:
            hou.session.F3H_FIRST_INSTANCE_32BIT: bool = False # type: ignore
        elif cvex_precision == 64 and first_instance_64bit is True:
            hou.session.F3H_FIRST_INSTANCE_64BIT: bool = False # type: ignore


    @staticmethod
    def is_post_affine_default_on_load(node: hou.SopNode) -> None:
        """Turn iterators/FF post affine OFF if they are active and default values.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node.
            
        Returns:
            (None):
        """  
        _len: Callable[[tuple[Any]], int] = len
        # Iterators
        iter_num: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        prm_list_post_affine: tuple[tuple[str, int], ...] = flam3h_iterator().sec_postAffine
        prm_list_post_affine_XYOA: tuple[tuple[str, int], ...] = prm_list_post_affine[1:]
        keyframes_iters: list[list[int]] = [[item for sublist in k for item in sublist] for k in [[[1 if _len(p.keyframes()) else 0 for p in node.parmTuple(f"{prm_list_post_affine_XYOA[idx][0]}{id + 1}")] if prm_list_post_affine_XYOA[idx][1] else [1 if _len(node.parm(f"{prm_list_post_affine_XYOA[idx][0]}{id + 1}").keyframes()) else 0] for idx in range(len(prm_list_post_affine_XYOA))] for id in range(iter_num)]]
        collect_iters: list[list[tuple[float, ...] | float]] = [[node.parmTuple(f"{prm_list_post_affine_XYOA[idx][0]}{id + 1}").eval() if prm_list_post_affine_XYOA[idx][1] else node.parm(f"{prm_list_post_affine_XYOA[idx][0]}{id + 1}").eval() for idx in range(len(prm_list_post_affine_XYOA))] for id in range(iter_num)]
        for id, affine in enumerate(collect_iters):
            prm_iter_name: str = f"{prm_list_post_affine[0][0]}{id + 1}"
            if node.parm(prm_iter_name).eval() and 1 not in keyframes_iters[id] and affine == f3h_affineDefaults.DEFAULT_VALS:
                prm_node = node.parm(prm_iter_name)
                prm_node.lock(False)
                prm_node.deleteAllKeyframes()
                prm_node.set(0)
                
        # FF
        prm_list_post_affine_FF: tuple[tuple[str, int], ...] = flam3h_iterator_FF().sec_postAffine_FF
        prm_list_post_affine_FF_XYOA: tuple[tuple[str, int], ...] = prm_list_post_affine_FF[1:]
        keyframes_FF: list[int] = [item for sublist in [[1 if _len(p.keyframes()) else 0 for p in node.parmTuple(f"{prm_list_post_affine_FF_XYOA[idx][0]}")] if prm_list_post_affine_FF_XYOA[idx][1] else [1 if _len(node.parm(f"{prm_list_post_affine_FF_XYOA[idx][0]}").keyframes()) else 0] for idx in range(len(prm_list_post_affine_FF_XYOA))] for item in sublist]
        collect_FF: list[tuple[float, ...] | float] = [node.parmTuple(f"{prm_list_post_affine_FF_XYOA[idx][0]}").eval() if prm_list_post_affine_FF_XYOA[idx][1] else node.parm(f"{prm_list_post_affine_FF_XYOA[idx][0]}").eval() for idx in range(len(prm_list_post_affine_FF_XYOA))]
        prm_ff_name: str = f"{prm_list_post_affine_FF[0][0]}"
        if node.parm(prm_ff_name).eval() and 1 not in keyframes_FF and collect_FF == f3h_affineDefaults.DEFAULT_VALS:
            prm_node = node.parm(prm_ff_name)
            prm_node.lock(False)
            prm_node.deleteAllKeyframes()
            prm_node.set(0)


    @staticmethod
    def unpin_parameter_editor_with_f3h_node(f3h_node: hou.SopNode) -> None:
        """If a FLAM3H™ node is on display in a pinned Parameter Editor, unpin that parameter Editor.<br/>
        This is specifically made for:
        * def flam3h_on_deleted(self) -> None:
        
        to avoid a menu error happening sometime when deleting multiple FLAM3H™ nodes in one go while one of them was on display in a pinned Parameter Editor.</br>

        Args:
            node(hou.SopNode): The FLAM3H™ node to check if its parameter are being pinned inside a Parameter Editor.
            
        Returns:
            (None):
        """  
    
        pe: list[hou.ParameterEditor] = flam3h_general_utils.util_getParameterEditors()
        for p in pe:
            if p.currentNode() == f3h_node and p.isPin():
                p.setPin(False)
            
            
    @staticmethod
    def hou_session_data_clear_and_restore() -> None:
        """Clear and set hou.session data when the last FLAM3H™ node is being deleted.<br/>
        This is specifically made for:
        * def flam3h_on_deleted(self) -> None:

        Args:
            (None):
            
        Returns:
            (None):
        """  
        
        # Init the Copy/Paste data to defaults
        try: 
            hou.session.F3H_MARKED_ITERATOR_NODE.type() # type: ignore
            
        except (AttributeError, hou.ObjectWasDeleted):
            
            try:
                if hou.session.F3H_MARKED_ITERATOR_MP_IDX is not None:  # type: ignore
                    hou.session.F3H_MARKED_ITERATOR_NODE: TA_MNode = None # type: ignore
            
            except AttributeError:
                pass
            
        try: 
            hou.session.F3H_MARKED_FF_NODE.type() # type: ignore
            
        except (AttributeError, hou.ObjectWasDeleted):
            
            try:
                if hou.session.F3H_MARKED_FF_CHECK is not None:  # type: ignore
                    hou.session.F3H_MARKED_FF_NODE: TA_MNode = None # type: ignore
            
            except AttributeError:
                pass
            
        # Delete the Houdini update mode data if needed
        try: 
            del hou.session.F3H_SYS_UPDATE_MODE # type: ignore
        
        except AttributeError:
            pass


    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @property
    def kwargs(self) ->  dict[str, Any]:
        return self._kwargs
    
    @property
    def node(self) -> hou.SopNode:
        return self._node
    
    
    def flam3h_compatible_type(self, range_type: bool, kwargs: dict | None = None, msg: bool = True) -> bool:
        """Check FLAM3H™ compatibility based on the type of range(of Houdini versions)</br>
        
        * range_open -> mean it allow FLAM3H™ to run on newer versions of Houdini than the versions included inside:</br>nodetype.hdaModule().__h_versions__ before being properly fine tuned.
        * range_close -> mean FLAM3H™ will run only on Houdini versions included inside:</br>nodetype.hdaModule().__h_versions__

        Args:
            range_type(bool): True for closed range. False for open range. This is set inside the HDA's -> Type Properties -> Scripts -> PythonModule
            kwargs(dict | None): Default to: None</br>When needed, this must be the class' self.kwargs
            msg(bool): Default to: True</br>When False it will not run the hou display messages.

        Returns:
            (bool): True if compatible otherwise False.
        """ 
        if range_type:
            return self.flam3h_compatible_range_close(kwargs, msg)
        
        return self.flam3h_compatible_range_open(kwargs, msg)
        

    def flam3h_check_first_node_instance_msg(self, FIRST_TIME_MSG: bool = True) -> None:
        """This is temporary until I dnt have time to find a better solution</br>
        to advice the user about the first node compile time without having any leftover</br>
        messages in the Houdini status bar.</br></br>
        
        This definition will cook and updated the FLAM3H™ node on creation based on its CVEX precision preference's setting</br>
        and based on its display flag status ( Tru or False ).</br></br>
        
        It will also restore the houdini session update mode if not set already on AutoUpdate.</br>

        Args:
            (self):
            FIRST_TIME_MSG(int): Default to: True</br>False for onLoaded and True for onCreated
            
        Returns:
            (None):
        """
        
        try:
            hou.session.F3H_FIRST_INSTANCE_32BIT # type: ignore
        except AttributeError:
            first_instance_32bit: bool = True
        else:
            first_instance_32bit: bool = False
            
        try:
            hou.session.F3H_FIRST_INSTANCE_64BIT # type: ignore
        except AttributeError:
            first_instance_64bit: bool = True
        else:
            first_instance_64bit: bool = False
            
        node: hou.SopNode = self.node
        cvex_precision: int = int( node.parm(f3h_tabs.PREFS.PRM_CVEX_PRECISION).eval() )
                
        if FIRST_TIME_MSG is True and ( first_instance_32bit is True or first_instance_64bit is True ): # type: ignore
            
            __module_version__: str = '.'.join((__py_version__.split('.'))[:2])
            
            if cvex_precision == 32 and first_instance_32bit is True:
                
                hou.setUpdateMode(hou.updateMode.AutoUpdate) # type: ignore
                sys_updated_mode: hou.EnumValue = hou.session.F3H_SYS_UPDATE_MODE # type: ignore
                
                _MSG_INFO = f"FLAM3H™ v{__version__}  first instance -> Compiling FLAM3H™ CVEX nodes. Depending on your PC configuration it can take up to 1(one) minute. It is a one time compile process."
                _MSG_DONE = f"FLAM3H™ CVEX nodes compile: DONE \nversion: {__version__} - {__status__}\nF3H Python module: {__module_version__}"
                
                pyside_utils.pyside_panels_safe_launch(pyside_master.F3H_msg_panel, auto_close_ms=0, splash_screen=True)
                if node.isGenericFlagSet(hou.nodeFlag.Display): # type: ignore
                    self.flam3h_check_first_node_instance_msg_status_bar_display_flag(node, cvex_precision, _MSG_INFO, _MSG_DONE, sys_updated_mode) # type: ignore
                else:
                    self.flam3h_check_first_node_instance_msg_status_bar_no_display_flag(node, cvex_precision,_MSG_INFO, _MSG_DONE, sys_updated_mode) # type: ignore
                    
            elif cvex_precision == 64 and first_instance_64bit is True:

                hou.setUpdateMode(hou.updateMode.AutoUpdate) # type: ignore
                sys_updated_mode: hou.EnumValue = hou.session.F3H_SYS_UPDATE_MODE # type: ignore
                
                _MSG_INFO = f"FLAM3H™ v{__version__} 64-bit  first instance -> Compiling FLAM3H™ CVEX 64-bit nodes. Depending on your PC configuration it can take up to 1(one) minute. It is a one time compile process."
                _MSG_DONE = f"FLAM3H™ CVEX 64-bit nodes compile: DONE\nversion: {__version__} - {__status__}\nF3H Python module: {__module_version__}"
                
                pyside_utils.pyside_panels_safe_launch(pyside_master.F3H_msg_panel, auto_close_ms=0, splash_screen=True)
                if node.isGenericFlagSet(hou.nodeFlag.Display): # type: ignore
                    self.flam3h_check_first_node_instance_msg_status_bar_display_flag(node, cvex_precision, _MSG_INFO, _MSG_DONE, sys_updated_mode) # type: ignore
                else:
                    self.flam3h_check_first_node_instance_msg_status_bar_no_display_flag(node, cvex_precision,_MSG_INFO, _MSG_DONE, sys_updated_mode) # type: ignore
                    
            else:
                pass
                
        else:
            self.flam3h_set_first_instance_global_var(cvex_precision, first_instance_32bit, first_instance_64bit)


    def flam3h_check_first_node_instance_prefs_cvex_precision_msg(self) -> None:
        """When changing CVEX precison modes in the preference's tab,</br>
        this definition will let the user node know about the compilie time</br>
        if a mode is selected for the first time in the current houdini's session.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        
        try:
            hou.session.F3H_FIRST_INSTANCE_32BIT # type: ignore
        except AttributeError:
            first_instance_32bit: bool = True
        else:
            first_instance_32bit: bool = False
            
        try:
            hou.session.F3H_FIRST_INSTANCE_64BIT # type: ignore
        except AttributeError:
            first_instance_64bit: bool = True
        else:
            first_instance_64bit: bool = False
                
        if first_instance_32bit is True or first_instance_64bit is True: # type: ignore

            node: hou.SopNode = self.node
            cvex_precision: int = int( node.parm(f3h_tabs.PREFS.PRM_CVEX_PRECISION).eval() )
            
            sys_updated_mode: hou.EnumValue = hou.updateModeSetting() # type: ignore
            hou.setUpdateMode(hou.updateMode.AutoUpdate) # type: ignore
            
            __module_version__: str = '.'.join((__py_version__.split('.'))[:2])
            
            if cvex_precision == 32:
                _MSG_INFO = f" FLAM3H™ v{__version__}  first instance -> Compiling FLAM3H™ CVEX node. Depending on your PC configuration it can take up to 1(one) minute. It is a one time compile process."
                _MSG_DONE = f"FLAM3H™ CVEX node compile: DONE \nversion: {__version__} - {__status__}\nF3H Python module: {__module_version__}"
            else:
                _MSG_INFO = f" FLAM3H™ v{__version__} 64-bit  first instance -> Compiling FLAM3H™ CVEX 64-bit node. Depending on your PC configuration it can take up to 1(one) minute. It is a one time compile process."
                _MSG_DONE = f"FLAM3H™ CVEX 64-bit node compile: DONE\nversion: {__version__} - {__status__}\nF3H Python module: {__module_version__}"
            
            density: int = node.parm(f3h_tabs.GLB.PRM_DENSITY).eval()
            if node.isGenericFlagSet(hou.nodeFlag.Display): # type: ignore
                flam3h_general_utils.set_status_msg(_MSG_INFO, 'WARN')
                node.parm(f3h_tabs.GLB.PRM_DENSITY).set(1)
                node.cook(force=True)
                if hou.isUIAvailable():
                    if hou.ui.displayMessage(_MSG_DONE, buttons=("Got it, thank you",), severity = hou.severityType.Message, default_choice = 0, close_choice = -1, help = None, title = "FLAM3H™ CVEX 64bit compile", details = None, details_label = None, details_expanded = False) == 0: # type: ignore
                        # node.cook(force=True)
                        self.flam3h_set_first_instance_global_var(cvex_precision, first_instance_32bit, first_instance_64bit)

                        node.parm(f3h_tabs.GLB.PRM_DENSITY).set(density)
                        hou.setUpdateMode(sys_updated_mode) # type: ignore
                        flam3h_general_utils.set_status_msg(_MSG_DONE, 'IMP')
                else:
                    self.flam3h_set_first_instance_global_var(cvex_precision, first_instance_32bit, first_instance_64bit)

                    node.parm(f3h_tabs.GLB.PRM_DENSITY).set(density)
                    hou.setUpdateMode(sys_updated_mode) # type: ignore
            else:
                # m = nodesearch.State("Display", True)
                # _display_node = m.nodes(node.parent(), recursive=False)[0]
                flam3h_general_utils.set_status_msg(_MSG_INFO, 'WARN')
                node.parm(f3h_tabs.GLB.PRM_DENSITY).set(1)
                node.cook(force=True)
                self.flam3h_set_first_instance_global_var(cvex_precision, first_instance_32bit, first_instance_64bit)

                node.parm(f3h_tabs.GLB.PRM_DENSITY).set(density)
                hou.setUpdateMode(sys_updated_mode) # type: ignore
                flam3h_general_utils.set_status_msg(_MSG_DONE, 'IMP')


    def flam3h_on_create_set_houdini_session_data(self) -> None:
        """Initialize the necessary data for the copy/paste iterator and FF methods on creation.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        
        node: hou.SopNode = self.node
        node_instances: tuple[hou.SopNode, ...] = self.node.type().instances()
        
        # FLAM3H™ node and MultiParameter id for iterators
        # This is to make sure the hou.session's data is at least initialized.
        flam3h_iterator_utils.flam3h_init_hou_session_iterator_data(node)

        # If an iterator was copied from a node that has been deleted
        try: hou.session.F3H_MARKED_ITERATOR_NODE.type() # type: ignore
        except (AttributeError, hou.ObjectWasDeleted):
            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = None # type: ignore
            # If we deleted all FLAM3H™ nodes and we then create a new one,
            # Lets initialize back to himself.
            if len(node_instances) == 1:
                hou.session.F3H_MARKED_ITERATOR_NODE: TA_MNode = node # type: ignore

        # FLAM3H™ node for FF.
        # This is to make sure the hou.session's data is at least initialized.
        flam3h_iterator_utils.flam3h_init_hou_session_ff_data(node)

        # If the FF was copied from a node that has been deleted
        try: hou.session.F3H_MARKED_FF_NODE.type() # type: ignore
        except (AttributeError, hou.ObjectWasDeleted):
            hou.session.F3H_MARKED_FF_CHECK: TA_M = None # type: ignore
            # If we deleted all FLAM3H™ nodes and we then create a new one,
            # Lets initialize back to himself.
            if len(node_instances) == 1:
                hou.session.F3H_MARKED_FF_NODE: TA_MNode = node # type: ignore


    def flam3h_on_create_set_prefs_viewport(self, default_value_pt: float = 1, default_value_ww: float = 3) -> None:
        """Initialize the necessary data for the viewport display preference's option on creation.</br>
        This need some work as it is a little rough, I'll be back to this at some point. Good enough for now.</br>
        
        Args:
            (self):
            default_value_pt(float): Default to: 1</br>A default value to compare to for the point setting.</br>This must always be the same as the FLAM3H™ UI parameter's default values.
            default_value_ww(float): Default to: 3</br>A default value to compare to for the wire width setting.</br>This must always be the same as the FLAM3H™ UI parameter's default values.
            
        Returns:
            (None):
        """
        
        node: hou.SopNode = self.node
        
        # viewers
        viewers: list[hou.SceneViewer] = flam3h_general_utils.util_getSceneViewers()
        
        # Update dark history
        flam3h_general_utils.util_store_all_viewers_color_scheme_onCreate() # init Dark viewers data, needed for the next definition to run
        flam3h_general_utils(self.kwargs).colorSchemeDark(False) # type: ignore
        # Set other FLAM3H™ instances to dark if any
        all_f3h: tuple[hou.SopNode, ...] = node.type().instances()
        all_f3h_vpptsize: list[float] = []
        all_f3h_vptype: list[int] = []
        all_f3h_ww: list[float] = []
        
        if len(all_f3h) > 1:

            for f3h in all_f3h:
                if f3h != node:
                    all_f3h_vpptsize.append(f3h.parm(f3h_tabs.PREFS.PRM_VIEWPORT_PT_SIZE).eval())
                    all_f3h_vptype.append(f3h.parm(f3h_tabs.PREFS.PRM_VIEWPORT_PT_TYPE).eval())
                    all_f3h_ww.append(f3h.parm(f3h_tabs.PREFS.PRM_VIEWPORT_WIRE_WIDTH).eval())
                    if f3h.parm(f3h_tabs.PREFS.PRM_VIEWPORT_DARK).eval():
                        flam3h_prm_utils.set(node, f3h_tabs.PREFS.PRM_VIEWPORT_DARK, 1)
                        flam3h_general_utils(self.kwargs).colorSchemeDark(False)
                        
                    # FLAM3H™ nodes viewport preferences options are already synced
                    # so we really need only one to know them all
                    break
        else:
            flam3h_prm_utils.set(node, f3h_tabs.PREFS.PRM_VIEWPORT_DARK, 1)
            flam3h_general_utils(self.kwargs).colorSchemeDark(False) # type: ignore
        
        # If we collected some data, set
        if all_f3h_vpptsize:
            flam3h_prm_utils.set(node, f3h_tabs.PREFS.PRM_VIEWPORT_PT_SIZE, all_f3h_vpptsize[0])
            flam3h_prm_utils.set(node, f3h_tabs.PREFS.PRM_VIEWPORT_PT_TYPE, all_f3h_vptype[0])
            # Updated memory
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_SIZE_MEM, all_f3h_vpptsize[0])
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_TYPE_MEM, all_f3h_vptype[0])
            
        else:
            Pixels: hou.EnumValue = hou.viewportParticleDisplay.Pixels # type: ignore
            
            for v in viewers:
                
                # Lets make sure we check for a viewer in the Sop context
                if flam3h_general_utils.util_is_context('Sop', v) or flam3h_general_utils.util_is_context('Object', v):
                    
                    settings: hou.GeometryViewportSettings = v.curViewport().settings()
                    size: float = settings.particlePointSize()
                    
                    if size != default_value_pt:
                        flam3h_prm_utils.set(node, f3h_tabs.PREFS.PRM_VIEWPORT_PT_SIZE, size)
                        # Updated memory
                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_SIZE_MEM, size)
                        
                    _type: hou.EnumValue = settings.particleDisplayType()
                    if _type == Pixels:
                        flam3h_prm_utils.set(node, f3h_tabs.PREFS.PRM_VIEWPORT_PT_TYPE, 1)
                        # Updated memory
                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_TYPE_MEM, 1)
                        
                else:
                    # FLAM3H™ shoud use its parameter default value in this case, but just to be sure
                    flam3h_prm_utils.set(node, f3h_tabs.PREFS.PRM_VIEWPORT_PT_SIZE, default_value_pt)
                    # Updated memory
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_SIZE_MEM, default_value_pt)
                    
        # If we collected some data, set
        if all_f3h_ww:
            flam3h_prm_utils.set(node, f3h_tabs.PREFS.PRM_VIEWPORT_WIRE_WIDTH, all_f3h_ww[0])
            # Updated memory
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_WIRE_WIDTH_MEM, all_f3h_ww[0])
            
        else:
            
            for v in viewers:
                
                # Lets make sure we check for a viewer in the Sop context
                if flam3h_general_utils.util_is_context('Sop', v) or flam3h_general_utils.util_is_context('Object', v):
                    
                    settings: hou.GeometryViewportSettings = v.curViewport().settings()
                    size: float = settings.wireWidth()
                    
                    if size != default_value_ww:
                        flam3h_prm_utils.set(node, f3h_tabs.PREFS.PRM_VIEWPORT_WIRE_WIDTH, size)
                        # Updated memory
                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_WIRE_WIDTH_MEM, size)
    
    
    def flam3h_on_create_init_viewportWireWidth(self) -> None:
        """Initialize FLAM3H™ viewport wire width.</br>
        We set it ot 3 for now as it looks nice.</br>
        This will affect the viewport wireframe width as it is a global setting.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        if flam3h_general_utils(self.kwargs).util_other_xf_viz() is False:
            hou.session.H_VIEWPORT_WIRE_WIDTH: float = 3 # type: ignore
        else:
            try:
                hou.session.H_VIEWPORT_WIRE_WIDTH # type: ignore
            except AttributeError:
                hou.session.H_VIEWPORT_WIRE_WIDTH: float = 3 # type: ignore
    
    
    def flam3h_presets_cache_filepath_on_load(self) -> None:
        """Initialize presets cached data to be up to date.</br>
        
        Here I could use userData instead of a cachedUserData but can happen that between one houdini session</br>
        and the next one the user may make some modification to the stored file, like moving it into another location or deleting it</br>
        so this way we make sure to always be up to date.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        cp_is_valid: int = node.parm(f3h_tabs.CP.PVT_PRM_ISVALID_FILE).eval()
        in_is_valid: int = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_FILE).eval()
        out_is_valid: int = node.parm(f3h_tabs.OUT.PVT_PRM_ISVALID_FILE).eval()
        
        if cp_is_valid:
            cp_path: str = os.path.expandvars(node.parm(f3h_tabs.CP.PRM_PATH).eval())
            cp_path_checked: str | bool = out_flame_utils.out_check_outpath(node,  cp_path, f3h_tabs.CP.DEFAULT_FILE_EXT, f3h_tabs.CP.DEFAULT_AUTO_NAME)
            cp_is_file: bool = os.path.isfile(cp_path_checked) if cp_path_checked is not False else False
            if cp_is_file: node.setCachedUserData(f3h_cachedUserData.cp_presets_filepath, cp_path_checked)
                
        if in_is_valid:
            in_xml: str = os.path.expandvars(node.parm(f3h_tabs.IN.PRM_PATH).eval())
            in_xml_checked: str | bool = out_flame_utils.out_check_outpath(node,  in_xml, f3h_tabs.OUT.DEFAULT_FILE_EXT, f3h_tabs.OUT.DEFAULT_AUTO_NAME, False, False)
            in_xml_is_file: bool = os.path.isfile(in_xml_checked) if in_xml_checked is not False else False
            if in_xml_is_file: node.setCachedUserData(f3h_cachedUserData.in_presets_filepath, in_xml_checked)
            
        if out_is_valid:
            out_xml: str = os.path.expandvars(node.parm(f3h_tabs.OUT.PRM_PATH).eval())
            out_xml_checked: str | bool = out_flame_utils.out_check_outpath(node,  out_xml, f3h_tabs.OUT.DEFAULT_FILE_EXT, f3h_tabs.OUT.DEFAULT_AUTO_NAME)
            out_xml_is_file: bool = os.path.isfile(out_xml_checked) if out_xml_checked is not False else False
            if out_xml_is_file: node.setCachedUserData(f3h_cachedUserData.out_presets_filepath, out_xml_checked)


    def flam3h_on_create_compatible_false(self, iterators_count_zero: bool = True, descriptive_prm: bool = True) -> None:
        """When FLAM3H™ is loaded into an incompatible Houdini version this code is run on creation.</br></br>
        
        Note:</br>
            This will need to be expanded at some point in time, for now it is enough to catch the versions and show the incompatibility for simple cases.
        
        Args:
            (self):
            iterators_count_zero(bool): Default to: True</br>Set the iterators count to Zero. Set it to False to not set.
            descriptive_prm(bool): Default to: True</br>Set the node descriptive parameter. Set it to False to not set.
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        flam3h_prm_utils.private_prm_set(self.node, f3h_tabs.PREFS.PVT_PRM_H_VALID, 0)
        __h_versions__: tuple[int, ...] = nodetype.hdaModule().__h_versions__ # type: ignore # This is set inside each FLAM3H™ HDA PythonModule module.
        
        _MSG_H_VERSIONS = flam3h_scripts.flam3h_compatible_h_versions_msg(__h_versions__, False)

        _MSG_INFO = f"ERROR -> FLAM3H™ version: {__version__}. This Houdini version is not compatible with this FLAM3H™ version. you need {_MSG_H_VERSIONS} to run this FLAM3H™ version"
        _MSG_ABOUT = f"This FLAM3H™ version need {_MSG_H_VERSIONS} to work."
        _MSG_DESCRIPTIVE_MSG = f"FLAM3H™ v{__version__}\nYou need {_MSG_H_VERSIONS}"
        
        # Set proper messages in the about tabs
        node.parm(f3h_tabs.ABOUT.MSG_PRM_F3H_ABOUT).set(_MSG_ABOUT)
        node.parm(f3h_tabs.ABOUT.MSG_PRM_F3H_PLUGINS).set(_MSG_ABOUT)
        flam3h_about_utils(self.kwargs).flam3h_about_web_msg()
        
        # Force to display the error message even when the display flag is Off on creation
        #
        # Force this node to cook to get a warning message show up upstream.
        # It failed on me once, hence the try except block
        # Probably becasue I am now raising an error from the xaos cvex code and when it does
        # it is not allowed to cook ? Need to investigate...
        try:
            hou.node(flam3h_general_utils(self.kwargs).get_node_path(f3h_nodeNames.DEFAULT_TFFA_XAOS)).cook(force=True)
        except AttributeError as e:
            F3H_Exception.F3H_traceback_print_infos(e)
            pass
        except hou.OperationFailed:
            pass
        
        # Force to update
        node.cook(force=True)
        
        # We do not always want to set the iterators count to Zero
        # likely only on creation, not on hip file load
        if iterators_count_zero:
            flam3h_prm_utils.set(node, f3h_tabs.PRM_ITERATORS_COUNT, 0)
            flam3h_iterator_utils(self.kwargs).iterators_count_zero(node, False)
        
        # We do not always want to set the descriptive parameter
        # likely only on creation, not on hip file load
        if descriptive_prm:
            flam3h_prm_utils.set(node, f3h_tabs.PRM_DESCRIPTIVE, _MSG_DESCRIPTIVE_MSG)
            
        # ERROR in the status bar
        if hou.isUIAvailable(): hou.ui.setStatusMessage(_MSG_INFO, hou.severityType.Error) # type: ignore
        
        '''
        f3h_instances: tuple = node.type().instances()
        for f3h in f3h_instances:
            if f3h != node:
                flam3h_prm_utils.private_prm_set(f3h, FLAM3H_PVT_H_VALID, 1)
                # Restore about tab infos
                f3h_kwargs: dict = copy(self.kwargs)
                f3h_kwargs['node'] = f3h
                flam3h_about_utils(f3h_kwargs).flam3h_about_msg()
                flam3h_about_utils(f3h_kwargs).flam3h_about_plugins_msg()
                flam3h_about_utils(f3h_kwargs).flam3h_about_web_msg()
        '''


    def flam3h_on_create(self) -> None:
        """Initialize FLAM3H™ node on creation and all the data it need to run.
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        if self.flam3h_compatible_type(__range_type__, msg=False):
            
            node.setColor(hou.Color((0.9,0.9,0.9)))
            
            flam3h_iterator_utils(self.kwargs).flam3h_default()
            self.flam3h_check_first_node_instance_msg()
            
            # Set about tab infos
            flam3h_about_utils(self.kwargs).flam3h_about_msg()
            flam3h_about_utils(self.kwargs).flam3h_about_plugins_msg()
            flam3h_about_utils(self.kwargs).flam3h_about_web_msg()
            
            self.flam3h_on_create_set_houdini_session_data()
            self.flam3h_on_create_set_prefs_viewport()
            self.flam3h_on_create_init_viewportWireWidth()
            
            # Remove any comment and user data from the node
            flam3h_iterator_utils.del_comment_and_user_data_iterator(node)
            flam3h_iterator_utils.del_comment_and_user_data_iterator(node, f3h_userData.MARKED_FF)
            # This is already destroyed inside: flam3h_iterator_utils(self.kwargs).flam3h_default()
            # But I keep it for now in case a make some changes later on
            flam3h_iterator_utils.destroy_userData(node, f3h_userData.XML_LAST)
            
            # OUT render curves reset and set
            out_flame_utils.out_render_curves_set_and_retrieve_defaults(node)
            
            # Clear menu caches
            # This is needed to help to updates the menus from time to time so to pick up sneaky changes to the loaded files
            # (ex. the user perform hand made modifications like renaming a Preset and such).
            flam3h_iterator_utils(self.kwargs).destroy_all_menus_data(node, True)
            
            # lock private parameters not being locked on creation by other definitions.
            self.flam3h_on_create_lock_parms(node)
            
        else:
            self.flam3h_on_create_compatible_false()


    # def flam3h_on_loaded_set_density_menu(self) -> None:
    #     """This is for backward compatibility when the point count parameter was still exposed.
    #     It will set the density presets menu to the closest point count value
        
    #     The density values dictionary entries match whats inside: def menu_global_density_set(self) -> None:
    #     and also the entries inside the global menu: f3h_menus.DENSITY
        
    #     Any changes to the entries on one of those need to be made also on the others.
        
    #     Returns:
    #         (None):
    #     """
    #     node: hou.SopNode = self.node
    #     density = node.parm(f3h_tabs.GLB.DENSITY).eval()
    #     density_values: dict = { 500000: 1, 1000000: 2, 2000000: 3, 5000000: 4, 15000000: 5, 25000000: 6, 50000000: 7, 100000000: 8, 150000000: 9, 250000000: 10, 500000000: 11, 750000000: 12, 1000000000: 13 }
    #     density_new = min(density_values.keys(), key=lambda x:abs(x-density))
    #     node.parm(f3h_tabs.GLB.DENSITY_PRESETS).set(density_values.get(density_new))
    #     node.parm(f3h_tabs.GLB.DENSITY).set(density_new)


    def flam3h_on_loaded_compatible_false(self) -> None:
        """When FLAM3H™ is loaded into an incompatible Houdini version on hip file load and on node copy/clone this code is run.
        
        Note:
            This will need to be expanded at some point in time, for now it is enough to catch the versions and show the incompatibility for simple cases.
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        
        # For now we set both cases the same
        if hou.hipFile.isLoadingHipFile(): #type: ignore
            self.flam3h_on_create_compatible_false(False, False)
        else:
            self.flam3h_on_create_compatible_false(False, False)
            
            
    def flam3h_on_loaded_compatible_true(self) -> None:
        """If we are loading hip files with FLAM3H™ nodes in it that were prviewsly initialized with an incompatible version of Houdini,</br>
        restore their default settings if their iterators count is set to Zero, otherwise leave them as they are to not modify exixting settings.</br>
        
        This definition must run inside a:
        * if hou.hipFile.isLoadingHipFile():
            ....
        
        Note:
            This may be extended in the future, depending on needs.
        
        To be used inside:
        * def flam3h_on_loaded(self) -> None:
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        # This is done in case the user saved a hip file with FLAM3H™ nodes in it
        # while using an incompatible version of Houdini so that we can restore it to functional again.
        h_valid_prm: hou.Parm = node.parm(f3h_tabs.PREFS.PVT_PRM_H_VALID)
        if not h_valid_prm.eval():
            flam3h_prm_utils.private_prm_set(self.node, h_valid_prm, 1)
            
            # Only if the iterators count is Zero
            # This mean that this FLAM3H™ node was created inside an unsopported Houdini version
            iter_count_prm: hou.Parm = node.parm(f3h_tabs.PRM_ITERATORS_COUNT)
            if not iter_count_prm.eval():
                flam3h_iterator_utils(self.kwargs).flam3h_default()
            
                # lock private parameters not being locked on creation by other definitions.
                # The Private parameters are unlocked becasue this definition will only run
                # if the FLAM3H™ node was previewsly created and saved in an unsopported Houdini version so we need to re-lock them.
                self.flam3h_on_create_lock_parms(node)
            

    def flam3h_on_loaded(self) -> None:
        """Initialize FLAM3H™ node on hip file load and all the data it need to run.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        if self.flam3h_compatible_type(__range_type__):
            
            # Force updated of the mini-menu iterator selection
            flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
            flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.edge_case_01)
            # CP and IN PRESETS filepaths (cache data)
            self.flam3h_presets_cache_filepath_on_load()
            # Turn iterators/FF post affine OFF if they are default values
            self.is_post_affine_default_on_load(node)
            
            # init xaos
            flam3h_iterator_utils(self.kwargs).auto_set_xaos()
            
            if hou.hipFile.isLoadingHipFile(): #type: ignore
                
                # Restore if it is needed
                self.flam3h_on_loaded_compatible_true()
                
                # set density menu
                flam3h_iterator_utils.flam3h_on_loaded_set_density_menu(node)
                
                # This is important so loading a hip file with a FLAM3H™ node inside
                # it wont block the houdini session until user input.
                self.flam3h_check_first_node_instance_msg(False)
                
                # Update FLAM3H™ viewport preferences
                self.flam3h_on_create_set_prefs_viewport()
                # Init FLAM3H™ xform handles viz viewport' wire width
                self.flam3h_on_create_init_viewportWireWidth()
                
                # init CP PRESETS: mode (int): ZERO: To be used to prevent to load a preset when loading back a hip file.
                flam3h_general_utils(self.kwargs).flam3h_init_presets_CP_PRESETS(0)
                # init IN PRESETS: mode (int): ZERO: To be used to prevent to load a preset when loading back a hip file.
                flam3h_general_utils(self.kwargs).flam3h_init_presets_IN_PRESETS(0)
                # init OUT PRESETS
                flam3h_general_utils(self.kwargs).flam3h_init_presets_OUT_PRESETS()
                # init RIP: Remove Invalid Points
                flam3h_iterator_utils.flam3h_on_load_opacity_zero(node)
                
                # Set color correction curves to their defaults if there is need to do it (ex: hip files with older version of FLAM3H™)
                out_flame_utils.out_render_curves_set_defaults_on_load(node)
                
                # update about tab just in case
                flam3h_about_utils(self.kwargs).flam3h_about_msg()
                flam3h_about_utils(self.kwargs).flam3h_about_plugins_msg()
                flam3h_about_utils(self.kwargs).flam3h_about_web_msg()
                
                # CAMERA SENSOR
                #
                # If a FLAM3H™ node is in camera sensor mode and its display flag ON, update the viewport to actually be in camera sensor mode.
                # This work with multiple FLAM3H™ node becasue there can only be one FLAM3H™ node in camera sensor mode at any given time.
                if node.isGenericFlagSet(hou.nodeFlag.Display) and node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval(): # type: ignore
                    flam3h_general_utils(self.kwargs).util_set_clipping_viewers()
                    flam3h_general_utils(self.kwargs).util_set_front_viewer()
                else:
                    # Otherwise just turn the camera sensor mode OFF.
                    if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)
                        # Clear stashed cams data
                        flam3h_general_utils.util_clear_stashed_cam_data()
                
                # The following is a workaround to keep the correct preset inside the IN Tab when the hip file was saved
                # as it always get reset to ZERO on load for some reason. The preset inside the SYS Tab is correct after load.
                # Need to investigate why. the IN_SYS_PRESETS menu parameter is set inside:
                # 
                #   - in_flame_utils(self.kwargs).in_to_flam3h()
                #   - in_flame_utils(self.kwargs).in_to_flam3h_sys()
                #
                #
                # They are already unlocked and cleared from their keyframes from the above: flam3h_general_utils(self.kwargs).flam3h_init_presets_IN_PRESETS(0) 
                node.parm(f3h_tabs.IN.PRM_PRESETS).set(node.parm(f3h_tabs.IN.PRM_SYS_PRESETS).eval())
                node.parm(f3h_tabs.IN.PRM_PRESETS_OFF).set(node.parm(f3h_tabs.IN.PRM_SYS_PRESETS_OFF).eval())
                
                
                # Same goes for the palette preset entrie, and some time goes also out of range
                # so we store the selection first inside a mem menu parameter on Load inside:
                #
                #   - flam3h_palette_utils(self.kwargs).json_to_flam3h_ramp_SET_PRESET_DATA(node)
                #   - flam3h_palette_utils(self.kwargs).json_to_flam3h_ramp_sys()
                #
                # and on Save inside:
                #
                #   - flam3h_palette_utils(self.kwargs).flam3h_ramp_save()
                #
                #
                # They are already unlocked and cleared from their keyframes from the above: flam3h_general_utils(self.kwargs).flam3h_init_presets_CP_PRESETS(0)
                node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS).set(node.parm(f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS).eval())
                node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS_OFF).set(node.parm(f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS_OFF).eval())

                # init/clear copy/paste iterator's data and prm
                # This was causing some issues and got updated.
                flam3h_iterator_utils(self.kwargs).flam3h_paste_reset_hou_session_data(True)
                # If in the loaded hip file there are data stored into the nodes, lets set the copy/paste data from them.
                # This will allow to re-load an hip file with marked iterator or FF and pick up from there, which is nice.
                flam3h_iterator_utils.flam3h_init_hou_session_restore_from_user_data(node)
                
            else:
                # CAMERA SENSOR
                # If camera sensor is ON
                if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
                    # lets turn it OFF.
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)
                    # Restore anc clear stashed cams data
                    flam3h_general_utils.util_set_stashed_cam()
                    flam3h_general_utils(self.kwargs).flam3h_other_sensor_viz_off(node)
                    
                # Reset memory mpidx prm data
                flam3h_iterator_utils.iterator_mpidx_mem_set(node, 0)
                # init RIP: Remove Invalid Points: ALL
                flam3h_iterator_utils.flam3h_on_load_opacity_zero(node, True)
                
                # Clear menu caches
                # This is needed to help to updates the menus from time to time so to pick up sneaky changes to the loaded files
                # (ex. the user perform hand made modifications like renaming a Preset and such).
                flam3h_iterator_utils(self.kwargs).destroy_all_menus_data(node, True)
                # Check and Update this data
                flam3h_iterator_utils(self.kwargs).update_xml_last_loaded(False)
                
                # Clear any comment and user data from the node
                if flam3h_iterator_utils.exist_user_data(node):
                    flam3h_iterator_utils.del_comment_and_user_data_iterator(node)
                if flam3h_iterator_utils.exist_user_data(node, f3h_userData.MARKED_FF):
                    flam3h_iterator_utils.del_comment_and_user_data_iterator(node, f3h_userData.MARKED_FF)
        
        else:
            self.flam3h_on_loaded_compatible_false()


    def flam3h_on_deleted(self) -> None:
        """Cleanup the data on deletion.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        self.unpin_parameter_editor_with_f3h_node(node)
        
        node_instances: tuple[hou.SopNode, ...] = node.type().instances()
        
        if len(node_instances) == 1:
            
            # Init the Copy/Paste data to defaults
            self.hou_session_data_clear_and_restore()
            
            # Restore and delete the xforms handles VIZ data if needed
            flam3h_general_utils.util_xf_viz_set_stashed_wire_width()
            flam3h_general_utils.util_clear_xf_viz_stashed_wire_width_data()
            
            # Delete all data related to the Camera sensor viz
            flam3h_general_utils.util_clear_stashed_cam_data()
            
        else:
            # Clear menu caches
            # This is needed to help to updates the menus from time to time so to pick up sneaky changes to the loaded files
            # (ex. the user perform hand made modifications like renaming a Preset and such).
            flam3h_iterator_utils(self.kwargs).destroy_all_menus_data(node, True)
            # Check and Update this data
            flam3h_iterator_utils(self.kwargs).update_xml_last_loaded(False)
            
            # If we are deleting a FLAM3H™ node in xforms handles VIZ mode
            # check if others FLAM3H™ node are in xfomrs handles VIZ mode as well
            # and if not, restore the H viewports wire widths data
            if flam3h_general_utils(self.kwargs).util_other_xf_viz() is False:
                flam3h_general_utils.util_xf_viz_set_stashed_wire_width()
                flam3h_general_utils.util_clear_xf_viz_stashed_wire_width_data()
            
            # If we are deleting a FLAM3H™ node in camera Sensor Viz mode,
            # restore the viewers to their preview states and clear all the stashed cams data
            if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
                flam3h_general_utils.util_set_stashed_cam()
                flam3h_general_utils.util_clear_stashed_cam_data()
            
            if hou.session.F3H_MARKED_FF_CHECK: # type: ignore
                from_FLAM3H_NODE: TA_MNode = hou.session.F3H_MARKED_FF_NODE # type: ignore
                
                if node == from_FLAM3H_NODE and node_instances:
                    hou.session.F3H_MARKED_FF_CHECK: TA_M = None # type: ignore
                    hou.session.F3H_MARKED_FF_NODE: TA_MNode = node_instances[0] # type: ignore
                    
                    _MSG: str = f"The FLAM3H™ node you just deleted had its FF marked for being copied. Please, mark a FF first to copy parameters from."
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'IMP')
                    flam3h_general_utils.flash_message(node, f"FF marked node: DELETED")


# FLAM3H™ GENERAL UTILS start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class flam3h_general_utils:
    """
class flam3h_general_utils

@STATICMETHODS
* is_list_of_lists(x: list) -> bool:
* is_flat_list(x: list) -> bool:
* is_tuple_of_tuples(x: tuple) -> bool:
* is_flat_tuple(x: tuple) -> bool:
* select_file_start_dir(node: hou.SopNode, type: str = IN_PATH) -> str | None:
* flash_message(node: hou.SopNode, msg: str | None, timer: float = f3h_tabs.DEFAULT_FLASH_MESSAGE_TIMER, img: str | None = None, usd_context: str = 'Lop') -> None:
* remove_locked_from_flame_stats(node) -> None:
* houdini_version(digit: int=1) -> int:
* clamp(x, val_max: int | float = 255) -> float:
* reset_density(node: hou.SopNode) -> None:
* my_system() -> str:
* set_status_msg(msg: str, msg_type: str) -> None:
* isLOCK(filepath: str | bool) -> bool:
* util_open_file_explorer(filepath_name: str) -> None:
* util_getParameterEditors() -> list[hou.ParameterEditor]:
* util_getSceneViewers() -> list[hou.SceneViewer]:
* util_getNetworkEditors() -> list[hou.NetworkEditor]:
* util_is_context(context: str, viewport: hou.SceneViewer | hou.NetworkEditor | hou.ParameterEditor) -> bool:
* util_is_context_available_viewer(context: str) -> bool:
* util_is_context_available_viewer_data(context: str) -> tuple[bool, list[hou.SceneViewer]]:
* util_is_context_available_network_editor(context: str) -> bool:
* util_clear_stashed_cam_data() -> None:
* util_set_stashed_cam() -> None:
* util_clear_xf_viz_stashed_wire_width_data() -> None:
* util_xf_viz_set_stashed_wire_width() -> None:
* util_xf_viz_force_cook(node: hou.SopNode, kwargs: dict) -> None:
* util_store_all_viewers_color_scheme_onCreate() -> None:
* mp_xf_viz_solo_follow_prev_off(node: hou.SopNode) -> None:

@METHODS
* reset_parm(self, val: tuple[int | float, ...]) -> None:
* menus_refresh_enum_prefs(self) -> None:
* get_node_path(self, node_name: str) -> str | None:
* util_set_clipping_viewers(self) -> None:
* util_store_all_viewers(self) -> None:
* util_set_front_viewer(self, update: bool=True) -> bool:
* util_set_front_viewer_all(self, 
                            node: hou.SopNode, 
                            viewports: list[hou.SceneViewer], 
                            update_sensor: int, 
                            _SYS_FRAME_VIEW_SENSOR_prm: int, 
                            update: bool = True
                            ) -> bool:
* util_store_all_viewers_xf_viz(self) -> None:
* util_other_xf_viz(self) -> bool:
* util_viewport_bbox_frame(self) -> None:
* flam3h_other_sensor_viz_off(self, node: hou.SopNode) -> None:
* flam3h_outsensor_toggle(self, prm_name: str = f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR) -> None:
* flam3h_xf_viz_toggle(self, prm_name: str = PREFS_PVT_XF_VIZ) -> None:
* flam3h_all_mp_xf_viz_check(self) -> bool:
* flam3h_toggle_sys_xf_viz_solo(self) -> None:
* flam3h_toggle_sys_xf_ff_viz_solo(self) -> None:
* flam3h_toggle_mp_xf_viz(self) -> None:
* flam3h_toggle_mp_xf_viz_solo_follow(self, mp_idx: str) -> None:
* flam3h_toggle_xf_ff_viz(self) -> None:
* flam3h_toggle(self, prm_name: str) -> None:
* flam3h_toggle_private(self, prm_name: str) -> None:
* flam3h_toggle_private_FF(self, prm_name: str = PREFS_PVT_DOFF) -> None:
* flam3h_toggle_off(self, prm_name: str) -> None:
* flam3h_init_presets_CP_PRESETS(self, mode: int = 1, destroy_menus: bool = True, json_file: bool | None = None, f3h_json_file: bool | None = None, json_path_checked: str | bool | None = None) -> None:
* flam3h_init_presets_IN_PRESETS(self, mode: int = 1) -> None:
* flam3h_init_presets_OUT_PRESETS(self, destroy_menus: bool = True) -> None:
* flam3h_display_help(self) -> None:
* util_store_all_viewers_color_scheme(self) -> None:
* colorSchemeDark(self, update_others: bool = True) -> None:
* viewportParticleDisplay(self) -> None:
* viewportParticleSize(self, reset_val: float | None = None, prm_name_size: str = f3h_tabs.PREFS.PRM_VIEWPORT_PT_SIZE) -> None:
* viewportWireWidth(self, reset_val: float | None = None) -> None:
* reset_SYS(self, density: int, iter: int, mode: int) -> None:
* reset_MB(self, all: bool = True) -> None:
* reset_PREFS(self, mode: int = 0) -> None:
    """    
    
    __slots__ = ("_cached_data", 
                 "_kwargs", "_node", "_bbox_sensor_path", "_bbox_reframe_path")
    
    def __init__(self, kwargs: dict) -> None:
        """
        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """ 
        self._kwargs: dict[str, Any] = kwargs
        self._node: hou.SopNode = kwargs['node']
        # Why am I doing the following ? Because with time FLAM3H™ grew and evolved and I was tiered to keep updating an hard coded node path,
        # hence I added the following so I can always find the nodes even if I place them in different locations from time to time.
        self._bbox_sensor_path: str | None = self.get_node_path(f3h_nodeNames.DEFAULT_OUT_BBOX_SENSOR)
        self._bbox_reframe_path: str | None = self.get_node_path(f3h_nodeNames.DEFAULT_OUT_BBOX_REFRAME)
        
    
    @staticmethod
    def is_list_of_lists(x: list) -> bool:
        """Check if the passed in list is a list of lists.</br>
        
        Args:
            x(list): the list to check
            
        Returns:
            (bool): True if it is a list of lists and False if not
        """ 
        return isinstance(x, list) and all(isinstance(el, list) for el in x)
        # If you want to treat an empty list as not a list of lists, change the logic
        # return isinstance(x, list) and x != [] and all(isinstance(el, list) for el in x)
    
    
    @staticmethod
    def is_flat_list(x: list) -> bool:
        """Check if the passed in list is a flat lists.</br>
        
        Args:
            x(list): the list to check
            
        Returns:
            (bool): True if it is a flat lists and False if not
        """ 
        return isinstance(x, list) and not any(isinstance(el, list | tuple | set) for el in x)
    
    
    @staticmethod
    def is_tuple_of_tuples(x: tuple) -> bool:
        """Check if the passed in tuple is a tuple of tuples.</br>
        
        Args:
            x(list): the tuple to check
            
        Returns:
            (bool): True if it is a tuple of tuples and False if not
        """ 
        return isinstance(x, tuple) and all(isinstance(el, tuple) for el in x)
        # If you want to treat an empty tuple as not a tuple of tuples, change the logic
        # return isinstance(x, tuple) and x != () and all(isinstance(el, tuple) for el in x)
    
    
    @staticmethod
    def is_flat_tuple(x: tuple) -> bool:
        """Check if the passed in tuple is a flat tuple.</br>
        
        Args:
            x(list): the tuple to check
            
        Returns:
            (bool): True if it is a flat tuple and False if not
        """ 
        return isinstance(x, tuple) and not any(isinstance(el, list | tuple | set) for el in x)
        
    
    @staticmethod
    def select_file_start_dir(node: hou.SopNode, type: str = f3h_tabs.IN.PRM_PATH) -> str | None:
        """Return the filepath string for either the CP or IN filepath parameter if any, otherwise return None if empty or invalid.</br>
        If an invalid filepath is present, it will try to extrapolate out the parent directory first and check for its validity, otherwise return: None
        
        Args:
            node(hou.SopNode): this FLAM3H™ node.
            type(str): Default to: IN_PATH</br>the parameter name for either the CP or IN filepath (respectively: f3h_tabs.CP.PATH, IN_PATH or OUT_PATH).
            
        Returns:
            (None):
        """ 
        # Get start directory if one is already set in the CP oir IN tabs filepath parameter (e.g. a Palette or a Flame file is already being loaded)
        CP_filepath: str = os.path.expandvars(node.parm(type).eval())
        _is_file: bool = os.path.isfile(CP_filepath) if CP_filepath else False
        if _is_file:
            CP_filepath_dir: str | None = os.path.split(CP_filepath)[0]
        else:
            _dir: str = os.path.split(CP_filepath)[0]
            if os.path.isdir(_dir): CP_filepath_dir = _dir
            else: CP_filepath_dir: str | None = None
            
        return CP_filepath_dir


    @staticmethod
    def flash_message(node: hou.SopNode, msg: str | None, timer: float = f3h_tabs.DEFAULT_FLASH_MESSAGE_TIMER, img: str | None = None, usd_context: str = 'Lop') -> None:
        """Cause a message to appear on the top left of the network editor.</br>
        This will work either in Sop and Lop context as it is handy to get those messages either ways.</br>
        
        Note:
            Whne working with FLAM3HUSD inside the Solaris context, a flash message will be sent to any available Lop viewers
            to make it easier for the user to read them since in that case the network editor real estate area will most likely be covered with parameters editor interfaces.

        Args:
            node(hou.SopNode): the current FLAM3H™ node.
            msg(str | None): The string message to print or None.
            timer(float): Default to: FLAM3H_FLASH_MESSAGE_TIMER (2 sec)</br>How long the printed message stay before it fade away.
            img(str | None): Default to: None</br>Specifies an icon or image file that should be displayed along with the text specified in the msg argument.
            usd_context(str): Default to: 'Lop'</br>The name of the context being used when working in the USD Solaris with FLAM3HUSD.

        Returns:
            (None):
        """  
        if hou.isUIAvailable() and node.parm(f3h_tabs.PREFS.PRM_FLASH_MSG).eval():
            for ne in (p for p in hou.ui.paneTabs() if p.type() == hou.paneTabType.NetworkEditor): ne.flashMessage(img, msg, timer) # type: ignore
            # Force the flash message to appear in any Lop viewers available.
            # This is being done because it is more handy for the user to read the message in the Lop viewers
            # when working through the FLAM3HUSD HDA instead of the network editor that it is usually covered with parameters editor interfaces.
            lop_viewer_available, viewers = flam3h_general_utils.util_is_context_available_viewer_data(usd_context)
            if lop_viewer_available:
                for view in (v for v in viewers if flam3h_general_utils.util_is_context(usd_context, v) and v.isViewingSceneGraph()): view.flashMessage('', msg, timer)

    
    @staticmethod
    def remove_locked_from_flame_stats(node) -> None:
        """When loading a flame preset from the clipboard while a valid locked flame library is loaded,</br>
        deleting the path string will leave the text: -> LOCKED inside the stats.</br>
        This definition will remove it.</br>

        Args:
            node (hou.SopNode): This FLAM3H™ node
            
        Returns:
            (None):
        """  
        stats: str = node.parm(f3h_tabs.IN.MSG_PRM_FLAMESTATS).eval()
        lines: list[str] = stats.splitlines()
        # Just in case lets check the str.lower()
        if str(lines[0]).lower().startswith(f3h_tabs.IN.DEFAULT_MSG_FLAMESTATS_LOCK.__str__().lower()): lines[0] = ''
        stats_join: str = "\n".join(lines)
        flam3h_prm_utils.set(node, f3h_tabs.IN.MSG_PRM_FLAMESTATS, stats_join)


    @staticmethod
    def houdini_version(digit: int=1) -> int:
        """Retrieve the major Houdini version number currently in use.</br>

        Args:
            digit(int): Default to: 1</br>19, 20. if set to 2: 190, 195, 200, 205, and so on.

        Returns:
            (int): By default it will retrieve major Houdini version number. ex: 19, 20 but not: 195, 205
        """  
        return int(''.join(str(x) for x in hou.applicationVersion()[:digit]))


    @staticmethod  
    def clamp(x, val_max: int | float = 255) -> float:
        """clamp a value to be between Zero and 255.</br>

        Args:
            x(int | float): the value to clamp.
            val_max(int | float): Default to: 255</br>Max value to clamp to.

        Returns:
            float: value clamped between Zero and 255.
        """
        return float(max(0, min(x, val_max)))


    @staticmethod
    def reset_density(node: hou.SopNode) -> None:
        """Reset/set density to its default.</br>

        Args:
            (None):

        Returns:
            (None):
        """  
        prm = node.parm(f3h_tabs.GLB.PRM_DENSITY)
        prm_presets = node.parm(f3h_tabs.GLB.PRM_DENSITY_PRESETS)
        
        prm.lock(False)
        prm.deleteAllKeyframes()
        
        prm_presets.lock(False)
        prm_presets.deleteAllKeyframes()
        
        prm.set(f3h_tabs.GLB.DEFAULT_DENSITY)
        prm_presets.set(1)


    @staticmethod
    def my_system() -> str:
        """Return the OS we are on.

        Args:
            (None):
            
        Returns:
            (str): Possible outcomes are: 
            * WIN (windows)
            * LNX (linux)
            * MAC
            * JAVA
            * UNKNW
        """
        sys: str = platform_system()
        sys_options: dict[str, str] = {'Windows': 'WIN', 'Linux': 'LNX', 'Darwin': 'MAC', 'Java': 'JAVA'}
        mysys: str | None = sys_options.get(sys)
        if mysys is not None:
            return mysys
        
        return 'UNKNW'


    @staticmethod
    def set_status_msg(msg: str, msg_type: str) -> None:
        """Print a message to the Houdini's status bar if the UI is available.</br>

        Args:
            msg(str): The message string to print
            msg_type(str): The type of severity message to use, Possible choises are:
            
            * MSG ( message )
            * IMP ( important message )
            * WARN ( warning )
            
            If type is mispelled, it will fallback to: hou.severityType.Message
            
        Returns:
            (None):
        """
        
        if hou.isUIAvailable():
            st: dict[str, hou.EnumValue] = { 'MSG': hou.severityType.Message, 'IMP': hou.severityType.ImportantMessage, 'WARN': hou.severityType.Warning }  # type: ignore
            severityType: hou.EnumValue | None = st.get(msg_type)
            if severityType is not None:
                hou.ui.setStatusMessage(msg, severityType) # type: ignore
            else:
                # If the selected severity type is not found, use the default severity type: hou.severityType.Message
                # This mostly not to make it error out if the user make a typo or such.
                hou.ui.setStatusMessage(f"\"{msg_type}\" is not a recognized hou.severityType, using \"MSG\" instead. {msg}", hou.severityType.Message) # type: ignore


    @staticmethod
    def isLOCK(filepath: str | bool) -> bool:
        """Check if the loaded lib file ( Palette or flame XML ) is locked.</br>

        Args:
            filepath(str | bool): the full lib file path.

        Returns:
            (bool): True if locked. False if not.
        """
        if filepath is not False:
            if os.path.exists(filepath) and os.path.split(str(filepath))[-1].upper().startswith(FLAM3H_LIB_LOCK):
                return True
            
            return False
        
        return False


    @staticmethod
    def util_open_file_explorer(filepath_name: str) -> None:
        """Open the file explorer to the currently loaded file location.</br>

        Args:
            filepath_name(str): The currently loaded file name full path.
            
        Returns:
            (None):
        """
        # If it is an exisiting valid file path
        if os.path.isfile(filepath_name):
            hou.ui.showInFileBrowser(filepath_name) # type: ignore
            
        # If the parent directory exist
        else:
            dir = os.path.dirname(filepath_name)
            if os.path.isdir(dir):
                hou.ui.showInFileBrowser(dir) # type: ignore
                
                
    @staticmethod
    def util_getParameterEditors() -> list[hou.ParameterEditor]:
        """Return a list of Parameter Editors currently open in this Houdini session.</br>
        It will collect only the Parameter Editors with a FLAM3H™ node parameter on display already.</br>
        
        Args:
            (None):
            
        Returns:
            (list): [return a list of open Parmaeter Editors with a FLAM3H™ node on display]
        """    
        parms: tuple[Any, ...] = hou.ui.paneTabs() # type: ignore
        return [p for p in parms if isinstance(p, hou.ParameterEditor) and p.currentNode().type().nameWithCategory() == F3H_NODE_TYPE_NAME_CATEGORY]


    @staticmethod
    def util_getSceneViewers() -> list[hou.SceneViewer]:
        """Return a list of viewer currently open in this Houdini session.</br>
        
        Args:
            (None):
            
        Returns:
            (list): [return a list of open scene viewers]
        """    
        views: tuple[Any, ...] = hou.ui.paneTabs() # type: ignore
        return [v for v in views if isinstance(v, hou.SceneViewer)]
    
    
    @staticmethod
    def util_getNetworkEditors() -> list[hou.NetworkEditor]:
        """Return a list of NetworkEditors currently open in this Houdini session.</br>
        
        Args:
            (None):
            
        Returns:
            (list): [return a list of open scene viewers]
        """    
        views: tuple[Any, ...] = hou.ui.paneTabs() # type: ignore
        return [v for v in views if isinstance(v, hou.NetworkEditor)]
    
    
    @staticmethod
    def util_is_context(context: str, viewport: hou.SceneViewer | hou.NetworkEditor | hou.ParameterEditor) -> bool:
        """Return if we are inside a context or not.</br>
        
        Args:
            context(str): The context we want to check if we are currently in.</br>Options so far are: 
                * Object: str
                * Sop: str
                * Lop: str
            viewport(hou.paneTabType): Any of the available pane tab types,</br>in my case will always be: hou.paneTabType.SceneViewer or hou.SceneViewer
            
        Returns:
            (bool): True if we are in a desired context or False if we are not.
        """    
        context_now: hou.NodeTypeCategory = hou.ui.findPaneTab(viewport.name()).pwd().childTypeCategory() # type: ignore
        if str(context_now.name()).lower() == context.lower():
            return True
        
        return False


    @staticmethod
    def util_is_context_available_viewer(context: str) -> bool:
        """Return if there are viewers that belong to a desired context.</br>
        
        Args:
            context(str): The context we want to check if we are currently in. Options so far are: 
                * Object: str
                * Sop: str
                * Lop: str
            
        Returns:
            (bool): [True if there is at least one viewer that belong to a desired context or False if not.]
        """    
        available = False
        for v in flam3h_general_utils.util_getSceneViewers():
            if flam3h_general_utils.util_is_context(context, v):
                available = True
                break
            
        return available
    
    
    @staticmethod
    def util_is_context_available_viewer_data(context: str) -> tuple[bool, list[hou.SceneViewer]]:
        """Return if there are viewers that belong to a desired context and a list of all viewers.</br>
        
        This is being added as an alternative to:
        * def util_is_context_available_viewer(context: str) -> bool:
        
        It perform the same operations</br>
        but will also return all the data available instead of just getting a bool.
        
        Args:
            context(str): The context we want to check if we are currently in. Options so far are: 
                * Object: str
                * Sop: str
                * Lop: str
            
        Returns:
            (tuple[bool, list[hou.SceneViewer]]): A tuple containing a bool and a list of viewers.</br>The bool will tell us if there is at least one viewer that belong to a desired context and the list will contain all available viewers.
        """    
        available = False
        viewers: list[hou.SceneViewer] = flam3h_general_utils.util_getSceneViewers()
        for v in viewers:
            if flam3h_general_utils.util_is_context(context, v):
                available = True
                break
            
        return available, viewers
    
    
    @staticmethod
    def util_is_context_available_network_editor(context: str) -> bool:
        """Return if there are network editors that belong to a desired context.</br>
        
        Args:
            context(str): The context we want to check if we are currently in. Options so far are: 
                * Object: str
                * Sop: str
                * Lop: str
            
        Returns:
            (bool): [True if there is at least one NetworkEditor that belong to a desired context or False if not.]
        """    
        available = False
        for v in flam3h_general_utils.util_getNetworkEditors():
            if flam3h_general_utils.util_is_context(context, v):
                available = True
                break
            
        return available
    

    @staticmethod
    def util_clear_stashed_cam_data() -> None:
        """Clear the stored stashed cam/cams data.

        Args:
            (None):
            
        Returns:
            (None):
        """
        try: del hou.session.F3H_SENSOR_CAM_STASH # type: ignore
        except AttributeError: pass
        try: del hou.session.F3H_SENSOR_CAM_STASH_TYPE # type: ignore
        except AttributeError: pass
        try: del hou.session.F3H_SENSOR_CAM_STASH_COUNT # type: ignore
        except AttributeError: pass
        try: del hou.session.F3H_SENSOR_CAM_STASH_DICT # type: ignore
        except AttributeError: pass
        try: del hou.session.F3H_SENSOR_CAM_STASH_TYPE_DICT # type: ignore
        except AttributeError: pass


    @staticmethod
    def util_set_stashed_cam() -> None:
        """Set/Load the stored stashed camera if a stashed camera data is available.</br>
        It will also restore multiple stashed cameras if multiple viewers were open when entering the Sensor Viz mode.</br>

        Args:
            (None):
            
        Returns:
            (None):
        """
        desktop: hou.Desktop = hou.ui.curDesktop() # type: ignore
        viewport: hou.SceneViewer = desktop.paneTabOfType(hou.paneTabType.SceneViewer) # type: ignore
        
        try: _CAMS: int | None = hou.session.F3H_SENSOR_CAM_STASH_COUNT # type: ignore
        except AttributeError: _CAMS: int | None = None
        
        if _CAMS is None:
            
            if viewport is not None and viewport.isCurrentTab() and (flam3h_general_utils.util_is_context('Sop', viewport) or flam3h_general_utils.util_is_context('Object', viewport)):
                
                view: hou.GeometryViewport = viewport.curViewport()
                
                try: _CAM_STASHED: hou.GeometryViewportCamera | None = hou.session.F3H_SENSOR_CAM_STASH # type: ignore
                except AttributeError: _CAM_STASHED: hou.GeometryViewportCamera | None = None
                    
                if _CAM_STASHED is not None:
                    
                    if _CAM_STASHED.isPerspective():
                        view.changeType(hou.geometryViewportType.Perspective) # type: ignore
                        view.setDefaultCamera(_CAM_STASHED) # type: ignore
                        
                    elif _CAM_STASHED.isOrthographic:
                        
                        try: _CAM_STASHED_TYPE: hou.geometryViewportType | None = hou.session.F3H_SENSOR_CAM_STASH_TYPE # type: ignore
                        except AttributeError: _CAM_STASHED_TYPE: hou.geometryViewportType | None = None
                            
                        if _CAM_STASHED_TYPE is not None:
                            view.changeType(_CAM_STASHED_TYPE) # type: ignore
                            view_obj = view.defaultCamera()
                            view_obj.setOrthoWidth(_CAM_STASHED.orthoWidth())
                            view_obj.setTranslation(_CAM_STASHED.translation())
                            
        else:
            try: _STASH_DICT: dict[str, hou.GeometryViewportCamera] | None = hou.session.F3H_SENSOR_CAM_STASH_DICT # type: ignore
            except AttributeError: _STASH_DICT: dict[str, hou.GeometryViewportCamera] | None = None
            try: _TYPE_DICT: dict[str, hou.geometryViewportType] | None = hou.session.F3H_SENSOR_CAM_STASH_TYPE_DICT # type: ignore
            except AttributeError: _TYPE_DICT: dict[str, hou.geometryViewportType] | None = None
                
            if _STASH_DICT is not None and _TYPE_DICT is not None:
                
                for v in flam3h_general_utils.util_getSceneViewers():
                    
                    # Restore only if it is a Sop viewer
                    if flam3h_general_utils.util_is_context('Sop', v) or flam3h_general_utils.util_is_context('Object', v):
                        
                        view: hou.GeometryViewport = v.curViewport()
                        key: str = v.name()
                        _STASH: hou.GeometryViewportCamera | None = _STASH_DICT.get(key)
                        if _STASH is not None:
                            if _STASH.isPerspective():
                                view.changeType(hou.geometryViewportType.Perspective) # type: ignore
                                view.setDefaultCamera(_STASH) # type: ignore
                                
                            elif _STASH.isOrthographic:
                                _TYPE: hou.geometryViewportType | None = _TYPE_DICT.get(key)
                                if _TYPE is not None:
                                    view.changeType(_TYPE) # type: ignore
                                    view_obj = view.defaultCamera()
                                    view_obj.setOrthoWidth(_STASH.orthoWidth())
                                    view_obj.setTranslation(_STASH.translation())
        
                                
    @staticmethod
    def util_clear_xf_viz_stashed_wire_width_data() -> None:
        """Clear the stored stashed cam/cams data.</br>

        Args:
            (None):
            
        Returns:
            (None):
        """
        try: del hou.session.H_XF_VIZ_WIRE_WIDTH_STASH_DICT # type: ignore
        except AttributeError: pass
    
    
    @staticmethod
    def util_xf_viz_set_stashed_wire_width() -> None:
        """Set/Load the stored stashed cameras viewport wire widths.</br>

        Args:
            (None):
            
        Returns:
            (None):
        """
        
        # This stashed dict is already without any Lop viewers. They have been filtered inside:
        #   * flam3h_general_utils.util_store_all_viewers_xf_viz(self) -> None:
        try: _STASH_DICT: dict[str, float] | None = hou.session.H_XF_VIZ_WIRE_WIDTH_STASH_DICT # type: ignore
        except AttributeError: _STASH_DICT: dict[str, float] | None = None
        
        if _STASH_DICT is not None:
            for v in flam3h_general_utils.util_getSceneViewers():
                view: hou.GeometryViewport = v.curViewport()
                key: str = v.name()
                # Since all the viewers inside this stashed dict are sure not to be a Lop viewer
                # we do not need to check and we can just proceed.
                _STASH: float | None = _STASH_DICT.get(key)
                if _STASH is not None:
                    settings: hou.GeometryViewportSettings = view.settings()
                    settings.wireWidth(_STASH)


    @staticmethod
    def util_xf_viz_force_cook(node: hou.SopNode, kwargs: dict) -> None:
        """Force viewport xforms handles VIZ to cook when the mode is OFF</br>
        to have the geometry ready when the user turn the mode ON.</br>
        
        If not success, it will pass silently and throw a warning message.

        Args:
            node(hou.SopNode): This FLAM3H™ node
            kwargs:(dict): this FLAM3H™ node kwargs
            
        Returns:
            (None):
        """   
        if not node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ).eval():
            # BUILD XFVIZ
            try: hou.node(flam3h_general_utils(kwargs).get_node_path(f3h_nodeNames.DEFAULT_XFVIZGL)).cook(force=True)
            except AttributeError:
                flam3h_general_utils.set_status_msg(f"{node.name()}: XF VIZ node not found.", 'WARN')


    @staticmethod
    def util_store_all_viewers_color_scheme_onCreate() -> None:
        """Store dictionaries of viewers color schemes if needed on FLAM3H™ node creation</br>
        This version do not check from which parameter run as we need it to run regardless.</br></br>
        
        It will check the currently stored color schemes data and update it if there is a need to do so.</br>
        
        Args:
            node(hou.SopNode): This FLAM3H™ node
            
        Returns:
            (None):  
        """  
        # Check if the required data exist already
        try:
            hou.session.H_CS_STASH_DICT # type: ignore
            
        except AttributeError:
            _EXIST: bool = False
            
        else:
            _EXIST: bool = True
            
        # build a new one
        views_scheme: list[hou.viewportColorScheme]  = []
        views_keys: list[str] = []
        
        for v in flam3h_general_utils.util_getSceneViewers():
            
            # Store only if it is a Sop viewer
            if flam3h_general_utils.util_is_context('Sop', v) or flam3h_general_utils.util_is_context('Object', v):
                
                view: hou.GeometryViewport = v.curViewport()
                settings: hou.GeometryViewportSettings = view.settings()
                _CS: hou.viewportColorScheme = settings.colorScheme()
                if _CS != hou.viewportColorScheme.Dark: # type: ignore
                    views_scheme.append(_CS)
                    views_keys.append(v.name())
        
        # Always store and update this data if we collected something
        if views_scheme and views_keys:
            new: dict[str, hou.viewportColorScheme] = dict(zip(views_keys, views_scheme)) # type: ignore
            if _EXIST:
                # Check if it needs an update
                if new != hou.session.H_CS_STASH_DICT: #type: ignore
                    __old_to_update: dict[str, hou.viewportColorScheme] = hou.session.H_CS_STASH_DICT.copy() #type: ignore
                    for key, value in new.items():
                        if value != hou.viewportColorScheme.Dark: # type: ignore
                            if key not in __old_to_update.keys(): __old_to_update[key] = value
                    hou.session.H_CS_STASH_DICT: dict[str, hou.viewportColorScheme] = __old_to_update #type: ignore
            else:
                # otherwise create
                hou.session.H_CS_STASH_DICT: dict[str, hou.viewportColorScheme] = new # type: ignore
                
                
    @staticmethod
    def mp_xf_viz_solo_follow_prev_off(node: hou.SopNode) -> None:
        """When in xf viz SOLO (follow) mode,</br>
        Switching iterators using the select iterator mini-menu</br>
        will take care of turning the preview xfviz iterator number xf mp index OFF</br>
        before turning the selected one ON.</br>
        
        To be used inside:
        * def flam3h_toggle_mp_xf_viz(self) -> None:
        * def flam3h_toggle_mp_xf_viz_solo_follow(self, mp_idx: str) -> None:
        * def flam3h_toggle_xf_ff_viz(self) -> None:
        
        Args:
            node(hou.SopNode): This FLAM3H™ node
            
        Returns:
            (None):  
        """  
        # NEW method
        # Get the idx parameter of the xf_viz solo iterator from the memory
        prm_xfviz_idx_mem: hou.Parm = node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX)
        # Try to get the multi parameter instance parm with idx: xfviz_idx_mem.eval()
        xfviz_solo_prm_name: str = f"{flam3h_iterator_prm_names().main_xf_viz}_{prm_xfviz_idx_mem.eval()}"
        xfviv_solo: hou.Parm = node.parm(xfviz_solo_prm_name)
        # It it does exist and the xf_viz idx from memory was set
        if xfviv_solo is not None and prm_xfviz_idx_mem.eval() > 0:
            # Try to set the old xf_viz multi parameter instance solo toggle back to 0(Zero)
            if node.parm(xfviz_solo_prm_name).eval():
                # node.parm(xfviz_solo_prm_name).set(0)
                flam3h_prm_utils.set(node, xfviz_solo_prm_name, 0)

    
    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @property
    def kwargs(self) ->  dict[str, Any]:
        return self._kwargs
    
    @property
    def node(self) -> hou.SopNode:
        return self._node
    
    @cached_slot_property
    def bbox_sensor_path(self) -> str | None:
        return self._bbox_sensor_path
    
    @cached_slot_property
    def bbox_reframe_path(self) -> str | None:
        return self._bbox_reframe_path
    
    
    def reset_parm(self, val: tuple[int | float, ...]) -> None:
        """Reset a parameter to a value.</br>
        This is to be run from an action button script.
        
        Args:
            (self):
            val(tuple[int | float, ...]): The values to reset to.
            
        Returns:
            (None):                            
        """ 
        self.kwargs['parmtuple'].set(val)


    def menus_refresh_enum_prefs(self) -> None:
        """Refresh and force presets menus names to update</br>
        after the preference's option "enumerate presets menu" has been toggled ON or OFF</br>
        and also from inside other places, following a list:</br>
        
        * def util_set_front_viewer(self, update: bool = True) -> bool:
        * def util_viewport_bbox_frame(self) -> None:
        * def flam3h_outsensor_toggle(self, prm_name: str = f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR) -> None:
        * def flam3h_xf_viz_toggle(self, prm_name: str = PREFS_PVT_XF_VIZ) -> None:
        * def flam3h_toggle_sys_xf_viz_solo(self) -> None:
        * def flam3h_toggle_sys_xf_ff_viz_solo(self) -> None:
        * def flam3h_toggle_mp_xf_viz(self) -> None:
        * def flam3h_toggle_xf_ff_viz(self) -> None:
        * def flam3h_toggle(self, prm_name: str) -> None:
        * def flam3h_toggle_private(self, prm_name: str) -> None:
        * def flam3h_toggle_private_FF(self, prm_name: str = PREFS_PVT_DOFF) -> None:
        * def flam3h_toggle_off(self, prm_name: str) -> None:
                                                            
        Args:
            (self):
            
        Returns:
            (None):                            
        """ 
        node: hou.SopNode = self.node
        # Clear menu caches
        flam3h_iterator_utils(self.kwargs).destroy_all_menus_data(node)
        # Check and Update this data
        flam3h_iterator_utils(self.kwargs).update_xml_last_loaded(False)
        
        prm_menus: tuple[hou.Parm, ...] = ( node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS),
                                            node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS_OFF),
                                            node.parm(f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS),
                                            node.parm(f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS_OFF),
                                            node.parm(f3h_tabs.IN.PRM_PRESETS),
                                            node.parm(f3h_tabs.IN.PRM_PRESETS_OFF),
                                            node.parm(f3h_tabs.IN.PRM_SYS_PRESETS),
                                            node.parm(f3h_tabs.IN.PRM_SYS_PRESETS_OFF),
                                            node.parm(f3h_tabs.OUT.PRM_PRESETS),
                                            node.parm(f3h_tabs.OUT.PRM_SYS_PRESETS)
                                            )
        # This is probably light weight enough to be run all together
        # However in the future will be better to split this to run per type with checks (CP, IN and OUT)
        for prm in prm_menus:
            flam3h_prm_utils.set(node, prm, prm.eval())


    def get_node_path(self, node_name: str) -> str | None:
        """Find the full path of the bbox data null node inside the current FLAM3H™ node.</br>
        
        The Null node names prefixes to search are stored inside the global variables:
        * f3h_nodeNames.DEFAULT_OUT_BBOX_SENSOR
        * f3h_nodeNames.DEFAULT_OUT_BBOX_REFRAME

        Args:
            (self):
            node_name(str): The node name to search for
            
        Returns:
           ( str | None): The full path string to the bbox null data node used by the Camera sensor mode or the Re-frame mode.
        """     
        matcher = nodesearch.Name(node_name, exact=True)
        search = matcher.nodes(self.kwargs['node'], recursive=True)
        if search:
            return search[0].path()
        
        # Disabling this because it is annoying it never find it on creation, need to investigate
        # and I added it inside: def util_viewport_bbox_frame(self) -> None:
        
        # _MSG: str = f"{self.node.name()}: Camera sensor BBOX data node not found."
        # self.set_status_msg(_MSG, 'WARN')
        return None


    def util_set_clipping_viewers(self) -> None:
        """Set current viewport camera clipping near/far planes.</br>
        
        Args:
            (self):
            
        Returns:
            (None):  
        """
        for view in self.util_getSceneViewers():
            # It is handy to set the clipping planes also on LOP viewers
            # so there is no check to know if we are setting a SOP or LOP viewer
            curView: hou.GeometryViewport = view.curViewport()
            settings = curView.settings()
            settings.setHomeAutoAdjustsClip( hou.viewportHomeClipMode.Neither ) # type: ignore
            settings.setClipPlanes( (0.001, 1000) )
            settings.homeAutoAdjustClip()
            settings.clipPlanes()


    def util_store_all_viewers(self) -> None:
        """Store dictionaries of viewers cameras and their types
        
        Args:
            (self):
            
        Returns:
            (None):  
        """  
        # Do this only once; when we enter the sensor viz
        parm = self.kwargs.get('parm')
        _ENTER_PRM = None
        if parm is not None: _ENTER_PRM = parm.name()
        if _ENTER_PRM is not None and _ENTER_PRM == f3h_tabs.OUT.PRM_RENDER_PROPERTIES_SENSOR_ENTER:
            views_cam: list[hou.GeometryViewportCamera]  = []
            views_keys: list[str] = []
            views_type: list[hou.geometryViewportType] = []
            for v in self.util_getSceneViewers():
                # Store only if it is a Sop viewer
                if self.util_is_context('Sop', v) or self.util_is_context('Object', v):
                    view: hou.GeometryViewport = v.curViewport()
                    views_cam.append(view.defaultCamera().stash())
                    views_keys.append(v.name())
                    views_type.append(view.type())
                
            # Store everything into the hou.session so we can retrieve them later but keep them if they exist already
            # as it mean another FLAM3H™ node was already im camera sensor mode and we likely want to restore what was already stored.
            try:
                hou.session.F3H_SENSOR_CAM_STASH_COUNT # type: ignore
            except AttributeError:
                hou.session.F3H_SENSOR_CAM_STASH_COUNT: int = len(views_cam) # type: ignore
                
            try:
                hou.session.F3H_SENSOR_CAM_STASH_DICT # type: ignore
            except AttributeError:
                hou.session.F3H_SENSOR_CAM_STASH_DICT: dict[str, hou.GeometryViewportCamera] = dict(zip(views_keys, views_cam)) # type: ignore
                
            try:
                hou.session.F3H_SENSOR_CAM_STASH_TYPE_DICT # type: ignore
            except AttributeError:
                hou.session.F3H_SENSOR_CAM_STASH_TYPE_DICT: dict[str, hou.geometryViewportType] = dict(zip(views_keys, views_type)) # type: ignore
            

    def util_set_front_viewer(self, update: bool = True) -> bool:
        """Set front view when entering the camera sensor mode.</br>
        This include storing and restoring the current viewport prior to entering the camera sensor mode if there is only one and is: viewport.isCurrentTab().</br>
        Otherwise it will set them all if multiple viewports are present and restore them all on exit.</br>
        
        This definition is multipurpose, it is run from multiple parameters:
        * When run from the SYS prm: _SYS_FRAME_VIEW_SENSOR_prm it will also print a flash message.
        * When run from the OUT Sensor parms, it will re frame the sensor based of if update sensor prm is ON or OFF.
        * When run while loading a hip file it will test the necessary condition to see if it can work ort not.
        
        Maybe it would be better to split all those purposes into their own definition for each...but good for now.</br>
        
        Note:
            This definition is also run inside the following definitions:
            
            * def flam3h_outsensor_toggle(self, prm_name: str = f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR) -> None:
            * def iterators_count(self) -> None:
            * def util_viewport_bbox_frame(self) -> None:
            * def in_copy_render_all_stats_msg(kwargs: dict,  apo_data: in_flame_iter_data | None=None, clipboard: bool=False) -> None:
            * def in_copy_sensor_stats_msg(kwargs: dict) -> None:
            * def in_copy_render_stats_msg(kwargs: dict) -> None:
            * def menu_sensor_resolution_set(self, update=True) -> None:
            * def reset_OUT_kwargs(self) -> None:
            * def reset_OUT(self, mode=0) -> None:
            * def flam3h_on_loaded(self) -> None:

        Args:
            (self):
            update(bool): Default to: True</br>Updated the viewport camera sensor or not(False)
            
        Returns:
            (bool): True if the Sensor Viz is being activated. False if not.
        """     
        node: hou.SopNode = self.node
        if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
            
            desktop: hou.Desktop = hou.ui.curDesktop() # type: ignore
            viewport: hou.SceneViewer = desktop.paneTabOfType(hou.paneTabType.SceneViewer) # type: ignore
            
            # check if there are more than one viewport available
            viewports: list[hou.SceneViewer] = self.util_getSceneViewers()
            
            # Get some data for down the line condition checks
            update_sensor: int = self.node.parm(f3h_tabs.OUT.PRM_UPDATE_SENSOR).eval()
            _SYS_FRAME_VIEW_SENSOR_prm = False

            prm: hou.Parm | None = self.kwargs.get('parm')
            if prm is not None and prm.name() == f3h_tabs.SYS.PRM_FRAME_VIEW_SENSOR:
                _SYS_FRAME_VIEW_SENSOR_prm =True
                # Refresh menu caches
                self.menus_refresh_enum_prefs()

            # If the viewport is: viewport.isCurrentTab()
            if viewport is not None and len(viewports) == 1 and viewport.isCurrentTab():
                
                # Set only if it is a Sop viewer
                if self.util_is_context('Sop', viewport) or self.util_is_context('Object', viewport):
                    
                    view: hou.GeometryViewport = viewport.curViewport()
                    
                    # Do this only once; when we enter the sensor viz
                    parm: hou.Parm | None = self.kwargs.get('parm')
                    _ENTER_PRM = None
                    if parm is not None: _ENTER_PRM = parm.name()
                    if _ENTER_PRM is not None and _ENTER_PRM == f3h_tabs.OUT.PRM_RENDER_PROPERTIES_SENSOR_ENTER:
                        try: _CAM_STASHED: hou.GeometryViewportCamera | None = hou.session.F3H_SENSOR_CAM_STASH # type: ignore
                        except AttributeError: _CAM_STASHED: hou.GeometryViewportCamera | None = None
                            
                        if _CAM_STASHED is None:
                            cam = view.defaultCamera()
                            hou.session.F3H_SENSOR_CAM_STASH: hou.GeometryViewportCamera = cam.stash() # type: ignore
                            hou.session.F3H_SENSOR_CAM_STASH_TYPE: hou.geometryViewportType = view.type() # type: ignore
                    
                    if view.type() != hou.geometryViewportType.Front: # type: ignore
                        view.changeType(hou.geometryViewportType.Front) # type: ignore
                        
                    if update:
                        if self.bbox_sensor_path is not None:
                            node_bbox: hou.SopNode = hou.node(self.bbox_sensor_path)
                            if hou.hipFile.isLoadingHipFile(): # type: ignore
                                # This fail on "isLoadingHipFile" under H19.x, H19.5.x and H20.0.506
                                # but work on H20.0.590 and up, hence the try/except block
                                try:
                                    view.frameBoundingBox(node_bbox.geometry().boundingBox())
                                    
                                except AttributeError as e:
                                    F3H_Exception.F3H_traceback_print_infos(e)
                                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)
                                    self.util_clear_stashed_cam_data()
                                    return False
                            else:
                                view.frameBoundingBox(node_bbox.geometry().boundingBox())

                            if _SYS_FRAME_VIEW_SENSOR_prm:
                                self.flash_message(node, f"sensor REFRAMED")
                                
                            return True

                    else:
                        # update_sensor = self.node.parm(OUT_UPDATE_SENSOR).eval()
                        if update_sensor or _SYS_FRAME_VIEW_SENSOR_prm:
                            if self.bbox_sensor_path is not None:
                                node_bbox: hou.SopNode = hou.node(self.bbox_sensor_path)
                                if hou.hipFile.isLoadingHipFile(): # type: ignore
                                    # This fail on "isLoadingHipFile" under H19.x, H19.5.x and H20.0.506
                                    # but work on H20.0.590 and up, hence the try/except block
                                    try:
                                        view.frameBoundingBox(node_bbox.geometry().boundingBox())
                                        
                                    except AttributeError as e:
                                        F3H_Exception.F3H_traceback_print_infos(e)
                                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)
                                        self.util_clear_stashed_cam_data()
                                        return False
                                    
                                else:
                                    view.frameBoundingBox(node_bbox.geometry().boundingBox())
                                    
                                    if _SYS_FRAME_VIEW_SENSOR_prm:
                                        self.flash_message(node, f"sensor REFRAMED")
                                        
                                return True
                            
                    return False
                
                else:
                    # If we were activating the Camera Sensor mode
                    if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
                        # Revert it back to OFF and fire a message
                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)
                        _MSG: str = f"No Sop viewers available."
                        self.set_status_msg(f"{node.name()}: {_MSG} You need at least one Sop viewer for the Camera Sensor to work.", 'WARN')
                        self.flash_message(node, f"{_MSG}")
                        
                    return False
                  
            else:  
                self.util_store_all_viewers()
                # Try to set all viewports
                if self.util_set_front_viewer_all(  node, 
                                                    viewports, 
                                                    update_sensor, 
                                                    _SYS_FRAME_VIEW_SENSOR_prm, update ):
                    return True
                
                # Or just exit the Sensor Viz mode
                self.flam3h_other_sensor_viz_off(self.node)
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)
                self.util_clear_stashed_cam_data()
                return False
                
        return False


    def util_set_front_viewer_all(self, 
                                  node: hou.SopNode, 
                                  viewports: list[hou.SceneViewer], 
                                  update_sensor: int, 
                                  _SYS_FRAME_VIEW_SENSOR_prm: int, 
                                  update: bool = True
                                  ) -> bool:
        """This is a fallback if the: util_set_front_viewer(...) can not run succesfully.</br>
        It will activate the Sensor Viz in all available viewports with the ability of storing and restoring a stashed camera for each.</br>
        
        Note:</br>
        This expect the following condition to be True (Must run inside this if statement):
        * if node.parm(OUT_PVT_RENDER_PROPERTIES_SENSOR).eval():</br>
        

        Args:
            (self):
            node(hou.SopNode): FLAM3H™ node
            viewports(list[hou.SceneViewer): A list of hou.ScenViewer
            update_sensor(int): Is the force sensor update toggle ON or OFF ?
            _SYS_FRAME_VIEW_SENSOR_prm(bool): Is this being run from the SYS tab reframe viewport icon ?
            update(bool): Default to: True</br>Updated the viewport camera sensor or not(False)
            
        Returns:
            (bool): True if the Sensor Viz is being activated. False if not.
        """ 
            
        if len(viewports):
            
            lop_viewports: list[bool] = []
            allowed_viewers: bool = False
            # Set them all without storing any stashed camera data 
            self.util_set_clipping_viewers()
            for v in viewports:
                
                # Set only if it is a Sop viewer
                if self.util_is_context('Sop', v) or self.util_is_context('Object', v):
                    
                    if allowed_viewers is False: allowed_viewers = True
                    
                    view: hou.GeometryViewport = v.curViewport()
                    if view.type() != hou.geometryViewportType.Front: # type: ignore
                        view.changeType(hou.geometryViewportType.Front) # type: ignore
                    if update:
                        if self.bbox_sensor_path is not None:
                            node_bbox: hou.SopNode = hou.node(self.bbox_sensor_path)
                            if hou.hipFile.isLoadingHipFile(): # type: ignore
                                # This fail on "isLoadingHipFile" under H19.x, H19.5.x and H20.0.506
                                # but work on H20.0.590 and up, hence the try/except block
                                try:
                                    view.frameBoundingBox(node_bbox.geometry().boundingBox())
                                    
                                except AttributeError as e:
                                    F3H_Exception.F3H_traceback_print_infos(e)
                                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)
                                    self.util_clear_stashed_cam_data()
                                    return False
                                
                            else:
                                view.frameBoundingBox(node_bbox.geometry().boundingBox())
                                
                    else:
                        if update_sensor or _SYS_FRAME_VIEW_SENSOR_prm:
                            if self.bbox_sensor_path is not None:
                                node_bbox: hou.SopNode = hou.node(self.bbox_sensor_path)
                                if hou.hipFile.isLoadingHipFile(): # type: ignore
                                    # This fail on "isLoadingHipFile" under H19.x, H19.5.x and H20.0.506
                                    # but work on H20.0.590 and up, hence the try/except block
                                    try:
                                        view.frameBoundingBox(node_bbox.geometry().boundingBox())
                                        
                                    except AttributeError as e:
                                        F3H_Exception.F3H_traceback_print_infos(e)
                                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)
                                        self.util_clear_stashed_cam_data()
                                        return False
                                else:
                                    view.frameBoundingBox(node_bbox.geometry().boundingBox())
                                        
                else:
                    # Count how many Lop viewports are present
                    lop_viewports.append(True)
                    
            if allowed_viewers and _SYS_FRAME_VIEW_SENSOR_prm:
                self.flash_message(self.node, f"sensor REFRAMED")
                    
            # If all the viewports are Lop viewports
            if len(lop_viewports) == len(viewports):
                
                # If we were activating the Camera Sensor mode
                if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
                    # Revert it back to OFF and fire a message
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)
                    _MSG: str = f"No Sop viewers available."
                    self.set_status_msg(f"{node.name()}: {_MSG} You need at least one Sop viewer for the Sensor Viz to work.", 'WARN')
                    self.flash_message(node, f"{_MSG}")
                    
                return False
            
            return True
        
        else:
            # Exit the Sensor Viz mode
            self.flam3h_other_sensor_viz_off(self.node)
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)
            self.util_clear_stashed_cam_data()
            
            _MSG: str = f"No Sop viewers available."
            self.set_status_msg(f"{node.name()}: {_MSG} You need at least one Sop viewer for the Sensor Viz to work.", 'WARN')
            self.flash_message(node, f"{_MSG}")
            return False
            
    
    def util_store_all_viewers_xf_viz(self) -> None:
        """Store dictionaries of viewers cameras and their wire width value.</br>
        
        Args:
            (self):
            
        Returns:
            (None):  
        """  
        # Do this only once; when we activate the xforms handles VIZ
        parm = self.kwargs.get('parm')
        _ENTER_PRM = None
        if parm is not None: _ENTER_PRM = parm.name()
        if _ENTER_PRM is not None and _ENTER_PRM == f3h_tabs.SYS.PRM_XF_VIZ_OFF:
            views_widths: list[float]  = []
            views_keys: list[str] = []
            for v in self.util_getSceneViewers():
                # Store only if it is a Sop viewer
                if self.util_is_context('Sop', v) or self.util_is_context('Object', v):
                    
                    view: hou.GeometryViewport = v.curViewport()
                    settings: hou.GeometryViewportSettings = view.settings()
                    views_widths.append(settings.wireWidth())
                    views_keys.append(v.name())
            
            # Store everything into the hou.session so we can retrieve them later but keep them if they exist already
            # as it mean another FLAM3H™ node had already its viewport xforms handles VIZ ON and we likely want to restore what was already stored.
            try:
                hou.session.H_XF_VIZ_WIRE_WIDTH_STASH_DICT # type: ignore
            except AttributeError:
                hou.session.H_XF_VIZ_WIRE_WIDTH_STASH_DICT: dict[str, float] = dict(zip(views_keys, views_widths)) # type: ignore
            
    
    def util_other_xf_viz(self) -> bool:
        """Check if there are other FLAM3H™ nodes with the xforms handles VIZ ON.</br>
        
        Args:
            (self):
            
        Returns:
            (bool): True if there are other FLAM3H™ nodes with the xforms handles VIZ ON or False
        """ 
        node: hou.SopNode = self.node
        if [1 for f3h in node.type().instances() if f3h != node and f3h.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ).eval()]:
            return True
        
        return False


    def util_viewport_bbox_frame(self) -> None:
        """Re-frame the current viewport based on camera sensor node's bounding box.</br>
        
        Args:
            (self):
            
        Returns:
            (None):  
        """  
        node: hou.SopNode = self.node
        
        # Refresh menu caches
        self.menus_refresh_enum_prefs()
        
        if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval() and not node.parm(f3h_tabs.OUT.PRM_UPDATE_SENSOR).eval():
            # This condition probably will never evaluate to True as when in Sensor Viz mode
            # a new reframe icon will be displayed with the proper definition, but its good to make this icon multipurpose anyway.
            self.util_set_clipping_viewers()
            self.util_set_front_viewer()
        
        else:
            viewports: list[hou.SceneViewer] = self.util_getSceneViewers()
            num_viewers: int = len(viewports)
            if num_viewers:
                self.util_set_clipping_viewers()
                for v in viewports:
                    
                    view: hou.GeometryViewport = v.curViewport()
                    if self.bbox_reframe_path is not None:
                        node_bbox: hou.SopNode = hou.node(self.bbox_reframe_path)
                        view.frameBoundingBox(node_bbox.geometry().boundingBox())
                    else:
                        # If you can not find the BBOX data node, let us know
                        # The following used to be run from inside: def get_node_path(self, node_name: str) -> str | None:
                        _MSG: str = f"{node.name()}: Camera sensor BBOX data node not found."
                        self.set_status_msg(_MSG, 'WARN')
                        
                if num_viewers == 1:
                    _MSG: str = f"viewport REFRAMED"
                    self.flash_message(node, _MSG)
                    self.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                    
                else:
                    _MSG: str = f"viewports REFRAMED"
                    self.flash_message(node, _MSG)
                    self.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                    
            else:
                _MSG: str = f"No viewports in the current Houdini Desktop."
                self.set_status_msg(f"{node.name()}: {_MSG} You need at least one viewport for the reframe to work.", 'IMP')
                self.flash_message(node, f"Sensor Viz: {_MSG}")


    def flam3h_other_sensor_viz_off(self, node: hou.SopNode) -> None:
        """When activating the Camera sensor viz, check if there is another FLAM3H™ in camera sensor mode</br>
        and turn it Off if so. this way we guarantee there can be only one FLAM3H™ node in Camera sensor viz mode at any given time.</br>

        Args:
            (self):
            node(hou.SopNode): This FLAM3H™ node

        Returns:
            (None):
        """
        all_f3h: tuple[hou.SopNode, ...] = node.type().instances()
        if len(all_f3h) > 1:
            for f3h in all_f3h:
                if f3h != node:
                    if f3h.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
                        flam3h_prm_utils.private_prm_set(f3h, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)
                        # If another FLAM3H™ node is in Camera Sensor mode, clear up its data.
                        # after restoring the viewport prior to entering the Camera sensor mode
                        self.util_set_stashed_cam()
                        self.util_clear_stashed_cam_data()
                        break


    def flam3h_outsensor_toggle(self, prm_name: str = f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR) -> None:
        """If a toggle is OFF it will switch ON, and viceversa.</br>

        Args:
            (self):
            prm_name(str): Default to: OUT_PVT_RENDER_PROPERTIES_SENSOR</br>Toggle parameter name to use.
            
        Returns:
            (None):
        """
        
        node: hou.SopNode = self.node
        prm = node.parm(prm_name)
        
        # Refresh menu caches
        self.menus_refresh_enum_prefs()
        
        if prm.eval():
            
            flam3h_prm_utils.private_prm_set(node, prm, 0)
            
            # Restore the viewport prior to entering the Camera sensor mode
            self.util_set_stashed_cam()
            self.util_clear_stashed_cam_data()

            _MSG: str = f"Sensor viz: OFF"
            self.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
            self.flash_message(node, _MSG)
            
        else:
            
            # When in Lop context and only one viewers is present in the current Desktop and an active Karma render viewer,
            # This will prevent Karma to restart if we are trying to activate the camera sensor viz.
            # However, if we have a mix of SOP and LOP viewers, we still need to go and check them one by one inside: self.util_set_front_viewer()
            # and if an active Karma viewer is present it will be re-started during the process as of now.
            if self.util_is_context_available_viewer('Sop') or self.util_is_context_available_viewer('Object'):
                
                flam3h_prm_utils.private_prm_set(node, prm, 1)
                
                # If the current FLAM3H™ node is displayed ( its displayFlag is On )
                if node.isGenericFlagSet(hou.nodeFlag.Display): # type: ignore
                    # Check if any other FLAM3H™ node is in Camera Sensor viz mode
                    self.flam3h_other_sensor_viz_off(node)
                    # Set this FLAM3H™ node to enter the camera sensor viz mode
                    self.util_set_clipping_viewers()
                    if self.util_set_front_viewer():
                        _MSG: str = f"Sensor viz: ON"
                        self.set_status_msg(f"{node.name()}: {_MSG}", 'IMP')
                        self.flash_message(node, _MSG)
                        
                else:
                    # IF displayFlag is OFF, turn the outsensor toggle OFF, too.
                    flam3h_prm_utils.private_prm_set(node, prm, 0)
                    _MSG: str = f"This node display flag is OFF. Please use a FLAM3H™ node that is currently displayed to enter the Camera sensor viz."
                    self.set_status_msg(f"{node.name()}: {str(prm.name()).upper()} -> {_MSG}", 'WARN')
                    self.flash_message(node, f"{_MSG[:30]}")
            
            else:
                
                # Fire messages
                _MSG: str = f"No Sop viewers available."
                self.set_status_msg(f"{node.name()}: {_MSG} You need at least one Sop viewer for the Camera Sensor to work.", 'WARN')
                self.flash_message(node, f"{_MSG}")


    def flam3h_xf_viz_toggle(self, prm_name: str = f3h_tabs.PREFS.PVT_PRM_XF_VIZ) -> None:
        """If a toggle is OFF it will switch ON, and viceversa.</br>

        Args:
            (self):
            prm(str): Default to: PREFS_PVT_XF_VIZ</br>Toggle parameter name to use.

        Returns:
            (None):  
        """
        node: hou.SopNode = self.node
        prm = node.parm(prm_name)
        f3h_xf_viz_others: bool = self.util_other_xf_viz()
        
        # Refresh menu caches
        self.menus_refresh_enum_prefs()
        
        if prm.eval():
            
            # There must be at least one viewport
            if self.util_is_context_available_viewer('Sop') or self.util_is_context_available_viewer('Object'):
                
                flam3h_prm_utils.private_prm_set(node, prm, 0)
                
                if f3h_xf_viz_others is False:
                    # Restore the viewport wire width prior to entering the xforms handles VIZ
                    # only if there not other FLAM3H™ node in xforms handles VIZ mode.
                    self.util_xf_viz_set_stashed_wire_width()
                    self.util_clear_xf_viz_stashed_wire_width_data()
                    
                _MSG: str = f"OFF"
                self.set_status_msg(f"{node.name()}: {str(prm.name()).upper()}: {_MSG}", 'MSG')
                self.flash_message(node, f"XF VIZ: {_MSG}")
                
            else:
                flam3h_prm_utils.private_prm_set(node, prm, 1)
                _MSG: str = f"No Sop viewers available."
                self.set_status_msg(f"{node.name()}: {_MSG} You need at least one Sop viewer for the xforms handles VIZ to work.", 'WARN')
                self.flash_message(node, f"{_MSG}")
            
        else:
            
            # There must be at least one viewport
            if self.util_is_context_available_viewer('Sop') or self.util_is_context_available_viewer('Object'):
            
                if f3h_xf_viz_others is False:
                    self.util_store_all_viewers_xf_viz()
                    
                # Retrieve the value we shoud be set to
                try:
                    w: float | None = hou.session.H_VIEWPORT_WIRE_WIDTH # type: ignore
                except AttributeError:
                    w: float | None = None
                    
                if w is not None: self.viewportWireWidth(w)
                
                flam3h_prm_utils.private_prm_set(node, prm, 1)
                
                _MSG: str = f"ON"
                self.set_status_msg(f"{node.name()}: {str(prm.name()).upper()}: {_MSG}", 'IMP')
                self.flash_message(node, f"XF VIZ: {_MSG}")
                
            else:
                flam3h_prm_utils.private_prm_set(node, prm, 0)
                _MSG: str = f"No Sop viewers available."
                self.set_status_msg(f"{node.name()}: {_MSG} You need at least one Sop viewer for the xforms handles VIZ to work.", 'WARN')
                self.flash_message(node, f"{_MSG}")
                
    
    def flam3h_all_mp_xf_viz_check(self) -> bool:
        """ NOT USED YET</br>
        Check if any multiparameter have its xf_viz ON.</br>

        Args:
            (self):

        Returns:
            (None):  
        """ 
        node: hou.SopNode = self.node
        iter_num: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        _main_xf_viz_name: str = flam3h_iterator_prm_names().main_xf_viz
        all_mp_xf_viz: list[int] = [node.parm(f"{_main_xf_viz_name}_{mp_idx}").eval() for mp_idx in range(1, iter_num + 1)]
        
        return 1 in all_mp_xf_viz
        
        
    def flam3h_toggle_sys_xf_viz_solo(self) -> None:
        """When in xform VIZ SOLO mode, this will turn it off and go back to viz them all.</br>
        Specifically built for the SYS -> "xfviz_on_solo" icon parameter.</br>

        Args:
            (self):

        Returns:
            (None):  
        """
        node: hou.SopNode = self.node
        prm_xfviz_solo: hou.Parm = node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO)
        
        # Refresh menu caches
        self.menus_refresh_enum_prefs()
        
        if prm_xfviz_solo.eval():
            
            # NEW method
            self.mp_xf_viz_solo_follow_prev_off(node)
            
            flam3h_prm_utils.private_prm_set(node, prm_xfviz_solo, 0) # Turn Off iterator xf viz solo mode
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX, 0) # Reset mp index to Off value: 0(Zero)
            flam3h_iterator_utils.destroy_userData(node, f"{f3h_userData.PRX}_{f3h_userData.XFVIZ_SOLO}")
            
            _MSG: str = f"{node.name()}: {str(prm_xfviz_solo.name()).upper()}: OFF"
            self.set_status_msg(_MSG, 'MSG')
            self.flash_message(node, f"XF VIZ: ALL")
            
        else:
            
            _MSG: str = f"{node.name()}: {str(prm_xfviz_solo.name()).upper()}: ON"
            self.set_status_msg(_MSG, 'IMP')
            
            
    def flam3h_toggle_sys_xf_ff_viz_solo(self) -> None:
        """When in xform VIZ SOLO mode, this will turn it off and go back to viz them all.</br>
        Specifically built for the SYS -> "xfvizff_on_solo" icon parameter.</br>

        Args:
            (self):

        Returns:
            (None):  
        """
        node: hou.SopNode = self.node
        prm_FF = node.parm(f3h_tabs.PREFS.PVT_PRM_XF_FF_VIZ_SOLO)
        
        # Refresh menu caches
        self.menus_refresh_enum_prefs()
        
        if prm_FF.eval():
            flam3h_prm_utils.private_prm_set(node, prm_FF, 0) # Turn Off FF xf viz solo mode
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX, 0) # Reset mp index to Off value: 0(Zero)
            flam3h_iterator_utils.destroy_userData(node, f"{f3h_userData.PRX}_{f3h_userData.XFVIZ_SOLO}")
            
            _MSG: str = f"{node.name()}: {str(prm_FF.name()).upper()}: OFF"
            self.set_status_msg(_MSG, 'MSG')
            self.flash_message(node, f"XF VIZ: ALL")
            
        else:
            
            _MSG: str = f"{node.name()}: {str(prm_FF.name()).upper()}: ON"
            self.set_status_msg(_MSG, 'IMP')
                
                
    def flam3h_toggle_mp_xf_viz(self) -> None:
        """If a toggle is OFF it will switch ON, and viceversa.</br>
        Specifically built for the XF VIZ multiparameter icons.</br>

        Args:
            (self):

        Returns:
            (None):  
        """    
        
        # with hou.undos.disabler(): # type: ignore
        
        node: hou.SopNode = self.node
        
        s_mp_index: int = self.kwargs['script_multiparm_index']
        prm_mp = node.parm(f"{flam3h_iterator_prm_names().main_xf_viz}_{s_mp_index}")
        
        data_name: str = f"{f3h_userData.PRX}_{f3h_userData.XFVIZ_SOLO}"
        
        # Refresh menu caches
        self.menus_refresh_enum_prefs()
        
        if prm_mp.eval():
            
            flam3h_prm_utils.set(node, prm_mp, 0)
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO, 0) # Turn Off iterator xf viz solo mode
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX, 0) # Reset mp index to Off value: 0(Zero)
            flam3h_iterator_utils.destroy_userData(node, f"{data_name}")
            
            _MSG: str = f"{node.name()}: VIZHANDLES_SOLO: OFF"
            self.set_status_msg(_MSG, 'MSG')
            self.flash_message(node, f"XF VIZ: ALL")
            
        else:
            # NEW method
            self.mp_xf_viz_solo_follow_prev_off(node)
               
            # OLD method 
            # Set all xv_viz multi parameter instance solo toggles back to 0(Zero)
            # This was the old method. It was ~N times slower where N is the number of the iterators.
            # for mp_id in range(iter_num): node.parm(f"{flam3h_iterator_prm_names().main_xf_viz}_{mp_id + 1}").set(0) # type: ignore
            
            flam3h_prm_utils.set(node, prm_mp, 1)
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO, 1)
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX, s_mp_index)
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_FF_VIZ_SOLO, 0)
            node.setUserData(f"{data_name}", str(s_mp_index))
                
            _MSG: str = f"{node.name()}: {str(prm_mp.name()).upper()}: ON"
            self.set_status_msg(_MSG, 'IMP')
            self.flash_message(node, f"XF VIZ: {s_mp_index}")
            
            
    def flam3h_toggle_mp_xf_viz_solo_follow(self, mp_idx: str) -> None:
        """When one of the iterators in in SOLO mode,</br>
        changing the iterators focus using the select iterator mini menu</br>
        will change also the SOLO focus as well, keeping any selected iterator in SOLO modo while switching.</br>
        
        This is used inside:
        - def prm_select_iterator(self) -> None:

        Args:
            (self):
            mp_idx(int): The multiparameter index of the selected iterator  

        Returns:
            (None):  
        """    
        node: hou.SopNode = self.node
        
        xfviz_solo: int = node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO).eval()
        xfviz_solo_mp_idx: int = node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX).eval() # this need to one higher than 0(Zero)
        xfviz_solo_follow: int = node.parm(f3h_tabs.PREFS.PRM_SOLO_FOLLOW).eval()
        xfviz_out_sensor: int = node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval()
        
        # If any of the iterators is in SOLO mode and we are not in camera sensor mode
        if xfviz_solo and xfviz_solo_mp_idx and xfviz_solo_follow and not xfviz_out_sensor:
            
            _main_xf_viz_name: str = flam3h_iterator_prm_names().main_xf_viz
            prm_mp = node.parm(f"{_main_xf_viz_name}_{mp_idx}")
            
            if not prm_mp.eval():
                
                # NEW method
                self.mp_xf_viz_solo_follow_prev_off(node)
                
                # Turn the new one On
                flam3h_prm_utils.set(node, prm_mp, 1)
                
                # Update data accordingly
                data_name: str = f"{f3h_userData.PRX}_{f3h_userData.XFVIZ_SOLO}"
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX, int(mp_idx))
                node.setUserData(f"{data_name}", mp_idx)
                # message
                _MSG: str = f"{node.name()}: {str(prm_mp.name()).upper()}: ON"
                self.set_status_msg(_MSG, 'IMP')
            
            
    def flam3h_toggle_xf_ff_viz(self) -> None:
        """If a toggle is OFF it will switch ON, and viceversa.</br>
        Specifically built for the XF FF VIZ icons.</br>
        
        Args:
            (self):

        Returns:
            (None):  
        """    
        
        # with hou.undos.disabler(): # type: ignore
        
        node: hou.SopNode = self.node
        
        # s_mp_index: int = self.kwargs['script_multiparm_index']
        prm_mp = node.parm(f3h_tabs.PREFS.PVT_PRM_XF_FF_VIZ_SOLO)
        data_name: str = f"{f3h_userData.PRX}_{f3h_userData.XFVIZ_SOLO}"
        
        # Refresh menu caches
        self.menus_refresh_enum_prefs()
        
        if prm_mp.eval():
            flam3h_prm_utils.private_prm_set(node, prm_mp, 0)
            flam3h_iterator_utils.destroy_userData(node, f"{data_name}")
            
            _MSG: str = f"{node.name()}: VIZHANDLESFF_SOLO: OFF"
            self.set_status_msg(_MSG, 'MSG')
            self.flash_message(node, f"XF VIZ: ALL")
            
        else:
            
            # NEW method
            self.mp_xf_viz_solo_follow_prev_off(node)
            
            flam3h_prm_utils.private_prm_set(node, prm_mp, 1)
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO, 0) # Turn Off iterator xf viz solo mode
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX, 0) # Reset mp index to Off value: 0(Zero)
            node.setUserData(f"{data_name}", "FF")
                
            _MSG: str = f"{node.name()}: {str(prm_mp.name()).upper()}: ON"
            self.set_status_msg(_MSG, 'IMP')
            self.flash_message(node, f"XF VIZ: FF")
                
            
    def flam3h_toggle(self, prm_name: str) -> None:
        """If a toggle is OFF it will switch ON, and viceversa.</br>

        Args:
            (self):
            prm_name(str): Toggle parameter name to use.

        Returns:
            (None):  
        """
        node: hou.SopNode = self.node
        prm = node.parm(prm_name)
        
        # Refresh menu caches
        self.menus_refresh_enum_prefs()
        
        if prm.eval():
            flam3h_prm_utils.set(node, prm, 0)
            _MSG: str = f"{node.name()}: {str(prm.name()).upper()}: OFF"
            self.set_status_msg(_MSG, 'MSG')
            
        else:
            flam3h_prm_utils.set(node, prm, 1)
            _MSG: str = f"{node.name()}: {str(prm.name()).upper()}: ON"
            self.set_status_msg(_MSG, 'IMP')
            
            
    def flam3h_toggle_private(self, prm_name: str) -> None:
        """If a toggle is OFF it will switch ON, and viceversa,</br>
        and make sure to unlock and lock the parameter.</br>

        Args:
            (self):
            prm_name(str): Toggle parameter name to use.

        Returns:
            (None):  
        """
        node: hou.SopNode = self.node
        prm = node.parm(prm_name)
        
        # Refresh menu caches
        self.menus_refresh_enum_prefs()
        
        if prm.eval():
            flam3h_prm_utils.private_prm_set(node, prm, 0)
            _MSG: str = f"{node.name()}: {str(prm.name()).upper()}: OFF"
            self.set_status_msg(_MSG, 'MSG')
            
        else:
            # This is a one off only for the TAG
            if prm_name == f3h_tabs.PREFS.PVT_PRM_TAG:
                
                if self.util_is_context_available_viewer('Sop') or self.util_is_context_available_viewer('Object'):
                    
                    flam3h_prm_utils.private_prm_set(node, prm, 1)
                    _MSG: str = f"{node.name()}: {str(prm.name()).upper()}: ON"
                    self.set_status_msg(_MSG, 'IMP')
                
                else:
                    
                    flam3h_prm_utils.private_prm_set(node, prm, 0)
                    _MSG: str = f"No Sop viewers available."
                    self.set_status_msg(f"{node.name()}: {_MSG} You need at least one Sop viewer for the Tag to work.", 'WARN')
                    self.flash_message(node, f"{_MSG}")
                
            else:
                flam3h_prm_utils.private_prm_set(node, prm, 1)
                _MSG: str = f"{node.name()}: {str(prm.name()).upper()}: ON"
                self.set_status_msg(_MSG, 'IMP')


    def flam3h_toggle_private_FF(self, prm_name: str = f3h_tabs.PREFS.PVT_PRM_DOFF) -> None:
        """If a toggle is OFF it will switch ON, and viceversa,</br>
        and make sure to unlock and lock the parameter.</br>
        Specifically built for the FF toggles ON/OFF</br>

        Args:
            (self):
            prm_name(str): Default to: PREFS_PVT_DOFF</br>Toggle parameter name to use.

        Returns:
            (None):  
        """
        node: hou.SopNode = self.node
        prm = node.parm(prm_name)
        
        # Refresh menu caches
        self.menus_refresh_enum_prefs()
        
        if prm.eval():
            flam3h_prm_utils.private_prm_set(node, prm, 0)
            
            if node.parm(f3h_tabs.PREFS.PVT_PRM_XF_FF_VIZ_SOLO).eval():
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_FF_VIZ_SOLO, 0)
                data_name: str = f"{f3h_userData.PRX}_{f3h_userData.XFVIZ_SOLO}"
                flam3h_iterator_utils.destroy_userData(node, f"{data_name}")
                
            _MSG: str = f"{node.name()}: {str(prm.name()).upper()}: OFF"
            self.set_status_msg(_MSG, 'MSG')
            
        else:
            flam3h_prm_utils.private_prm_set(node, prm, 1)
            _MSG: str = f"{node.name()}: {str(prm.name()).upper()}: ON"
            self.set_status_msg(_MSG, 'IMP')
            

    def flam3h_toggle_off(self, prm_name: str) -> None:
        """If a toggle is ON it will switch it OFF.

        Args:
            (self):
            prm_name(str): Toggle parameter name to use

        Returns:
            (None):  
        """      
        prm = self.node.parm(prm_name)  
        
        # Refresh menu caches
        self.menus_refresh_enum_prefs()
        
        if prm.eval():
            # If the passed toggle's name argument is the camera sensor: 'outsensor'
            # restore the viewport prior to entering the Camera sensor mode and clearup all related data
            if prm_name == f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR:
                flam3h_prm_utils.private_prm_set(self.node, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)
                self.util_set_stashed_cam()
                self.util_clear_stashed_cam_data()
            else:
                flam3h_prm_utils.set(self.node, prm, 0)
                
                
    def flam3h_init_presets_CP_PRESETS(self, mode: int = 1, destroy_menus: bool = True, json_file: bool | None = None, f3h_json_file: bool | None = None, json_path_checked: str | bool | None = None) -> None:
        """Initialize parameter's menu presets for the CP tab.</br>
        
        Here I could use userData instead of a cachedUserData but can happen that between one houdini session</br>
        and the next one the user may make some modification to the stored file, like moving it into another location or deleting it</br>
        so this way we make sure to always be up to date.</br>
        
        Note:</br>
            This definition differ from the IN and OUT file init presets definitions,</br>
            because it deal with the Loading and Saving data initializations in one place.
        
        Args:
            (self):
            mode(int): Default to: 1</br>This is to be used to prevent to load a left over preset when loading back a hip file.
            destroy(bool): Default to: True</br>Destroy menu presets cached data. True or False.
            json_file(bool | None): Default to: None</br>Is it a json file ?
            f3h_json_file(bool | None): Default to: None</br>Is it a F3H palette json file ?
            json_path_checked(str | bool | None): Default to: None</br>Check if the provided path is a valid one, it will autocorrect it if needed.
            
        Returns:
            (None):
        """    
        node: hou.SopNode = self.node
        # Clear menu cache
        if destroy_menus:
            flam3h_iterator_utils(self.kwargs).destroy_all_menus_data(node)
            # Check and Update this data
            flam3h_iterator_utils(self.kwargs).update_xml_last_loaded(False)
        
        # Retrieve the filepath from the history (preview valid F3H json file path used)
        cp_presets_filepath_history: str | None = node.cachedUserData(f3h_cachedUserData.cp_presets_filepath)
        
        prm = node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS)
        prm_off = node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS_OFF)
        prm_sys = node.parm(f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS)
        prm_sys_off = node.parm(f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS_OFF)
        for p in (prm, prm_off, prm_sys, prm_sys_off):
            p.lock(False)
            p.deleteAllKeyframes()

        json_path: str | bool = False
        if json_path_checked is None:
            json_path = os.path.expandvars(node.parm(f3h_tabs.CP.PRM_PATH).eval())
            json_path_checked = out_flame_utils.out_check_outpath(node,  json_path, f3h_tabs.CP.DEFAULT_FILE_EXT, f3h_tabs.CP.DEFAULT_AUTO_NAME)
        
        if cp_presets_filepath_history is not None and node.parm(f3h_tabs.CP.PVT_PRM_ISVALID_FILE).eval() and os.path.isfile(cp_presets_filepath_history) and cp_presets_filepath_history == json_path_checked:
            pass
        else:
            prm.set('-1')
            prm_off.set('-1')

        if json_path_checked is not False:
            assert isinstance(json_path_checked, str)
            
            # Set the CP filepath parameter to this checked and corrected filepath
            flam3h_prm_utils.set(node, f3h_tabs.CP.PRM_PATH, json_path_checked)
            
            # Here we are checking the file path in the file path parameter field if asked to do so(args: "json_file" and "f3h_json_file" are None)
            if json_file is None and f3h_json_file is None: json_file, f3h_json_file = flam3h_palette_utils.isJSON_F3H(node, json_path)
            if json_file and f3h_json_file:
                
                # CP is valid file
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_FILE, 1)
                # We store the file path only when we know it is a valid F3H json file path
                node.setCachedUserData(f3h_cachedUserData.cp_presets_filepath, json_path_checked)
                
                # Only set when NOT on an: onLoaded python script
                if mode:
                    prm.set('0')
                    prm_off.set('0')
                    # Mark this as not a loaded preset
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
                    # check if the selected FLAM3H™ palette file is locked
                    if self.isLOCK(json_path_checked):
                        flam3h_palette_utils.json_to_flam3h_palette_plus_preset_MSG(node, f3h_tabs.CP.DEFAULT_MSG_PALETTE_LOCK)
                        # Lets print to the status bar as well
                        _MSG: str = f"CP: {f3h_tabs.CP.DEFAULT_MSG_PALETTE_LOCK}"
                        flam3h_general_utils.set_status_msg(f"{node.name()}.{_MSG} -> {json_path_checked}", 'WARN')
                    else:
                        flam3h_palette_utils.json_to_flam3h_palette_plus_preset_MSG(node, "")
                
            else:
                # Here we are checking the corrected file path
                json_file, f3h_json_file = flam3h_palette_utils.isJSON_F3H(node, json_path_checked)
                if json_file and f3h_json_file:
                    
                    # Only set when NOT on an: onLoaded python script
                    if mode and json_path_checked != cp_presets_filepath_history:
                        
                        # CP is valid file
                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_FILE, 1)
                        # We store the file path only when we know it is a valid F3H json file path
                        node.setCachedUserData(f3h_cachedUserData.cp_presets_filepath, json_path_checked)
                        
                        prm.set('0')
                        prm_off.set('0')
                        # Mark this as not a loaded preset
                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
                        # check if the selected FLAM3H™ palette file is locked
                        if self.isLOCK(json_path_checked):
                            flam3h_palette_utils.json_to_flam3h_palette_plus_preset_MSG(node, f3h_tabs.CP.DEFAULT_MSG_PALETTE_LOCK)
                            # Lets print to the status bar as well
                            _MSG: str = f"CP: {f3h_tabs.CP.DEFAULT_MSG_PALETTE_LOCK}"
                            flam3h_general_utils.set_status_msg(f"{node.name()}.{_MSG} -> {json_path_checked}", 'WARN')
                        else:
                            flam3h_palette_utils.json_to_flam3h_palette_plus_preset_MSG(node, "")
                            
                else:
                    prm.set('-1')
                    prm_off.set('-1')
                    # CP not a valid file
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_FILE, 0)
                    flam3h_palette_utils.json_to_flam3h_palette_plus_preset_MSG(node, "")
                    # Mark this as not a loaded preset
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
                    # Clear cached data
                    flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.cp_presets_filepath)

        else:
            # CP not a valid file
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_FILE, 0)
            flam3h_palette_utils.json_to_flam3h_palette_plus_preset_MSG(node, "")
            # Mark this as not a loaded preset
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
            # Clear cached data
            flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.cp_presets_filepath)
            
            # We do not want to print if the file path parameter is empty
            # This became redundant since I added file checks during the presets menus build process but I leave it here for now.
            if not json_path:
                self.set_status_msg('', 'MSG')


    def flam3h_init_presets_IN_PRESETS(self, mode: int = 1) -> None:
        """Initialize parameter's menu presets for the IN tab.</br>
        
        Here I could use userData instead of a cachedUserData but can happen that between one houdini session</br>
        and the next one the user may make some modification to the stored file, like moving it into another location or deleting it</br>
        so this way we make sure to always be up to date.</br>
        
        Args:
            (self):
            mode(int): Default to: 1</br>This is to be used to prevent to load a left over preset when loading back a hip file.
            
        Returns:
            (None):
        """    
        node: hou.SopNode = self.node
        # Clear menu caches
        flam3h_iterator_utils(self.kwargs).destroy_all_menus_data(node)
        # Check and Update this data
        flam3h_iterator_utils(self.kwargs).update_xml_last_loaded(False)
        # Retrieve the filepath from the history (preview valid F3H json file path used)
        in_presets_filepath_history: str | None = node.cachedUserData(f3h_cachedUserData.in_presets_filepath)
        
        is_valid: int = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_FILE).eval()
        clipboard: int = node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval()
        prm = node.parm(f3h_tabs.IN.PRM_PRESETS)
        prm_off = node.parm(f3h_tabs.IN.PRM_PRESETS_OFF)
        prm_sys = node.parm(f3h_tabs.IN.PRM_SYS_PRESETS)
        prm_sys_off = node.parm(f3h_tabs.IN.PRM_SYS_PRESETS_OFF)
        for p in (prm, prm_off, prm_sys, prm_sys_off):
            p.lock(False)
            p.deleteAllKeyframes()

        xml: str = os.path.expandvars(node.parm(f3h_tabs.IN.PRM_PATH).eval())
        xml_checked: str | bool = out_flame_utils.out_check_outpath(node,  xml, f3h_tabs.OUT.DEFAULT_FILE_EXT, f3h_tabs.OUT.DEFAULT_AUTO_NAME, False, False)
        
        if in_presets_filepath_history is not None and is_valid and os.path.isfile(in_presets_filepath_history) and in_presets_filepath_history == xml_checked:
            pass
        else:
            prm.set('-1')
            prm_off.set('-1')
        
        if xml_checked is not False:
            assert isinstance(xml_checked, str)
            
            # Set the CP filepath parameter to this checked and corrected filepath
            flam3h_prm_utils.set(node, f3h_tabs.IN.PRM_PATH, xml_checked)
            
            # We are using the class: _xml_tree becasue we really need to carefully validate the loaded flame file.
            # This is important as all the toggles we are setting here will be used to speed up the population of the menu presets.
            # apo = _xml_tree(xml)
            if not _xml_tree(xml_checked).isvalidtree:
                
                if clipboard:
                    self.remove_locked_from_flame_stats(node)
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_FILE, 0)
                    
                else:
                    for prm in (node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_FILE), node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET), node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE)): flam3h_prm_utils.private_prm_set(node, prm, 0)
                    for prm in (node.parm(f3h_tabs.IN.MSG_PRM_FLAMESTATS), node.parm(f3h_tabs.IN.MSG_PRM_FLAMERENDER), node.parm(f3h_tabs.IN.MSG_PRM_FLAMESENSOR), node.parm(f3h_tabs.PRM_DESCRIPTIVE)): flam3h_prm_utils.set(node, prm, '')
                        
                # If it is not a chaotica xml file do print out from here,
                # other wise we are printing out from:
                # class: _xml_tree(...) @staticmethod -> xmlfile_root_chk(...)
                if not in_flame_utils.in_to_flam3h_is_CHAOS(xml):
                    _MSG: str = "IN: Nothing to load"
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                    flam3h_general_utils.flash_message(node, _MSG)
            else:
                # Only set when NOT on an: onLoaded python script
                if mode and xml_checked != in_presets_filepath_history:
                    
                    # IN is valid file
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_FILE, 1)
                    # We store the file path only when we know it is a valid Flame file path
                    node.setCachedUserData(f3h_cachedUserData.in_presets_filepath, xml_checked)
                    
                    prm.set('0')
                    prm_off.set('0')
                    
                    # the IN_PVT_ISVALID_PRESET is set inside the following: in_flame_utils(self.kwargs).in_to_flam3h()
                    in_flame_utils(self.kwargs).in_to_flam3h()
                    
                # Only set when NOT on an: onLoaded python script
                elif mode and not is_valid:
                        
                    # IN is valid file
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_FILE, 1)
                    # We store the file path only when we know it is a valid Flame file path
                    node.setCachedUserData(f3h_cachedUserData.in_presets_filepath, xml_checked)
                    
                    prm.set('0')
                    prm_off.set('0')
                    
                    # the IN_PVT_ISVALID_PRESET is set inside the following: in_flame_utils(self.kwargs).in_to_flam3h()
                    in_flame_utils(self.kwargs).in_to_flam3h()
                    
        else:
            # If there is not a flame preset loaded from the clipboard
            if not clipboard:
                for prm in (node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_FILE), node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET), node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE)): flam3h_prm_utils.private_prm_set(node, prm, 0)
                for prm in (node.parm(f3h_tabs.IN.MSG_PRM_FLAMESTATS), node.parm(f3h_tabs.IN.MSG_PRM_FLAMERENDER), node.parm(f3h_tabs.IN.MSG_PRM_FLAMESENSOR), node.parm(f3h_tabs.PRM_DESCRIPTIVE)): flam3h_prm_utils.set(node, prm, '')
                
                # We do not want to print if the file path parameter is empty
                # This became redundant since I added file checks during the presets menus build process but I leave it here for now.
                # if xml:
                #     print(f'{node.name()}.IN: please select a valid file location.')
            else:
                self.remove_locked_from_flame_stats(node)
                # Otherwise just mark the absence of a valid file and leave everything else untouched
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_FILE, 0)


    def flam3h_init_presets_OUT_PRESETS(self, destroy_menus: bool = True) -> None:
        """Initialize parameter's menu presets for the OUT tab.</br>
        
        Note:
            This need a little update at some point.
        
        Args:
            (self):
            destroy_menus(bool): Default to: True</br>Destroy all menus data and force them to be rebuilt.</br>Set it to False to not force menus rebuild.
            
        Returns:
            (None):
        """    
        node: hou.SopNode = self.node
        # Clear menu caches
        if destroy_menus:
            flam3h_iterator_utils(self.kwargs).destroy_all_menus_data(node)
            # Check and Update this data
            flam3h_iterator_utils(self.kwargs).update_xml_last_loaded(False)
        # Retrieve the filepath from the history (preview valid F3H json file path used)
        out_presets_filepath_history: str | None = node.cachedUserData(f3h_cachedUserData.out_presets_filepath)
        
        is_valid: int = node.parm(f3h_tabs.OUT.PVT_PRM_ISVALID_FILE).eval()
        prm = node.parm(f3h_tabs.OUT.PRM_PRESETS)
        prm_sys = node.parm(f3h_tabs.OUT.PRM_SYS_PRESETS)
        for p in (prm, prm_sys):
            p.lock(False)
            p.deleteAllKeyframes()

        xml: str = os.path.expandvars(node.parm(f3h_tabs.OUT.PRM_PATH).eval())
        xml_checked: str | bool = out_flame_utils.out_check_outpath(node, xml, f3h_tabs.OUT.DEFAULT_FILE_EXT, f3h_tabs.OUT.DEFAULT_AUTO_NAME)

        if out_presets_filepath_history is not None and is_valid and os.path.isfile(out_presets_filepath_history) and out_presets_filepath_history == xml_checked:
            pass
        else:
            prm.set('-1')
            prm_sys.set('-1')
        
        if xml_checked is not False:
            assert isinstance(xml_checked, str)
            
            # Set the IN filepath parameter to this checked and corrected filepath
            flam3h_prm_utils.set(node, f3h_tabs.OUT.PRM_PATH, xml_checked)
            
            apo = _xml_tree(xml_checked) #type: ignore
            if apo.isvalidtree:
                
                if xml_checked != out_presets_filepath_history:
                    
                    # We store the file path only when we know it is a valid Flame file path
                    node.setCachedUserData(f3h_cachedUserData.out_presets_filepath, xml_checked)
                    
                    data: str = f'{len(apo.name)-1}'
                    prm.set(data)
                    prm_sys.set(data)
                    
                    # check if the selected Flame file is locked
                    if self.isLOCK(xml_checked):
                        flam3h_prm_utils.set(node, f3h_tabs.OUT.MSG_PRM_OUT, f3h_tabs.OUT.DEFAULT_MSG_OUT_LOCK)
                        # Lets print to the status bar as well
                        _MSG: str = f"OUT: {f3h_tabs.OUT.DEFAULT_MSG_OUT_LOCK}"
                        flam3h_general_utils.set_status_msg(f"{node.name()}.{_MSG} -> {xml_checked}", 'WARN')
                    else:
                        flam3h_prm_utils.set(node, f3h_tabs.OUT.MSG_PRM_OUT, '')
                        
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_ISVALID_FILE, 1)
                
            else:
                flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.out_presets_filepath)
                
                prm.set('-1')
                prm_sys.set('-1')
                flam3h_prm_utils.set(node, f3h_tabs.OUT.MSG_PRM_OUT, '')
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_ISVALID_FILE, 0)
                
        else:
            flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.out_presets_filepath)
            
            flam3h_prm_utils.set(node, f3h_tabs.OUT.MSG_PRM_OUT, '')
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_ISVALID_FILE, 0)
            # We do not want to print if the file path parameter is empty
            # This became redundant since I added file checks during the presets menus build process but I leave it here for now.
            # if xml:
            #     print(f'{node.name()}.OUT: please select a valid file location.')


    def flam3h_display_help(self) -> None:
        """Open the Houdini help browser to display the FLAM3H™ node documentation.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        hou.ui.displayNodeHelp(self.node.type()) # type: ignore


    def util_store_all_viewers_color_scheme(self) -> None:
        """Store dictionaries of viewers color schemes
        
        Args:
            (self):
            
        Returns:
            (None):  
        """  
        # Do this only if the parameter toggle is: PREFS_VIEWPORT_DARK
        parm: hou.Parm | None = self.kwargs.get('parm')
        _ENTER_PRM: str | None = None
        if parm is not None: _ENTER_PRM = parm.name()
        if _ENTER_PRM is not None and _ENTER_PRM == f3h_tabs.PREFS.PRM_VIEWPORT_DARK:
            views_scheme: list[hou.viewportColorScheme]  = []
            views_keys: list[str] = []
            for v in self.util_getSceneViewers():
                
                # Store only if it is a Sop viewer
                if self.util_is_context('Sop', v) or self.util_is_context('Object', v):
                    
                    view: hou.GeometryViewport = v.curViewport()
                    settings: hou.GeometryViewportSettings = view.settings()
                    _CS: hou.viewportColorScheme = settings.colorScheme()
                    if _CS != hou.viewportColorScheme.Dark: # type: ignore
                        views_scheme.append(_CS)
                        views_keys.append(v.name())
            
            # Always store and update this data
            hou.session.H_CS_STASH_DICT: dict[str, hou.viewportColorScheme] = dict(zip(views_keys, views_scheme)) # type: ignore


    def colorSchemeDark(self, update_others: bool = True) -> None:
        """Change viewport color scheme to dark</br>
        and remember the current color scheme so to switch back to it when unchecked.</br>
        If the viewport color scheme is already dark, checking this option will do nothing.</br>
        
        Args:
            (self):
            update_others(bool): Default to: True</br>Update also the other FLAM3H™ nodes in the scene if any
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        prm = node.parm(f3h_tabs.PREFS.PRM_VIEWPORT_DARK)
        views: list[hou.SceneViewer] = self.util_getSceneViewers()
        
        if views:
            if prm.eval():
                
                # Store all viewers current color schemes
                # if different than Dark
                self.util_store_all_viewers_color_scheme()
                
                dark: bool = False
                allowed_viewers: bool = False
                
                for v in views:
                    
                    # Set only if it is a Sop viewer
                    if self.util_is_context('Sop', v) or self.util_is_context('Object', v):
                        
                        if allowed_viewers is False: allowed_viewers = True
                        
                        settings: hou.GeometryViewportSettings = v.curViewport().settings()
                        _CS: hou.viewportColorScheme = settings.colorScheme()
                        if _CS != hou.viewportColorScheme.Dark: # type: ignore
                            settings.setColorScheme(hou.viewportColorScheme.Dark) # type: ignore
                            if dark is False: dark = True
                
                if allowed_viewers:
                    
                    if dark:
                        _MSG: str = f"Dark: ON"
                        self.flash_message(node, _MSG)
                        self.set_status_msg(f"{node.name()}: {_MSG}", 'IMP')
                    else:
                        _MSG: str = f"Dark already"
                        self.set_status_msg(f"{node.name()}: {_MSG}. Viewers are in Dark mode already", 'MSG')
                        
                else:
                    flam3h_prm_utils.set(node, prm, 0)
                    
                    if not hou.hipFile.isLoadingHipFile(): # type: ignore
                        _MSG: str = f"No Sop viewers available."
                        self.set_status_msg(f"{node.name()}: {_MSG} You need at least one Sop viewer to either set to Dark or restore.", 'WARN')
                        self.flash_message(node, f"{_MSG}")
                    
            else:
                
                try:
                    _STASH_DICT: dict[str, hou.EnumValue] | None = hou.session.H_CS_STASH_DICT # type: ignore
                except AttributeError:
                    _STASH_DICT: dict[str, hou.EnumValue] | None = None
                    
                dark: bool = False
                allowed_viewers: bool = False
                if _STASH_DICT is not None:
                    for v in views:
                        
                        # Only if it is a Sop viewer
                        if self.util_is_context('Sop', v) or self.util_is_context('Object', v):
                            
                            if allowed_viewers is False: allowed_viewers = True
                            
                            key: str = v.name()
                            _STASH: hou.EnumValue | None = _STASH_DICT.get(key)
                            if _STASH is not None:
                                settings: hou.GeometryViewportSettings = v.curViewport().settings()
                                _CS: hou.viewportColorScheme = settings.colorScheme()
                                if _CS == hou.viewportColorScheme.Dark: # type: ignore
                                    settings.setColorScheme(_STASH)
                                    if dark is False: dark = True
                                
                if dark:
                    _MSG: str = f"Dark: OFF"
                    self.flash_message(node, _MSG)
                    self.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                    
                else:
                    
                    try:
                        
                        if hou.session.H_CS_STASH_DICT: # type: ignore
                           
                            if allowed_viewers is False:
                                
                                flam3h_prm_utils.set(node, prm, 1)
                                self.set_status_msg(f"{node.name()}: There are not Sop viewers available to restore.", 'WARN')
                                _MSG_FLASH: str = f"No Sop viewers available."
                                self.flash_message(node, f"{_MSG_FLASH}")
                                
                            else:
                                _MSG: str = f"No viewer in Dark mode"
                                self.set_status_msg(f"{node.name()}: {_MSG}. None of the current viewers are set to Dark.", 'MSG')
                                
                        else:
                            _MSG = f"Nothing to restore"
                            self.set_status_msg(f"{node.name()}: {_MSG}. None of the current viewers has been switched to Dark. They probably were already in Dark mode.", 'MSG')
                            
                    except AttributeError:
                        pass
                            
        else:
            flam3h_prm_utils.set(node, prm, 0)
            
            if not hou.hipFile.isLoadingHipFile(): # type: ignore
                _MSG: str = f"No Sop viewers available."
                self.set_status_msg(f"{node.name()}: {_MSG} You need at least one Sop viewer to either set to Dark or restore.", 'WARN')
                self.flash_message(node, f"{_MSG}")
            
        if update_others:
            # Update dark preference's option toggle on other FLAM3H™ nodes instances
            all_f3h: tuple[hou.SopNode, ...] = self.node.type().instances()
            if len(all_f3h) > 1:
                val: int = prm.eval()
                for f3h in all_f3h:
                    if f3h is node:
                        continue

                    parm = f3h.parm(f3h_tabs.PREFS.PRM_VIEWPORT_DARK)
                    if parm is None:
                        continue

                    if parm.eval() != val:
                        flam3h_prm_utils.set(f3h, parm, val)
    
    
    def viewportParticleDisplay(self) -> None:
        """Switch viewport particle display mode</br>
        between Pixel and Points.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        pttype: int = node.parm(f3h_tabs.PREFS.PRM_VIEWPORT_PT_TYPE).eval()
        pttype_mem: int = node.parm(f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_TYPE_MEM).eval()
        
        Points: hou.EnumValue = hou.viewportParticleDisplay.Points # type: ignore
        Pixels: hou.EnumValue = hou.viewportParticleDisplay.Pixels # type: ignore

        allowed_viewers: bool = False

        for view in self.util_getSceneViewers():
            
            # Set only if it is a Lop viewer
            if self.util_is_context('Sop', view) or self.util_is_context('Object', view):
                
                if allowed_viewers is False: allowed_viewers = True
                
                settings: hou.GeometryViewportSettings = view.curViewport().settings()
                
                match pttype:
                    
                    case 0:
                        settings.particleDisplayType(Points)
                        # update memory
                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_TYPE_MEM, pttype)
                        
                    case 1:
                        settings.particleDisplayType(Pixels)
                        # update memory
                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_TYPE_MEM, pttype)
                        
                    case _:
                        pass # For now, will see if in the future new options will be added.
                        
        # Sync FLAM3H™ nodes
        all_f3h: tuple[hou.SopNode, ...] = node.type().instances()
                        
        # Delete all keyframes
        for f3h in all_f3h:
            f3h_prm = f3h.parm(f3h_tabs.PREFS.PRM_VIEWPORT_PT_TYPE)
            f3h_prm.lock(False)
            f3h_prm.deleteAllKeyframes()
            # Delete all keyframes on memory parms
            flam3h_prm_utils.private_prm_deleteAllKeyframes(f3h, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_TYPE_MEM)
              
        if allowed_viewers:

            for f3h in all_f3h:
                if f3h is node:
                    continue

                # Check and set f3h_tabs.PREFS.VIEWPORT_PT_TYPE
                parm1: hou.Parm = f3h.parm(f3h_tabs.PREFS.PRM_VIEWPORT_PT_TYPE)
                if parm1 is not None and parm1.eval() != pttype:
                    flam3h_prm_utils.set(f3h, f3h_tabs.PREFS.PRM_VIEWPORT_PT_TYPE, pttype)

                # Check and set f3h_tabs.PREFS.PVT_VIEWPORT_PT_TYPE_MEM
                parm2: hou.Parm = f3h.parm(f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_TYPE_MEM)
                if parm2 is not None and parm2.eval() != pttype:
                    flam3h_prm_utils.private_prm_set(f3h, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_TYPE_MEM, pttype)

    
        else:
            if pttype != pttype_mem:
                for f3h in all_f3h:
                    flam3h_prm_utils.set(f3h, f3h_tabs.PREFS.PRM_VIEWPORT_PT_TYPE, pttype_mem)
            
            _MSG = f"No Sop viewers available."
            self.set_status_msg(f"{node.name()}: {_MSG} You need at least one Sop viewer for this option to work.", 'WARN')
            self.flash_message(node, f"{_MSG}")


    def viewportParticleSize(self, reset_val: float | None = None, prm_name_size: str = f3h_tabs.PREFS.PRM_VIEWPORT_PT_SIZE) -> None:
        """When the viewport particle display type is set to Point</br>
        this will change their viewport size.</br>
        
        Args:
            (self):
            reset_val (float | None): Default to: None</br>Can be either "None" or a float value. If "None" it will use the current parameter value, otherwise it will use the one passed in this function.
            prm_name_size(str): Default to: PREFS_VIEWPORT_PT_SIZE</br>The name of the parameter to set.
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        Points: hou.EnumValue = hou.viewportParticleDisplay.Points # type: ignore
        ptsize: float = node.parm(prm_name_size).eval()
        ptsize_mem: float = node.parm(f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_SIZE_MEM).eval()
        
        allowed_viewers: bool = False

        for view in self.util_getSceneViewers():
            
            # Set only if it is a Lop viewer
            if self.util_is_context('Sop', view) or self.util_is_context('Object', view):
            
                if allowed_viewers is False: allowed_viewers = True
            
                settings: hou.GeometryViewportSettings = view.curViewport().settings()
                settings.particleDisplayType(Points)
                if reset_val is None:
                    if prm_name_size == f3h_tabs.PREFS.PRM_VIEWPORT_PT_SIZE:
                        settings.particlePointSize(ptsize)
                        # update memory
                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_SIZE_MEM, ptsize)
                        
                else:
                    ptsize: float = float(reset_val)
                    if prm_name_size == f3h_tabs.PREFS.PRM_VIEWPORT_PT_SIZE:
                        settings.particlePointSize(ptsize)
                        
                    prm = node.parm(prm_name_size)
                    flam3h_prm_utils.set(node, prm, ptsize)
                    if prm_name_size == f3h_tabs.PREFS.PRM_VIEWPORT_PT_SIZE:
                        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_SIZE_MEM, ptsize)

        if prm_name_size == f3h_tabs.PREFS.PRM_VIEWPORT_PT_SIZE:
            
            # Sync FLAM3H™ nodes
            all_f3h: tuple[hou.SopNode, ...] = node.type().instances()
            
            for f3h in all_f3h:
                # Delete all keyframes
                prm_f3h = f3h.parm(prm_name_size)
                prm_f3h.lock(False)
                prm_f3h.deleteAllKeyframes()
                # Delete all keyframes on memory parms
                flam3h_prm_utils.private_prm_deleteAllKeyframes(f3h, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_SIZE_MEM)
            
            # Update Point Size preference's option toggle on other FLAM3H™ nodes instances
            if prm_name_size == f3h_tabs.PREFS.PRM_VIEWPORT_PT_SIZE and node.parm(f3h_tabs.PREFS.PRM_VIEWPORT_PT_TYPE).eval() == 0:
                
                if allowed_viewers:
                    for f3h in all_f3h:
                        parm1: hou.Parm = f3h.parm(prm_name_size)
                        if parm1 is not None and parm1.eval() != ptsize:
                            flam3h_prm_utils.set(f3h, prm_name_size, ptsize)
                            
                        parm2: hou.Parm = f3h.parm(f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_SIZE_MEM)
                        if parm1 is not None and parm2.eval() != ptsize:
                            flam3h_prm_utils.private_prm_set(f3h, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_PT_SIZE_MEM, ptsize)
                            
                else:
                    for f3h in all_f3h:
                        parm: hou.Parm = f3h.parm(prm_name_size)
                        if parm is not None and parm.eval() != ptsize_mem:
                            flam3h_prm_utils.set(f3h, prm_name_size, ptsize_mem)
                
                    _MSG: str = f"No Sop viewers available."
                    self.set_status_msg(f"{node.name()}: {_MSG} You need at least one Sop viewer for this option to work.", 'WARN')
                    self.flash_message(node, f"{_MSG}")
            

    def viewportWireWidth(self, reset_val: float | None = None) -> None:
        """When the viewport handle VIZ is ON</br>
        this will change their viewport setting wire width value.</br>
        
        Args:
            (self):
            reset_val (float | None): Default to: None</br>Can be either "None" or a float value.</br>If "None" it will use the current parameter value, otherwise it will use the one passed in this function.
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        width: float = node.parm(f3h_tabs.PREFS.PRM_VIEWPORT_WIRE_WIDTH).eval()
        width_mem: float = node.parm(f3h_tabs.PREFS.PVT_PRM_VIEWPORT_WIRE_WIDTH_MEM).eval()

        allowed_viewers: bool = False
        for view in self.util_getSceneViewers():
            
            # Set only if it is a Sop viewer
            if self.util_is_context('Sop', view) or self.util_is_context('Object', view):
                
                if allowed_viewers is False: allowed_viewers = True
                
                settings: hou.GeometryViewportSettings = view.curViewport().settings()
                if reset_val is None:
                    settings.wireWidth(width)
                    # update memory
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_WIRE_WIDTH_MEM, width)
                    
                else:
                    width = float(reset_val)
                    settings.wireWidth(width)
                    prm = node.parm(f3h_tabs.PREFS.PRM_VIEWPORT_WIRE_WIDTH)
                    flam3h_prm_utils.set(node, prm, width)
                    # update memory
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_WIRE_WIDTH_MEM, width)
            
        # Sync FLAM3H™ nodes
        all_f3h: tuple[hou.SopNode, ...] = node.type().instances()
            
        if allowed_viewers:
            
            # Updated FLAM3H™ wire width custom value
            hou.session.H_VIEWPORT_WIRE_WIDTH: float = width # type: ignore
            
            for f3h in all_f3h:
                # PREFS_VIEWPORT_WIRE_WIDTH
                # Update wire width preference's option toggle on other FLAM3H™ nodes instances
                parm = f3h.parm(f3h_tabs.PREFS.PRM_VIEWPORT_WIRE_WIDTH)
                if parm is not None:
                    parm.lock(False)
                    parm.deleteAllKeyframes()
                    if parm.eval() != width:
                        flam3h_prm_utils.set(f3h, f3h_tabs.PREFS.PRM_VIEWPORT_WIRE_WIDTH, width)
                # PREFS_PVT_VIEWPORT_WIRE_WIDTH_MEM
                # update memory
                flam3h_prm_utils.private_prm_deleteAllKeyframes(f3h, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_WIRE_WIDTH_MEM)
                mem_parm = f3h.parm(f3h_tabs.PREFS.PVT_PRM_VIEWPORT_WIRE_WIDTH_MEM)
                if mem_parm is not None and mem_parm.eval() != width:
                    flam3h_prm_utils.private_prm_set(f3h, f3h_tabs.PREFS.PVT_PRM_VIEWPORT_WIRE_WIDTH_MEM, width)

        else:
            for f3h in all_f3h:
                parm = f3h.parm(f3h_tabs.PREFS.PRM_VIEWPORT_WIRE_WIDTH)
                if parm is not None and parm.eval() != width_mem:
                    flam3h_prm_utils.set(f3h, f3h_tabs.PREFS.PRM_VIEWPORT_WIRE_WIDTH, width_mem)

            _MSG: str = f"No Sop viewers available."
            self.set_status_msg(f"{node.name()}: {_MSG} You need at least one Sop viewer for this option to work.", 'WARN')
            self.flash_message(node, f"{_MSG}")
            
    
    def reset_SYS(self, density: int, iter: int, mode: int) -> None:
        """Reset the FLAM3H™ SYS Tab parameters.</br>
        
        Args:
            (self):
            density(int): Numper of points to use
            iter(int): Number of iterations
            mode(int): 0: skip "doff" 1: reset "doff"
            
        Returns:
            (None):
        """    
        node: hou.SopNode = self.node

        parms_dict: dict = {f3h_tabs.GLB.PRM_DENSITY: density, 
                            f3h_tabs.GLB.PRM_DENSITY_PRESETS: 1, 
                            f3h_tabs.GLB.PRM_ITERATIONS: iter, 
                            f3h_tabs.SYS.PRM_TAG_SIZE: 0}
        flam3h_prm_utils.setParms(node, parms_dict)
        
        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_TAG, 0)
        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_RIP, 0)

        if mode:
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_DOFF, 0)
        

    def reset_MB(self, all: bool = True) -> None:
        """Reset the FLAM3H™ MB Tab parameters.</br>
        It will also clear/delete any keyframes for each parameters.</br>
        
        Args:
            (self):
            all(bool): Default to: True</br>It will reset all parameters.</br>If False, it will not reset the ON/OFF and VIZ toggles.
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        parms_mb_dict: dict[str, int | float] = {f3h_tabs.MB.PRM_DO: 0,
                                                 f3h_tabs.MB.PRM_FPS: 24,
                                                 f3h_tabs.MB.PRM_SAMPLES: 16,
                                                 f3h_tabs.MB.PRM_SHUTTER: 0.5,
                                                 f3h_tabs.MB.PRM_VIZ: 0}
        
        if all:
            flam3h_prm_utils.setParms(node, parms_mb_dict)
            
        else:
            
            # Lets unlock and delete keyframes anyway
            for prm_name in parms_mb_dict.keys():
                node.parm(prm_name).lock(False)
                node.parm(prm_name).deleteAllKeyframes()
            
            prm_fps: int = node.parm(f3h_tabs.MB.PRM_FPS).eval()
            prm_samples: int = node.parm(f3h_tabs.MB.PRM_SAMPLES).eval()
            prm_shutter: float = node.parm(f3h_tabs.MB.PRM_SHUTTER).eval()
            
            if prm_fps == 24 and prm_samples == 16 and prm_shutter == 0.5:
                _MSG: str = f"MB: already at its default values."
                self.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                self.flash_message(node, _MSG)
                
            else:
                for key, value in parms_mb_dict.items():
                    if key not in (f3h_tabs.MB.PRM_DO, f3h_tabs.MB.PRM_VIZ):
                        flam3h_prm_utils.set(node, key, value)
                
                _MSG: str = f"MB: RESET"
                self.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                self.flash_message(node, _MSG)


    def reset_PREFS(self, mode: int = 0) -> None:
        """Reset the FLAM3H™ PREFS Tab parameters.</br>

        Args:
            (self):
            mode(int): Default to: 0(Zero)</br>If set to 1, it will activate the flam3 compatibility option.
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        parms_dict: dict = {f3h_tabs.PREFS.PRM_XAOS_MODE: 0, 
                            f3h_tabs.PREFS.PRM_CAMERA_HANDLE: 0, 
                            f3h_tabs.PREFS.PRM_CAMERA_CULL: 0, 
                            f3h_tabs.PREFS.PRM_CAMERA: "", 
                            f3h_tabs.PREFS.PRM_CAMERA_CULL_AMOUNT: 0.99}
        flam3h_prm_utils.setParms(node, parms_dict)
        
        # XF VIZ SOLO OFF (but leave the xforms handles VIZ ON)
        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO, 0) # Turn Off iterator xf viz solo mode
        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_FF_VIZ_SOLO, 0) # Turn Off iterator FF xf viz solo mode
        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX, 0) # Reset mp index to Off value: 0(Zero)
        flam3h_iterator_utils.destroy_userData(node, f"{f3h_userData.PRX}_{f3h_userData.XFVIZ_SOLO}")
        
        if mode:
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_F3C, 1)


# FLAM3H™ ITERATOR start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################

class f3h_icons:
    '''
    FLAM3H™ ICONS for bookmarks and menus.</br></br>
    
    To bad vscode does truncate literals of this size in the preview window...</br>
    Maybe there are some settings I can tweak, need to investigate a little.</br>
    
    '''
    # ICONS menu copy/paste bookmarks
    COPY_PASTE: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapRedCopyPasteSVG.svg]'
    COPY_PASTE_XFVIZ: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapRedCopyPaste_xfVizSVG.svg]' # for select iterator bookmark icon when an iterator is in SOLO mode
    COPY_PASTE_ENTRIE: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapRedCopyPasteEntrieSVG.svg]'
    COPY_PASTE_ENTRIE_ZERO: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapRedCopyPasteZeroWSVG.svg]'
    COPY_PASTE_ENTRIE_ZERO_XFVIZ: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapRedCopyPasteZeroW_xfVizSVG.svg]' # for select iterator bookmark icon when an iterator is in SOLO mode
    COPY_PASTE_INFO: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarBlueSVG.svg]'
    COPY_PASTE_INFO_WARN: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWarningSVG.svg]'
    COPY_PASTE_FF: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapRedCopyPasteFFSVG.svg]'
    COPY_PASTE_FF_ENTRIE: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapRedCopyPasteEntrieFFSVG.svg]'
    COPY_PASTE_FF_ENTRIE_OFF: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapRedCopyPasteEntrieFFOffSVG.svg]'
    # ICONS menu select/iterator
    COPY_PASTE_ENTRIE_ITER_OFF_MARKED: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionDisabledSelIterSVG.svg]'
    COPY_PASTE_ENTRIE_ITER_OFF_MARKED_XFVIZ: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionDisabledSelIter_xfVizSVG.svg]' # for select iterator bookmark icon when an iterator is in SOLO mode

    # ICONS menu vars and palette bookmarks
    STAR_EMPTY: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionDisabledSVG.svg]'
    STAR_EMPTY_XFVIZ: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionDisabled_xfVizSVG.svg]' # for select iterator bookmark icon when an iterator is in SOLO mode
    STAR_EMPTY_OPACITY: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionDisabledZeroIterSVG.svg]'
    STAR_EMPTY_OPACITY_XFVIZ: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionDisabledZeroIter_xfVizSVG.svg]' # for select iterator bookmark icon when an iterator is in SOLO mode
    STAR_FLAME_LOAD: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionFlameINEntrieSVG.svg]'
    STAR_FLAME_LOAD_CB: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWhiteSVG.svg]'
    STAR_FLAME_LOAD_EMPTY: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_WhiteSVG_disabled.svg]'
    STAR_FLAME_SAVE: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_WhiteStarSVG.svg]'
    STAR_FLAME_SAVE_ENTRIE: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionFlameOUTEntrieSVG.svg]'
    STAR_PALETTE_LOAD: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionCPSVG.svg]'
    STAR_PALETTE_LOAD_EMPTY: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionPRIDEDisabledSVG.svg]'
    STAR_FLAME_VAR_ACTV: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledSVG.svg]'
    STAR_FLAME_VAR_ACTV_OVER_ONE: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapRedSVG.svg]'
    STAR_FLAME_VAR_ACTV_NEGATIVE: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSVG.svg]'
    STAR_FLAME_VAR_PP_ACTV: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWhitePBSVG.svg]'
    STAR_FLAME_VAR_PP_ACTV_OVER_ONE: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWhitePBHSVG.svg]'
    STAR_FLAME_ITER_ACTV: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarYellowOrangeSVG.svg]'
    STAR_FLAME_ITER_ACTV_XFVIZ: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarYellowOrange_xfVizSVG.svg]' # for select iterator bookmark icon when an iterator is in SOLO mode
    # High tier menu entrie
    STAR_HIGH_TIER: Final = '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]'
    
    # Menu select iterator - Prep icons ((unmarked, marked), (unmarked_xfviz, marked_xfviz))
    SEL_ITER_BOOKMARK_ACTIVE_AND_WEIGHT: Final[tuple[tuple[str, str], tuple[str, str]]] = ((STAR_FLAME_ITER_ACTV, COPY_PASTE), (STAR_FLAME_ITER_ACTV_XFVIZ, COPY_PASTE_XFVIZ))
    SEL_ITER_BOOKMARK_ACTIVE_AND_WEIGHT_ZERO: Final[tuple[tuple[str, str], tuple[str, str]]] = ((STAR_EMPTY_OPACITY, COPY_PASTE_ENTRIE_ZERO), (STAR_EMPTY_OPACITY_XFVIZ, COPY_PASTE_ENTRIE_ZERO_XFVIZ))
    SEL_ITER_BOOKMARK_OFF: Final[tuple[tuple[str, str], tuple[str, str]]] = ((STAR_EMPTY, COPY_PASTE_ENTRIE_ITER_OFF_MARKED), (STAR_EMPTY_XFVIZ, COPY_PASTE_ENTRIE_ITER_OFF_MARKED_XFVIZ))


class f3h_menus:
    '''
    FLAM3H™ pre-built menus for various parameters.</br>
    
    '''
    # The following are pre built to speed up the generations of the menus.
    ZERO_ITERATORS: Final[TA_Menu] = [0, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarBlueSVG.svg]  ZERO ITERATORS\n -> Please, create at least one iterator or load an IN flame file first.', 1, ""]
    DENSITY: Final[TA_Menu] = [-1, '', 1, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWhiteSVG.svg]...', 2, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallSVG.svg]1M', 3, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallSVG.svg]2M', 4, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallSVG.svg]5M', 5, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallSVG.svg]15M', 6, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]25M', 7, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]50M', 8, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]100M', 9, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]150M', 10, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]250M', 11, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]500M', 12, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]750M', 13, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]1 Billion', 14, '']
    DENSITY_XFVIZ_OFF: Final[TA_Menu] = [-1, '', 1, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWhiteXFVIZOFFSVG.svg]...', 2, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallXFVIZOFFSVG.svg]1M', 3, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallXFVIZOFFSVG.svg]2M', 4, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallXFVIZOFFSVG.svg]5M', 5, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallSVG.svg]15M', 6, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]25M', 7, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]50M', 8, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]100M', 9, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]150M', 10, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]250M', 11, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]500M', 12, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]750M', 13, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]1 Billion', 14, '']
    DENSITY_XFVIZ_ON: Final[TA_Menu] = [-1, '', 1, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWhiteXFVIZSVG.svg]...', 2, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallXFVIZSVG.svg]1M', 3, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallXFVIZSVG.svg]2M', 4, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallXFVIZSVG.svg]5M', 5, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallSVG.svg]15M', 6, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]25M', 7, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]50M', 8, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]100M', 9, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]150M', 10, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]250M', 11, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]500M', 12, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]750M', 13, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]1 Billion', 14, '']
    DENSITY_XFVIZ_ON_SOLO: Final[TA_Menu] = [-1, '', 1, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWhiteXFVIZSOLOSVG.svg]...', 2, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallXFVIZSOLOSVG.svg]1M', 3, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallXFVIZSOLOSVG.svg]2M', 4, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallXFVIZSOLOSVG.svg]5M', 5, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapCyanSmallSVG.svg]15M', 6, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]25M', 7, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]50M', 8, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]100M', 9, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]150M', 10, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionEnabledMidSVG.svg]250M', 11, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]500M', 12, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]750M', 13, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarRedHighSVG.svg]1 Billion', 14, '']
    # This is now handled from inside Houdini # MENU_DENSITY_OFF: list = [0, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionDisabledZeroIterSVG.svg]...', 1, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionDisabledZeroIterSVG.svg]1 Billion']
    PRESETS_EMPTY: Final[TA_Menu] = [-1, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionDisabledZeroIterSVG.svg]  Empty     ']
    PRESETS_EMPTY_HIDDEN: Final[TA_Menu] = [-1, '']
    PRESETS_SAVEONE: Final[TA_Menu] = [-1, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarBlueSVG.svg]  Save to create this file     ']
    ZERO_ITERATORS_PRESETS_INVALID: Final[TA_Menu] = [-1, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWarningSVG.svg]  ZERO ITERATORS\n -> Invalid file path. Please, create at least one iterator or load a valid IN flame file first.']
    PRESETS_INVALID: Final[TA_Menu] = [-1, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWarningSVG.svg]  Invalid file path     ']
    PRESETS_INVALID_CB: Final[TA_Menu] = [-1, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWarningSVG.svg]  [CLIPBOARD] Invalid file path     ']
    IN_PRESETS_EMPTY_CB: Final[TA_Menu] = [-1, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWhiteSVG.svg]  [CLIPBOARD]     ']
    ITER_COPY_PASTE_EMPTY: Final[TA_Menu] = [0, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapRedCopyPasteSVG.svg]  Please, mark an iterator first.', 1, '']
    ITER_COPY_PASTE_REMOVED: Final[TA_Menu] = [0, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWarningSVG.svg]  REMOVED: The marked iterator has been removed.\n-> Mark an existing iterator instead.', 1, '']
    ITER_COPY_PASTE_DELETED_MARKED: Final[TA_Menu] = [ 0, "![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarWarningSVG.svg]  DELETED: Marked iterator's node has been deleted.\n-> Mark another iterator first.", 1, '']
    FF_COPY_PASTE_EMPTY: Final[TA_Menu] = [-1, '![opdef:/alexnardini::Sop/FLAM3H?icon_StarSwapRedCopyPasteFFSVG.svg]  Please, mark the FF first.', 0, '']
    FF_COPY_PASTE_SELECT: Final[TA_Menu] = [0, '![opdef:/alexnardini::Sop/FLAM3H?icon_optionStarBlueSVG.svg]  FF: MARKED\n-> Select a different FLAM3H™ node to paste those FF values.', 1, '']

    VARS_ALL_SIMPLE: Final[TA_Menu] = [0, 'Linear                    ', 39, 'Arch                    ', 94, 'Auger...                    ', 14, 'Bent                    ', 52, 'Bent2...                    ', 53, 'Bipolar...                    ', 43, 'Blade                    ', 30, 'Blob...                    ', 26, 'Blur                    ', 54, 'Boarders                    ', 23, 'Bubble                    ', 55, 'Butterfly                    ', 99, 'Bwraps...                    ', 56, 'Cell...                    ', 50, 'Conic...                    ', 83, 'Cos                    ', 89, 'Cosh                    ', 20, 'Cosine                    ', 87, 'Cot                    ', 93, 'Coth                    ', 57, 'Cpow...                    ', 102, 'Crop...                    ', 46, 'Cross                    ', 86, 'Csc                    ', 92, 'Csch                    ', 27, 'Curl...                    ', 97, 'Curve...                    ', 24, 'Cylinder                    ', 11, 'Diamond                    ', 8, 'Disc                    ', 47, 'Disc2...                    ', 58, 'Edisc                    ', 59, 'Elliptic                    ', 61, 'Escher...                    ', 12, 'Ex                    ', 80, 'Exp                    ', 18, 'Exponential                    ', 25, 'Eyefish                    ', 22, 'Fan*                    ', 34, 'Fan2...                    ', 16, 'Fisheye                    ', 49, 'Flower...                    ', 95, 'Flux...                    ', 62, 'Foci                    ', 33, 'Gaussian blur                    ', 104, 'Glynnia                    ', 6, 'Handkerchief                    ', 7, 'Heart                    ', 100, 'Hemisphere                    ', 4, 'Horseshoe                    ', 10, 'Hyperbolic                    ', 13, 'Julia                    ', 31, 'JuliaN...                    ', 32, 'Juliascope...                    ', 63, 'Lazysusan...                    ', 81, 'Log                    ', 64, 'Loonie                    ', 96, 'Mobius...                    ', 66, 'Modulus...                    ', 28, 'Ngon...                    ', 60, 'Noise                    ', 67, 'Oscope...                    ', 51, 'Parabola...                    ', 29, 'Pdj...                    ', 98, 'Perspective...                    ', 38, 'Pie...                    ', 105, 'Point sym...                    ', 5, 'Polar                    ', 68, 'Polar2                    ', 101, 'Polynomial...                    ', 17, 'Popcorn*                    ', 69, 'Popcorn2...                    ', 19, 'Power                    ', 37, 'Radialblur...                    ', 42, 'Rays                    ', 36, 'Rectangles...                    ', 21, 'Rings*                    ', 35, 'Rings2...                    ', 70, 'Scry                    ', 85, 'Sec                    ', 44, 'Secant2                    ', 91, 'Sech                    ', 71, 'Separation...                    ', 82, 'Sin                    ', 88, 'Sinh                    ', 1, 'Sinusoidal                    ', 2, 'Spherical                    ', 9, 'Spiral                    ', 72, 'Split...                    ', 73, 'Splits...                    ', 41, 'Square                    ', 74, 'Stripes...                    ', 48, 'Supershape...                    ', 3, 'Swirl                    ', 84, 'Tan                    ', 40, 'Tangent                    ', 90, 'Tanh                    ', 45, 'Twintrian                    ', 103, 'Unpolar                    ', 15, 'Waves*                    ', 79, 'Waves2...                    ', 75, 'Wedge...                    ', 76, 'Wedgejulia...                    ', 77, 'Wedgesph...                    ', 78, 'Whorl...                    ']
    VARS_ALL_INDEXES: Final[dict[int, int]] = {0: 1, 39: 3, 94: 5, 14: 7, 52: 9, 53: 11, 43: 13, 30: 15, 26: 17, 54: 19, 23: 21, 55: 23, 99: 25, 56: 27, 50: 29, 83: 31, 89: 33, 20: 35, 87: 37, 93: 39, 57: 41, 102: 43, 46: 45, 86: 47, 92: 49, 27: 51, 97: 53, 24: 55, 11: 57, 8: 59, 47: 61, 58: 63, 59: 65, 61: 67, 12: 69, 80: 71, 18: 73, 25: 75, 22: 77, 34: 79, 16: 81, 49: 83, 95: 85, 62: 87, 33: 89, 104: 91, 6: 93, 7: 95, 100: 97, 4: 99, 10: 101, 13: 103, 31: 105, 32: 107, 63: 109, 81: 111, 64: 113, 96: 115, 66: 117, 28: 119, 60: 121, 67: 123, 51: 125, 29: 127, 98: 129, 38: 131, 105: 133, 5: 135, 68: 137, 101: 139, 17: 141, 69: 143, 19: 145, 37: 147, 42: 149, 36: 151, 21: 153, 35: 155, 70: 157, 85: 159, 44: 161, 91: 163, 71: 165, 82: 167, 88: 169, 1: 171, 2: 173, 9: 175, 72: 177, 73: 179, 41: 181, 74: 183, 48: 185, 3: 187, 84: 189, 40: 191, 90: 193, 45: 195, 103: 197, 15: 199, 79: 201, 75: 203, 76: 205, 77: 207, 78: 209}


class flam3h_iterator_utils:
    """
class flam3h_iterator_utils

@STATICMETHODS
* flam3h_iterator_is_default_name(name: str, regex: str = "^[^\d\s()]+(?: [^\d\s()]+)*[\d]+") -> bool:
* flam3h_update_iterators_names(node: hou.SopNode, iter_count: int) -> None:
* flam3h_on_loaded_set_density_menu(node: hou.SopNode) -> None:
* sierpinski_settings(node: hou.SopNode) -> None:
* get_user_data(node: hou.SopNode, data_name: str = f3h_userData.MARKED_ITER, nodeinfo: bool = True) -> str | bool:
* exist_user_data(node: hou.SopNode, data_name: str = f3h_userData.MARKED_ITER, nodeinfo: bool = True) -> bool:
* set_comment_and_user_data_iterator(node: hou.SopNode, value: str, data: str = f3h_userData.MARKED_ITER) -> None:
* del_comment_and_user_data_iterator(node: hou.SopNode, data: str = f3h_userData.MARKED_ITER) -> None:
* flam3h_init_hou_session_iterator_data(node: hou.SopNode) -> None:
* flam3h_init_hou_session_ff_data(node: hou.SopNode) -> None:
* flam3h_init_hou_session_restore_from_user_data(node: hou.SopNode) -> None:
* iterator_mpidx_mem_set(node, data: int) -> None:
* tmp_prm_clear_and_reset(node: hou.SopNode, prm_from: hou.Parm, prm_to: hou.Parm, default_val: float) -> None:
* paste_from_prm(prm_from: hou.Parm, prm_to: hou.Parm, pvt: bool = False) -> None:
* paste_from_list(node: hou.SopNode, flam3node: hou.SopNode | None, prm_list: tuple, id: str, id_from: str) -> None:
* is_iterator_affine_default(node: hou.SopNode, from_FLAM3H_NODE: hou.SopNode, prm_list_affine: tuple[tuple[str, int], ...], id: str, id_from: str, post: bool = False) -> bool:
* is_FF_affine_default(node: hou.SopNode, from_FLAM3H_NODE: hou.SopNode, prm_list_affine: tuple[tuple[str, int], ...], post: bool = False) -> bool:
* paste_from_list_affine(node: hou.SopNode, prm_list_affine_to: tuple[tuple[str, int], ...], prm_list_affine_from: tuple[tuple[str, int], ...], id: str) -> None:
* pastePRM_T_from_list(node: hou.SopNode, flam3node: hou.SopNode | None, prmT_list: tuple, varsPRM: tuple, id: str, id_from: str) -> None:
* paste_save_note(_note: str) -> str:
* paste_set_note(node: hou.SopNode, flam3node: hou.SopNode | None, int_mode: int, str_section: str, id: str, id_from: str) -> None:
* auto_set_xaos_div_str(node: hou.SopNode) -> tuple[str, str]:
* auto_set_xaos_data_get_MP_MEM(node: hou.SopNode) -> list[int] | None:
* auto_set_xaos_data_get_XAOS_PREV(node: hou.SopNode) -> list[list[str]] | None:
* auto_set_xaos_data_set_MP_MEM(node: hou.SopNode, data: list | tuple) -> None:
* auto_set_xaos_data_set_XAOS_PREV(node: hou.SopNode, data: list | tuple) -> None:
* flam3h_on_load_opacity_zero(node: hou.SopNode, f3h_all: bool = False) -> None:
* destroy_cachedUserData(node, data: str, must_exist: bool = False) -> None:
* destroy_cachedUserData_all_f3h(node, data_name: str) -> None:
* destroy_userData(node, data: str, must_exist: bool = False) -> None:
* force_menu_var_update_FF(node: hou.SopNode) -> None:
* menu_T_get_type_icon(w: float) -> str:
* menu_T_PP_get_type_icon(w: float) -> str:

@METHODS
* iterator_affine_scale(self) -> None:
* iterator_post_affine_scale(self) -> None:
* iterator_FF_affine_scale(self) -> None:
* iterator_FF_post_affine_scale(self) -> None:
* destroy_all_menus_data(self, node: hou.SopNode, f3h_all: bool = False) -> None:
* update_xml_last_loaded(self, menu_update: bool = True) -> None:
* refresh_iterator_vars_menu(self) -> None:
* destroy_data_note(self) -> None:
* note_FF(self) -> None:
* menu_T_get_var_data(self) -> tuple[int, float]:
* menu_T_FF_get_var_data(self) -> tuple[int, float]:
* menu_T_data(self) -> tuple[int, str]:
* menu_T_PP_data(self) -> tuple[int, str]:
* menu_T_FF_data(self) -> tuple[int, str]:
* menu_T_PP_FF_data(self) -> tuple[int, str]:
* menu_T_pb_data(self) -> str:
* menu_T_ICON(self) -> TA_Menu:
* menu_T_ICON_FF(self) -> TA_Menu:
* menu_T_PP_ICON(self) -> TA_Menu:
* menu_T_PP_ICON_FF(self) -> TA_Menu:
* menu_T_simple(self) -> TA_Menu:
* menu_T(self) -> TA_Menu:
* menu_T_FF(self) -> TA_Menu:
* menu_T_PP(self) -> TA_Menu:
* menu_T_PP_FF(self) -> TA_Menu:
* menu_T_pb(self) -> TA_Menu:
* menu_select_iterator_data(self, data_now: tuple[list[Any] | Any, ...], data_names: tuple[str, ...]) -> TA_Menu:
* menu_select_iterator(self) -> TA_Menu:
* prm_select_iterator(self) -> None:
* flam3h_paste_reset_hou_session_data(self, hipLoad: bool = False) -> None:
* menu_global_density(self) -> TA_Menu:
* menu_global_density_set(self) -> None:
* menu_global_density_set_default(self) -> None:
* menu_copypaste(self) -> TA_Menu:
* menu_copypaste_FF(self) -> TA_Menu:
* prm_paste_update_for_undo(self, node: hou.SopNode) -> tuple[hou.SopNode | None, int | None, bool]:
* prm_paste_update_for_undo_ff(self, node: hou.SopNode) -> tuple[hou.SopNode | None, int | None, bool]:
* prm_paste_CTRL(self, id: int) -> None:
* prm_paste_SHIFT(self, id: int) -> None:
* prm_paste_CLICK(self, id: int) -> None:
* prm_paste(self) -> None:
* prm_paste_FF_CTRL(self) -> None:
* prm_paste_FF_SHIFT(self) -> None:
* prm_paste_FF_CLICK(self) -> None:
* prm_paste_FF(self) -> None:
* prm_paste_sel_iter_sel_force_update(self, node: hou.SopNode) -> None:
* prm_paste_sel(self) -> None:
* prm_paste_sel_pre_affine(self) -> None:
* prm_paste_sel_post_affine(self) -> None:
* prm_paste_sel_pre_affine_FF(self) -> None:
* prm_paste_sel_post_affine_FF(self) -> None:
* prm_paste_sel_FF(self) -> None:
* flam3h_xaos_convert(self) -> None:
* reset_preaffine(self) -> None:
* reset_postaffine(self) -> None:
* reset_preaffine_FF(self) -> None:
* reset_postaffine_FF(self) -> None:
* swap_iter_pre_vars(self) -> None:
* swap_FF_post_vars(self) -> None:
* flam3h_default(self) -> None:
* flam3h_reset_iterator(self) -> None:
* flam3h_reset_FF(self) -> None:
* auto_set_xaos(self) -> None:
* iterators_count_zero(self, node: hou.SopNode, do_msg: bool = True) -> None:
* iterators_count_not_zero(self, node: hou.SopNode) -> None:
* iterators_count(self) -> None:
* iterator_vactive_and_update(self) -> None:
    """    
    
    __slots__ = ("_kwargs", "_node")
    
    def __init__(self, kwargs: dict) -> None:
        """
        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """ 
        self._kwargs: dict[str, Any] = kwargs
        self._node: hou.SopNode = kwargs['node']
        
        
    @staticmethod
    def flam3h_iterator_is_default_name(name: str, regex: str = "^[^\d\s()]+(?: [^\d\s()]+)*[\d]+") -> bool:
        """Check if an iterator name is a default name or not.</br>
        
        Args:
            name(str): current iterator name to check.
            regex(str): Default to: <b>^[^\d\s()]+(?: [^\d\s()]+)*[\d]+</b></br>The regex expresion to use. Default to one build for the current iterators default name.
        
        Returns:
            (bool): True if the iterator name is a default name and False if not.
        """
        name_strip: str = name.strip()
        x = re_search(regex, name_strip)
        return True if x is not None and x.group() == name_strip else False
    
    
    @staticmethod
    def flam3h_update_iterators_names(node: hou.SopNode, iter_count: int) -> None:
        """Rename iterators if they have a default name.
        This is useful when new iterators are added inbetween or when they are reordered.
        
        Args:
            node(hou.SopNode): This FLAM3H™ node
            iter_count(int): number of iterators in this FLAM3H™ node.
        
        Returns:
            (None):
        """
        
        _flam3h_iterator_is_default_name: Callable[[str, str], bool] = flam3h_iterator_utils.flam3h_iterator_is_default_name
        mp_note_name: str = flam3h_iterator_prm_names().main_note
        for mp_idx in range(iter_count):
            new_mp_idx: str = str(mp_idx + 1)
            param_name: str = f"{mp_note_name}_{new_mp_idx}"
            param_val: str = str(node.parm(param_name).eval()).strip()
            if _flam3h_iterator_is_default_name(param_val):
                flam3h_prm_utils.set(node, param_name, f"iterator_{new_mp_idx}")


    @staticmethod
    def flam3h_on_loaded_set_density_menu(node: hou.SopNode) -> None:
        """This is for backward compatibility when the point count parameter was still exposed.</br>
        It will set the density presets menu based on the currently set density value.</br></br>
        
        The density values dictionary entries match whats inside:
        * def menu_global_density_set(self) -> None:
        
        and also the entries inside the global menu: f3h_menus.DENSITY
        
        Any changes to the entries on one of those need to be made also on the others.
        
        Args:
            node(hou.SopNode): current hou.SopNode to set
        
        Returns:
            (None):
        """
        density: int = node.parm(f3h_tabs.GLB.PRM_DENSITY).eval()
        # node.parm(f3h_tabs.GLB.DENSITY).deleteAllKeyframes() # This is commented out for now to allow to anim the density only from here
        prm = node.parm(f3h_tabs.GLB.PRM_DENSITY_PRESETS)
        density_values: dict[int, int] = { 500000: 1, 1000000: 2, 2000000: 3, 5000000: 4, 15000000: 5, 25000000: 6, 50000000: 7, 100000000: 8, 150000000: 9, 250000000: 10, 500000000: 11, 750000000: 12, 1000000000: 13 }
        density_idx: int | None = density_values.get(density)
        if density_idx is not None:
            flam3h_prm_utils.set(node, prm, density_idx)
        else:
             flam3h_prm_utils.set(node, prm, -1)


    @staticmethod
    def sierpinski_settings(node: hou.SopNode) -> None:
        """Set all the parameter to build a sierpinski triangle.</br>

        Args:
            node(hou.SopNode): current hou.SopNode to set
            
        Returns:
            (None):
        """
        # Iterator prm names
        n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
        
        # Iterator parms names
        prm_names: tuple[str, ...] = (  n.shader_color, 
                                        n.shader_speed, 
                                        n.prevar_type_1, 
                                        n.prevar_type_2, 
                                        n.var_type_1, 
                                        n.var_type_2, 
                                        n.var_type_3, 
                                        n.var_type_4, 
                                        n.postvar_type_1, 
                                        n.preaffine_x, 
                                        n.preaffine_y, 
                                        n.preaffine_o
                                        )
        
        # Calc triangle sides
        height: float = 0.5 # so it is 1(one) Houdini unit tall
        side: float = height * 2.0 / 1.7320508075688772
        side /= 2.0 # Being 0(Zero) world centered
        
        # Bake the values that stay the same across all iterators
        _X: hou.Vector2 = hou.Vector2((0.5, 0.0))
        _Y: hou.Vector2 = hou.Vector2((0.0, 0.5))
        # Build sides values
        _O_1: hou.Vector2 = hou.Vector2((0.0, height))
        _O_2: hou.Vector2 = hou.Vector2((-side, 0.0))
        _O_3: hou.Vector2 = hou.Vector2((side, 0.0))
        
        # Iterator 1
        prm_vals_1: tuple[float | hou.Vector2, ...] = ( 0, 
                                                        -0.5, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        _X, 
                                                        _Y, 
                                                        _O_1
                                                        )
        
        # Iterator 2
        prm_vals_2: tuple[float | hou.Vector2, ...] = ( 0.5, 
                                                        -0.5, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        _X, 
                                                        _Y, 
                                                        _O_2
                                                        )
        
        # Iterator 3
        prm_vals_3: tuple[float | hou.Vector2, ...] = ( 1, 
                                                        -0.5, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        0, 
                                                        _X, 
                                                        _Y, 
                                                        _O_3
                                                        )
        
        # Collect all iterators parms values
        prm_vals_all: tuple[tuple[float | hou.Vector2, ...], tuple[float | hou.Vector2, ...], tuple[float | hou.Vector2, ...]] = (prm_vals_1, prm_vals_2, prm_vals_3)
        
        # Set
        for iter_idx, iter_vals in enumerate(prm_vals_all):
            prm_idx: int = iter_idx + 1
            for idx, name in enumerate(prm_names):
                prm_name: str = f"{name}_{prm_idx}"
                flam3h_prm_utils.set(node, prm_name, iter_vals[idx])


    @staticmethod
    def get_user_data(node: hou.SopNode, data_name: str = f3h_userData.MARKED_ITER, nodeinfo: bool = True) -> str | bool:
        """Get the node user data associated to the copy/paste data.</br>
        
        Args:
            node(hou.SopNode): [current hou.SopNode to set]
            data(str): Default to: f3h_userData.MARKED_ITER</br>The name of the data we want to get. 
            nodeinfo(bool): Default to: True</br>It will add the "nodeinfo" prefix to the <b>data_name</b></br>Set to False to use the raw <b>data_name</b> string.
            
        Returns:
            (int | bool): Return the requested user data or False if it does not exist.
        """   
        
        if nodeinfo: name: str = f"{f3h_userData.PRX}_{data_name}"
        else: name: str = f"{data_name}"
        data: str | None = node.userData(f"{name}")
        if data is not None:
            return data
        
        return False


    @staticmethod
    def exist_user_data(node: hou.SopNode, data_name: str = f3h_userData.MARKED_ITER, nodeinfo: bool = True) -> bool:
        """Confirm the node user data associated to the copy/paste data Exist.</br>
        
        Args:
            node(hou.SopNode): [current hou.SopNode to set]
            data_name(str): Default to: f3h_userData.MARKED_ITER</br>The name of the data we want to get. For FF it wil be: " f3h_userData.MARKED_FF "
            nodeinfo(bool): Default to: True</br>It will add the "nodeinfo" prefix to the <b>data_name</b></br>Set to False to use the raw <b>data_name</b> string.
            
        Returns:
            (bool): Return True if the requested user data exist or False if it does not.
        """   
        if nodeinfo: name: str = f"{f3h_userData.PRX}_{data_name}"
        else: name: str = f"{data_name}"
        if node.userData(f"{name}") is None:
            return False
        
        return True


    @staticmethod
    def set_comment_and_user_data_iterator(node: hou.SopNode, value: str, data: str = f3h_userData.MARKED_ITER) -> None:
        """Set the node comment associated to the copy/paste data. It can be for an iterator number or for the FF.</br>
        
        Args:
            node(hou.SopNode): FLAM3H™ node to set
            value(str): The value to set this user data to.
            data(str): Default to: f3h_userData.MARKED_ITER</br>The name of the data we want to set the comment for. 

        Returns:
            (None):
        """   
        
        data_name: str = f"{f3h_userData.PRX}_{data}"
        data_iter_name: str = f"{f3h_userData.PRX}_{f3h_userData.MARKED_ITER}"
        data_FF_name: str = f"{f3h_userData.PRX}_{f3h_userData.MARKED_FF}"
        
        if data_name == data_iter_name:
            
            if node.userData(f"{data_FF_name}") is None:
                if node.userData(f"{data_name}") is None:
                    with hou.undos.group(f"FLAM3H™ SET user data None"): # type: ignore
                        node.setUserData(f"{data_name}", value)
                        node.setComment(node.userData(f"{data_name}"))
                        node.setGenericFlag(hou.nodeFlag.DisplayComment, True) # type: ignore
                    
            else:
                if node.userData(f"{data_name}") is None:
                    with hou.undos.group(f"FLAM3H™ SET user data"): # type: ignore
                        node.setUserData(f"{data_name}", value)
                        node.setComment(f"{value}, FF")
                        node.setGenericFlag(hou.nodeFlag.DisplayComment, True) # type: ignore
                    
        elif data_name == data_FF_name:
            if node.userData(f"{data_iter_name}") is None:
                if node.userData(f"{data_name}") is None:
                    with hou.undos.group(f"FLAM3H™ SET FF user data None"): # type: ignore
                        node.setUserData(f"{data_name}", value)
                        node.setComment("FF")
                        node.setGenericFlag(hou.nodeFlag.DisplayComment, True) # type: ignore
            
            else:
                if node.userData(f"{data_name}") is None:
                    with hou.undos.group(f"FLAM3H™ SET FF user data"): # type: ignore
                        data_iter = node.userData(f"{data_iter_name}")
                        node.setUserData(f"{data_name}", value)
                        node.setComment(f"{data_iter}, FF")
                        node.setGenericFlag(hou.nodeFlag.DisplayComment, True) # type: ignore

        
    @staticmethod
    def del_comment_and_user_data_iterator(node: hou.SopNode, data: str = f3h_userData.MARKED_ITER) -> None:
        """Delete the node comment associated to the copy/paste data. It can be for an iterator number or for the FF.</br>
        
        Args:
            node(hou.SopNode): FLAM3H™ node to set
            data(str): Default to: FLAM3H_USER_DATA_ITER</br>The name of the data we want to delete the comment for. 
            
        Returns:
            (None):
        """   

        data_name: str = f"{f3h_userData.PRX}_{data}"
        data_iter_name: str = f"{f3h_userData.PRX}_{f3h_userData.MARKED_ITER}"
        data_FF_name: str = f"{f3h_userData.PRX}_{f3h_userData.MARKED_FF}"

        if data_name == data_iter_name:
            if node.userData(f"{data_FF_name}") is None:
                if node.userData(f"{data_name}") is not None:
                    with hou.undos.group(f"FLAM3H™ DEL user data iter None"): # type: ignore
                        flam3h_iterator_utils.destroy_userData(node, f"{data_name}")
                        node.setComment("")
                        node.setGenericFlag(hou.nodeFlag.DisplayComment, False) # type: ignore
                    
            else:
                if node.userData(f"{data_name}") is not None:
                    with hou.undos.group(f"FLAM3H™ DEL user data iter"): # type: ignore
                        flam3h_iterator_utils.destroy_userData(node, f"{data_name}")
                        # node.setComment("")
                        node.setGenericFlag(hou.nodeFlag.DisplayComment, False) # type: ignore
                        node.setComment("FF")
                        node.setGenericFlag(hou.nodeFlag.DisplayComment, True) # type: ignore
                    
        elif data_name == data_FF_name:
            
            if node.userData(f"{data_iter_name}") is None:
                if node.userData(f"{data_name}") is not None:
                    with hou.undos.group(f"FLAM3H™ DEL FF user data None"): # type: ignore
                        flam3h_iterator_utils.destroy_userData(node, f"{data_name}")
                        node.setComment("")
                        node.setGenericFlag(hou.nodeFlag.DisplayComment, False) # type: ignore
                    
            else:
                if node.userData(f"{data_name}") is not None:
                    with hou.undos.group(f"FLAM3H™ DEL FF user data"): # type: ignore
                        data_iter = node.userData(f"{data_iter_name}")
                        flam3h_iterator_utils.destroy_userData(node, f"{data_name}")
                        # node.setComment("")
                        node.setGenericFlag(hou.nodeFlag.DisplayComment, False) # type: ignore
                        node.setComment(f"{data_iter}")
                        node.setGenericFlag(hou.nodeFlag.DisplayComment, True) # type: ignore


    @staticmethod            
    def flam3h_init_hou_session_iterator_data(node: hou.SopNode) -> None:
        """Initialize the copy/paste data need by FLAM3H™ iterators and stored into the current hou.session.</br>
        
        Args:
            node(hou.SopNode): FLAM3H™ node to set
            
        Returns:
            (None):
        """   
        
        # The following try/except blocks are not really needed
        # becasue FLAM3H™ node will create and initialize those on creation
        # but just in case this data is deleted somehow.
        try:
            hou.session.F3H_MARKED_ITERATOR_NODE # type: ignore
        except AttributeError:
            hou.session.F3H_MARKED_ITERATOR_NODE: TA_MNode = node # type: ignore
        except hou.ObjectWasDeleted:
            hou.session.F3H_MARKED_ITERATOR_NODE: TA_MNode = node # type: ignore
            
        try:
            hou.session.F3H_MARKED_ITERATOR_NODE.type() # type: ignore
        except (AttributeError, hou.ObjectWasDeleted):
            hou.session.F3H_MARKED_ITERATOR_NODE: TA_MNode = None # type: ignore
        try:
            hou.session.F3H_MARKED_ITERATOR_MP_IDX # type: ignore
        except AttributeError:
            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = None # type: ignore
        except hou.ObjectWasDeleted:
            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = None # type: ignore


    @staticmethod
    def flam3h_init_hou_session_ff_data(node: hou.SopNode) -> None:
        """Initialize the copy/paste data need by FLAM3H™ FF and stored into the current hou.session.</br>
        
        Args:
            node(hou.SopNode): FLAM3H™ node to set
            
        Returns:
            (None):
        """   
        
        # The following try/except blocks are not really needed
        # becasue FLAM3H™ node will create and initialize those on creation
        # but just in case this data is deleted somehow.
        try:
            hou.session.F3H_MARKED_FF_NODE # type: ignore
        except AttributeError:
            hou.session.F3H_MARKED_FF_NODE: TA_MNode = node # type: ignore
        except hou.ObjectWasDeleted:
            hou.session.F3H_MARKED_FF_NODE: TA_MNode = node # type: ignore
            
        try:
            hou.session.F3H_MARKED_FF_NODE.type() # type: ignore
        except (AttributeError, hou.ObjectWasDeleted):
            hou.session.F3H_MARKED_FF_NODE: TA_MNode = None # type: ignore
            
        try:
            hou.session.F3H_MARKED_FF_CHECK # type: ignore
        except AttributeError:
            hou.session.F3H_MARKED_FF_CHECK: TA_M = None # type: ignore
        except hou.ObjectWasDeleted:
            hou.session.F3H_MARKED_FF_CHECK: TA_M = None # type: ignore
        
        
    @staticmethod
    def flam3h_init_hou_session_restore_from_user_data(node: hou.SopNode) -> None:
        """If in the loaded hip file there are data stored into the nodes, lets set the copy/paste data to those.</br>
        This will allow to re-load an hip file with marked iterator or FF and pick up from there, which is nice.</br>
        
        Args:
            node(hou.SopNode): FLAM3H™ node to set
            
        Returns:
            (None):
        """   
        
        # Iterator
        if flam3h_iterator_utils.exist_user_data(node):
            hou.session.F3H_MARKED_ITERATOR_NODE: TA_MNode = node # type: ignore
            data: int = int(flam3h_iterator_utils.get_user_data(node))
            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = data # type: ignore
            flam3h_iterator_utils.iterator_mpidx_mem_set(node, data) # type: ignore
        else:
            # If this node do not posses the copy/paste data, lets first check if the data and its node exist (other FLAM3H™ node)
            # before clearing it out
            try: 
                hou.session.F3H_MARKED_ITERATOR_NODE.type() # type: ignore
                hou.session.F3H_MARKED_ITERATOR_MP_IDX # type: ignore
            except (AttributeError, hou.ObjectWasDeleted):
                hou.session.F3H_MARKED_ITERATOR_NODE: TA_MNode = None # type: ignore
                hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = None # type: ignore
            
        # FF
        if flam3h_iterator_utils.exist_user_data(node, f3h_userData.MARKED_FF):
            hou.session.F3H_MARKED_FF_NODE: TA_MNode = node # type: ignore
            hou.session.F3H_MARKED_FF_CHECK: TA_M = 1 # type: ignore
        else:
            # If this node do not posses the copy/paste data, lets first check if the data and its node exist (other FLAM3H™ node)
            # before clearing it out
            try: 
                hou.session.F3H_MARKED_FF_NODE.type() # type: ignore
                hou.session.F3H_MARKED_FF_CHECK # type: ignore
            except (AttributeError, hou.ObjectWasDeleted):
                hou.session.F3H_MARKED_FF_NODE: TA_MNode = None # type: ignore
                hou.session.F3H_MARKED_FF_CHECK: TA_M = None # type: ignore


    @staticmethod
    def iterator_mpidx_mem_set(node, data: int) -> None:
        """Work as an history space to store the marked iterator info in it.</br>
        
        Args:
            node(hou.SopNode): FLAM3H™ node to set
            data(int): Marked iterator number and info. The possible option are:
                * from 1 to n for the number of the marked iterator.
                * 0 to signal no iterator has been marked.
                * -1 if a marked iterator has been deleted.
            
        Returns:
            (None):
        """   
        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX, data)


    @staticmethod
    def tmp_prm_clear_and_reset(node: hou.SopNode, prm_from: hou.Parm, prm_to: hou.Parm, reset_val: int | float = 0) -> None:
        """Delete all keyframes and reset to a default value after the two temp parameters performed a value swap.</br>
        
        This is specifically made for:
        * def swap_iter_pre_vars(self) -> None:
        * def swap_FF_post_vars(self) -> None:
        
        Args:
            node(hou.SopNode): this FLAM3H™ node
            prm_from(hou.Parm): the first parameter
            prm_to(hou.Parm): the second parameter
            reset_val(int | float): Default to: 0</br>The value to reset the parameters to.</br>This should be int for types and float for weights.
            
        Returns:
            (None):
        """
        # Clear tmp prm so in case of keyframes or expression it doesnt evaluate
        for prm in (prm_from, prm_to):
            flam3h_prm_utils.private_prm_set(node, prm, reset_val)


    @staticmethod
    def paste_from_prm(prm_from: hou.Parm, prm_to: hou.Parm, pvt: bool = False) -> None:
        """Paste value for a single parameter, including keyframes and expressions if any.</br>
        
        Args:
            prm_from(hou.Parm): The parameter to copy the data from
            prm_to(hou.Parm): The parameter to copy the dato into
            pvt(bool): Default to: False</br>Is it a private parameter or not ?
            
        Returns:
            (None):
        """   
        prm_to.lock(False) 
        prm_to.deleteAllKeyframes()
        
        if len(prm_from.keyframes()):
            for k in prm_from.keyframes(): prm_to.setKeyframe(k)
        else:
            prm_to.set(prm_from.eval()) # type: ignore
            
        # lock back if it is a private parameter
        if pvt:
            prm_to.lock(True)


    @staticmethod
    def paste_from_list(node: hou.SopNode, flam3node: hou.SopNode | None, prm_list: tuple, id: str, id_from: str) -> None:
        """Paste value for a parameter, including keyframes and expressions if any,</br>
        between different multiparameter indexes.</br>
        
        Args:
            node(hou.SopNode): FLAM3H™ node to set
            flam3node(hou.SopNode | None): hou.SopNode to copy values from
            prm_list(tuple): parameters list to query and set
            id(str): current multiparamter index
            id_from(str): multiparameter index to copy from
            
        Returns:
            (None):
        """    
        
        if flam3node is not None:
            
            for prm in prm_list:
                
                # if a tuple
                if prm[1]:
                    prm_from = flam3node.parmTuple(f"{prm[0]}{id_from}")
                    prm_to = node.parmTuple(f"{prm[0]}{id}")
                    prm_to.lock(False)
                    prm_to.deleteAllKeyframes()

                    for prm_idx, p in enumerate(prm_from):
                        keyframes: tuple[hou.Keyframe, ...] = p.keyframes()
                        dest_parm: hou.Parm = prm_to[prm_idx]

                        if keyframes:
                            for k in keyframes:
                                dest_parm.setKeyframe(k)
                        else:
                            dest_parm.set(p.eval()) # type: ignore
                    
                else:
                    prm_from = flam3node.parm(f"{prm[0]}{id_from}")
                    prm_to = node.parm(f"{prm[0]}{id}")
                    prm_to.lock(False)
                    prm_to.deleteAllKeyframes()
                    keyframes: tuple[hou.Keyframe, ...] = prm_from.keyframes()
                    if keyframes:
                        for k in keyframes:
                            prm_to.setKeyframe(k)
                    else:
                        prm_to.set(prm_from.eval())
        else:
            _MSG: str = f"{node.name()} -> The FLAM3H™ node you are trying to copy data from do not exist"
            flam3h_general_utils.set_status_msg(_MSG, 'WARN')
            
            
    @staticmethod
    def is_iterator_affine_default(node: hou.SopNode, from_FLAM3H_NODE: hou.SopNode, prm_list_affine: tuple[tuple[str, int], ...], id: str, id_from: str, post: bool = False) -> bool:
        """To be used with the copy/paste methods. Check if an iterator Affine (PRE or POST) are at default values. </br>
        If they are default values and they are the post affine, it will turn the post affine toggle OFF for both this iterator (id) and the from iterator (id_from)</br>
        even if they are between two different FLAM3H™ nodes (node and from_FLAM3H_NODE)</br>
        
        Args:
            node(hou.SopNode): This FLAM3H™ node
            from_FLAM3H_NODE(hou.SopNode, None): hou.SopNode to copy values from
            prm_list_affine(tuple[tuple[str, int], ...]): parameters list to query. This expect either: flam3h_iterator().sec_preAffine or flam3h_iterator().sec_postAffine
            id(str): current multiparamter index
            id_from(str): multiparameter index to copy from
            post(bool): Default to: False</br>Is it a post affine ?</br>True for declaring it as post affine.
            
        Returns:
            (bool): True if the affine are default values and False if they are not.
        """   
        _len: Callable[[tuple[Any]], int] = len
        if post:
            prm_list_affine_XYOA: tuple[tuple[str, int], ...] = prm_list_affine[1:]
            keyframes_post: list[int] = [item for sublist in [[1 if _len(p.keyframes()) else 0 for p in node.parmTuple(f"{prm_list_affine_XYOA[idx][0]}{id}")] if prm_list_affine_XYOA[idx][1] else [1 if _len(node.parm(f"{prm_list_affine_XYOA[idx][0]}{id}").keyframes()) else 0] for idx in range(len(prm_list_affine_XYOA))] for item in sublist]
            collect_post: list[tuple[float, ...] | float] = [node.parmTuple(f"{prm_list_affine_XYOA[idx][0]}{id}").eval() if prm_list_affine_XYOA[idx][1] else node.parm(f"{prm_list_affine_XYOA[idx][0]}{id}").eval() for idx in range(len(prm_list_affine_XYOA))]
            if 1 not in keyframes_post and collect_post == f3h_affineDefaults.DEFAULT_VALS:
                prm_name: str = prm_list_affine[0][0]
                prm_node = node.parm(f"{prm_name}{id}")
                prm_from_FLAM3H_NODE = from_FLAM3H_NODE.parm(f"{prm_name}{id_from}")
                for p in (prm_node, prm_from_FLAM3H_NODE):
                    p.lock(False)
                    p.deleteAllKeyframes()
                    p.set(0)
                return True
            
            return False

        keyframes_pre: list[int] = [item for sublist in [[1 if _len(p.keyframes()) else 0 for p in node.parmTuple(f"{prm_list_affine[idx][0]}{id}")] if prm_list_affine[idx][1] else [1 if _len(node.parm(f"{prm_list_affine[idx][0]}{id}").keyframes()) else 0] for idx in range(len(prm_list_affine))] for item in sublist]
        collect_pre: list[tuple[float, ...] | float] = [node.parmTuple(f"{prm_list_affine[idx][0]}{id}").eval() if prm_list_affine[idx][1] else node.parm(f"{prm_list_affine[idx][0]}{id}").eval() for idx in range(len(prm_list_affine))]
        if 1 not in keyframes_pre and collect_pre == f3h_affineDefaults.DEFAULT_VALS:
            return True
        
        return False
            
            
    @staticmethod
    def is_FF_affine_default(node: hou.SopNode, from_FLAM3H_NODE: hou.SopNode, prm_list_affine: tuple[tuple[str, int], ...], post: bool = False) -> bool:
        """To be used with the copy/paste methods. Check if the FF Affine (PRE or POST) are at default values.</br></br>
        
        If they are default values and they are the post affine,</br>
        it will turn the post affine toggle OFF for both this iterator (id) and the from iterator (id_from)</br>
        even if they are between two different FLAM3H™ nodes (node and from_FLAM3H_NODE)
        
        Args:
            node(hou.SopNode): This FLAM3H™ node
            flam3node(hou.SopNode, None): hou.SopNode to copy values from
            prm_list_affine(tuple[tuple[str, int], ...]): parameters list to query.</br>This expect either:</br>flam3h_iterator_FF().sec_preAffine_FF</br>flam3h_iterator_FF().sec_postAffine_FF
            post(bool): Default to: False</br>Is it a post affine ?</br>True for declaring it as post affine.
            
        Returns:
            (bool): True if the affine are default values and False if they are not.
        """   
        _len: Callable[[tuple[Any]], int] = len
        if post:
            prm_list_affine_XYOA: tuple[tuple[str, int], ...] = prm_list_affine[1:]
            keyframes_post: list[int] = [item for sublist in [[1 if _len(p.keyframes()) else 0 for p in node.parmTuple(f"{prm_list_affine_XYOA[idx][0]}")] if prm_list_affine_XYOA[idx][1] else [1 if _len(node.parm(f"{prm_list_affine_XYOA[idx][0]}").keyframes()) else 0] for idx in range(len(prm_list_affine_XYOA))] for item in sublist]
            collect_post: list[tuple[float, ...] | float] = [node.parmTuple(f"{prm_list_affine_XYOA[idx][0]}").eval() if prm_list_affine_XYOA[idx][1] else node.parm(f"{prm_list_affine_XYOA[idx][0]}").eval() for idx in range(len(prm_list_affine_XYOA))]
            if 1 not in keyframes_post and collect_post == f3h_affineDefaults.DEFAULT_VALS:
                prm_name: str = prm_list_affine[0][0]
                prm_node = node.parm(prm_name)
                prm_from_FLAM3H_NODE = from_FLAM3H_NODE.parm(prm_name)
                for p in (prm_node, prm_from_FLAM3H_NODE):
                    p.lock(False)
                    p.deleteAllKeyframes()
                    p.set(0)
                return True
            
            return False

        keyframes_pre: list[int] = [item for sublist in [[1 if _len(p.keyframes()) else 0 for p in node.parmTuple(f"{prm_list_affine[idx][0]}")] if prm_list_affine[idx][1] else [1 if _len(node.parm(f"{prm_list_affine[idx][0]}").keyframes()) else 0] for idx in range(len(prm_list_affine))] for item in sublist]
        collect_pre: list[tuple[float, ...] | float] = [node.parmTuple(f"{prm_list_affine[idx][0]}").eval() if prm_list_affine[idx][1] else node.parm(f"{prm_list_affine[idx][0]}").eval() for idx in range(len(prm_list_affine))]
        if 1 not in keyframes_pre and collect_pre == f3h_affineDefaults.DEFAULT_VALS:
            return True
        
        return False
    
    
    @staticmethod
    def paste_from_list_affine(node: hou.SopNode, prm_list_affine_to: tuple[tuple[str, int], ...], prm_list_affine_from: tuple[tuple[str, int], ...], id: str) -> None:
        """Paste value from the post affine into the pre affine and viceversa ( just swap  )</br>
        
        Args:
            node(hou.SopNode): FLAM3H™ node to set
            prm_list_affine_to(tuple[tuple[str, int], ...]): parameters list to query and set for the either the PRE or POST affine
            prm_list_affine_from(tuple[tuple[str, int], ...]): parameters list to query and set for the either the PRE or POST affine
            id(str): current multiparamter index
            
        Returns:
            (None):
        """    
        
        for idx, prm in enumerate(prm_list_affine_to):
            # if a tuple
            if prm[1]:
                prm_from = node.parmTuple(f"{prm[0]}{id}")
                prm_to = node.parmTuple(f"{prm_list_affine_from[idx][0]}{id}")
                prm_to.lock(False)
                prm_to.deleteAllKeyframes()
                for prm_idx, p in enumerate(prm_from):
                    keyframes: tuple[hou.Keyframe, ...] = p.keyframes()
                    dest: hou.Parm = prm_to[prm_idx]
                    if keyframes:
                        for k in keyframes:
                            dest.setKeyframe(k)
                    else:
                        dest.set(p.eval()) # type: ignore
                
            else:
                prm_from = node.parm(f"{prm[0]}{id}")
                prm_to = node.parm(f"{prm_list_affine_from[idx][0]}{id}")
                prm_to.lock(False)
                prm_to.deleteAllKeyframes()
                keyframes: tuple[hou.Keyframe, ...] = prm_from.keyframes()
                if keyframes:
                    for k in keyframes:
                        prm_to.setKeyframe(k)
                else:
                    prm_to.set(prm_from.eval()) # type: ignore
                    
                     
    @staticmethod
    def pastePRM_T_from_list(node: hou.SopNode, flam3node: hou.SopNode | None, prmT_list: tuple, varsPRM: tuple, id: str, id_from: str) -> None:
        """Paste variation parameter values</br>
        between different multiparameter indexes.</br>
        In case of a parametric variation, it will paste its parameters using:</br>
        * flam3h_iterator_utils.paste_from_list() definition.</br>
         
        Args:
            node(hou.SopNode): FLAM3H™ node to set
            flam3node(hou.SopNode | None): hou.SopNode to copy values from
            prmT_list(tuple): variations list - types
            varsPRM(tuple): variation's parmaters list
            id(str): current multiparamter index
            id_from(str): multiparameter index to copy from
            
        Returns:
            (None):
        """    
        for prm in prmT_list:
            if flam3node is not None:
                prm_from = flam3node.parm(f"{prm}{id_from}")
                prm_to = node.parm(f"{prm}{id}")
                prm_to.lock(False)
                prm_to.deleteAllKeyframes()
                flam3h_iterator_utils.paste_from_prm(prm_from, prm_to)
                # Check if this var is a parametric or not
                v_type: int = int(prm_from.eval())
                if(varsPRM[v_type][-1]):  
                    flam3h_iterator_utils.paste_from_list(node, flam3node, varsPRM[v_type][1:-1], id, id_from)
                    

    @staticmethod
    def paste_save_note(_note: str) -> str:
        """When copy/paste parameter values between different multiparameter indexes,</br>
        this will save the current note and place it into parenthesis as a form of backup.</br>
        
        Note:
            This need an upgrade/improvements at some point.
        
        Args:
            _note(str): current note in the parameter

        Returns:
            (str): simple new note append
        """

        search_iter: str = "iter."
        search_FF: str = ".FF"

        if _note.find("(") or _note.find(")") == -1:
            _note_split: list[str] = _note.split()
            if len(_note_split) > 1 and (search_iter in _note_split[-1].rpartition(search_iter) or search_FF in _note_split[-1].rpartition(search_FF)):
                note: str = f"({' '.join(_note_split[0:-1])}) "
            elif len(_note.split(".")) > 1 and ("iter" in _note.split(".") or "FF" in _note.split(".")):
                note: str = ""
            else:
                note: str = f"({_note}) "
        else:
            note: str = f"({_note[_note.find('(') + 1:_note.find(')')]}) "
            
        return note


    @staticmethod
    def paste_set_note(node: hou.SopNode, flam3node: hou.SopNode | None, int_mode: int, str_section: str, id: str, id_from: str) -> None:
        """After a copy/paste,</br>
        it will set the note parameter with a string indicating what has been pasted ( when copy/paste iterator's sections )
        
        Note:
            This need an upgrade/improvements at some point.
        
        Args:
            node (hou.SopNode): FLAM3H™ node to set
            flam3node(hou.SopNode | None): hou.SopNode to copy values from
            int_mode(int): int(0) copy/paste iterator into the same node. int(1) copy/paste FF between different nodes. int(2) copy/paste FF sections between different nodes
            str_section(str): section name string to be copied, this is only for msg print info
            id(str): current multiparamter index
            id_from(str): multiparameter index to copy from
            
        Returns:
            (None):
        """ 
        
        n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
        node_name: str = str(flam3node)
        _current_note_FF: str = node.parm("ffnote").eval()
        
        prm_iter_note_name: str = f"{n.main_note}_{id}"
        prm_ff_note_name: str = f"{f3h_ffPrmPrx.PRM}{n.main_note}"

        if int_mode == 0:
            _current_note: str = node.parm(f"note_{id}").eval()
            # If on the same FLAM3H™ node
            if node == flam3node:
                if len(_current_note) == 0:
                    prm_iter_note_val: str = f"iter.{id_from}{str_section}"
                    flam3h_prm_utils.set(node, prm_iter_note_name, prm_iter_note_val)
                else:
                    prm_iter_note_val: str = f"{flam3h_iterator_utils.paste_save_note(_current_note)}iter.{id_from}{str_section}"
                    flam3h_prm_utils.set(node, prm_iter_note_name, prm_iter_note_val)
                _MSG: str = f"{node.name()}.iter.{id}{str_section} -> Copied values from: iter.{id_from}{str_section}"
                flam3h_general_utils.set_status_msg(_MSG, 'IMP')
            else:
                if len(_current_note) == 0:
                    prm_iter_note_val: str = f"{node_name}.iter.{id_from}{str_section}"
                    flam3h_prm_utils.set(node, prm_iter_note_name, prm_iter_note_val)
                else:
                    prm_iter_note_val: str = f"{flam3h_iterator_utils.paste_save_note(_current_note)}{node_name}.iter.{id_from}{str_section}"
                    flam3h_prm_utils.set(node, prm_iter_note_name, prm_iter_note_val)
                _MSG: str = f"{node.name()}.iter.{id}{str_section} -> Copied values from: {node_name}.iter.{id_from}{str_section}"
                flam3h_general_utils.set_status_msg(_MSG, 'IMP')
        elif int_mode == 1:
            if node != flam3node:
                if len(_current_note_FF) == 0:
                    prm_ff_note_val: str = f"{node_name}.FF"
                    flam3h_prm_utils.set(node, prm_ff_note_name, prm_ff_note_val)
                else:
                    prm_ff_note_val: str = f"{flam3h_iterator_utils.paste_save_note(_current_note_FF)}{node_name}.FF"
                    flam3h_prm_utils.set(node, prm_ff_note_name, prm_ff_note_val)
                _MSG: str = f"{node.name()} -> Copied FF from: {node_name}.FF"
                flam3h_general_utils.set_status_msg(_MSG, 'IMP')
        elif int_mode == 2:
            if node != flam3node:
                if len(_current_note_FF) == 0:
                    prm_ff_note_val: str = f"{node_name}.FF{str_section}"
                    flam3h_prm_utils.set(node, prm_ff_note_name, prm_ff_note_val)
                else:
                    prm_ff_note_val: str = f"{flam3h_iterator_utils.paste_save_note(_current_note_FF)}{node_name}.FF{str_section}"
                    flam3h_prm_utils.set(node, prm_ff_note_name, prm_ff_note_val)
                _MSG: str = f"{node.name()}.FF{str_section} -> Copied from: {node_name}.FF{str_section}"
                flam3h_general_utils.set_status_msg(_MSG, 'IMP')


    @staticmethod
    def auto_set_xaos_div_str(node: hou.SopNode) -> tuple[str, str]:
        """Return the proper prefix xaos strings to use based on the value of: PREFS_PVT_XAOS_AUTO_SPACE</br>

        Args:
            node(hou.SopNode): this FLAM3H™ node.
            
        Returns:
            (tuple[str, str]): div_xaos: str, div_weight: str
        """
        div_xaos: str = 'xaos:'
        div_weight: str = ':'
        
        autodiv: int = node.parm(f3h_tabs.PREFS.PVT_PRM_XAOS_AUTO_SPACE).eval()
        if autodiv:
            div_xaos = 'xaos :'
            div_weight = ' :'
            
        return div_xaos, div_weight


    @staticmethod
    def auto_set_xaos_data_get_MP_MEM(node: hou.SopNode) -> list[int] | None:
        """Retrieve the desire data from FLAM3H™ data srting parameters</br>
    and reconvert it back to usable types.</br>

        Args:
            node(hou.SopNode): FLAM3H™ node 

        Returns:
            (list | None): A valid data type of the same data retrieved to be used inside: auto_set_xaos()
        """
        get_prm: str = node.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_XAOS_MP_MEM).eval()
        if get_prm:
            return [int(x) for x in get_prm.split(' ')]
        
        return None
        
        
    @staticmethod
    def auto_set_xaos_data_get_XAOS_PREV(node: hou.SopNode) -> list[list[str]] | None:
        """Retrieve the desire data from FLAM3H™ data srting parameters</br>
    and reconvert it back to usable types.</br>

        Args:
            node(hou.SopNode): FLAM3H™ node

        Returns:
            (list | None): A valid data type of the same data retrieved to be used inside: auto_set_xaos()
        """
        get_prm: str = node.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_XAOS_PREV).eval()
        if get_prm:
            return [x.split(' ') for x in get_prm.split(':')]
        
        return None
        

    @staticmethod
    def auto_set_xaos_data_set_MP_MEM(node: hou.SopNode, data: list | tuple) -> None:
        """Set the data_name data into FLAM3H™ data parameters.</br>
        Note that all the data will be of type: string.</br>

        Note:
            This parameter has been swapped for a label message parameter so the lock/unlock is not necessary anymore.
            However, is not causing any problem and I leave it here for now.

        Args:
            data (list | tuple): The actual data to set.

        Returns:
            (None):
        """
        data_to_prm: str = ' '.join([str(x) for x in data])
        flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_DATA_PRM_XAOS_MP_MEM, data_to_prm)
                

    @staticmethod
    def auto_set_xaos_data_set_XAOS_PREV(node: hou.SopNode, data: list | tuple) -> None:
        """Set the data_name data into FLAM3H™ data parameters.</br>
    Note that all the data will be of type: string.</br>

        Args:
            node(hou.SopNode): The FLAM3H™ node
            data(list | tuple): The actual data to set. A tuple can only come from: out_flame_utils.out_xf_xaos_from(self, mode=0) -> tuple:

        Returns:
            (None):
        """
        # to prm from: flam3_xaos_convert()
        if isinstance(data, tuple):
            data_to_prm: str = ':'.join(data)
            # set
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_DATA_PRM_XAOS_PREV, data_to_prm)
            
        else:
            _join: Callable[[Iterable[str]], str] = ' '.join
            data_to_prm: str = ':'.join([_join(xaos) for xaos in data])
            # set
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_DATA_PRM_XAOS_PREV, data_to_prm)
            
            
    @staticmethod
    def flam3h_on_load_opacity_zero(node: hou.SopNode, f3h_all: bool = False) -> None:
        """Check each iterator's shader opacity and if any of them is 0(Zero) activate the Remove Invalid Option(RIP)

        Args:
            node(hou.SopNode): The current FLAM3H™ node being loaded in the hip file.
            f3h_all(bool): Default to: False</br>Perform this check and correct if needed for all FLAM3H™ nodes in the scene.

        Returns:
            (None):
        """  
        iter_count: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        if iter_count:
            shader_alpha_name: str = flam3h_iterator_prm_names().shader_alpha
            if f3h_all:
                for f3h in node.type().instances():
                    f3h_all_lambda_min_opacity: Callable[[], float] = lambda: min((f3h.parm(f'{shader_alpha_name}_{idx}').eval() for idx in range(1, iter_count + 1)))
                    try:
                        if not f3h.parm(f3h_tabs.PREFS.PVT_PRM_RIP).eval() and f3h_all_lambda_min_opacity() == 0: # This is the one that can possibly fail
                            flam3h_prm_utils.private_prm_set(f3h, f3h_tabs.PREFS.PVT_PRM_RIP, 1)
                    except AttributeError:
                        pass
            else:
                lambda_min_opacity: Callable[[], float] = lambda: min((node.parm(f'{shader_alpha_name}_{idx}').eval() for idx in range(1, iter_count + 1)))
                if lambda_min_opacity() == 0: flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_RIP, 1)


    @staticmethod
    def destroy_cachedUserData(node, data: str, must_exist: bool = False) -> None:
        """Destroy cached user data.</br>
        This is to be run also as a callback script inside parms that are responsible to update some menus,</br>
        For now inside: Iterator shader's opacity -> calback script</br>
        
        So far the cached user data names being used are inside:</br>
        
        * class <b>f3h_cachedUserData</b>
            
        Args:
            node(hou.SopNode): FLAM3H™ node
            data(str): the name of the data to destroy
            must_exist(bool): Default to: False</br>Destroy data will run silently if the data name do not exist. Set it to True to get an error.

        Returns:
            (None):
        """
        if not must_exist:
            try:
                node.destroyCachedUserData(data)
            except hou.OperationFailed:
                pass
        else:
            node.destroyCachedUserData(data)
        
        
    @staticmethod
    def destroy_cachedUserData_all_f3h(node, data_name: str) -> None:
        """Destroy cached user data an all FLAM3H™ node in the current Houdini session.

        Args:
            node(hou.SopNode): The current FLAM3H™ node being loaded in the hip file.
            data_name(str): The name of the data to destroy.

        Returns:
            (None):
        """  
        for f3h in node.type().instances():
            assert isinstance(f3h, hou.SopNode)
            data: Any | None = f3h.cachedUserData(data_name)
            if data is not None: flam3h_iterator_utils.destroy_cachedUserData(f3h, data_name)
            
            
    @staticmethod
    def destroy_userData(node, data: str, must_exist: bool = False) -> None:
        """Destroy user data.
        
        So far the user data names being used are:
        
        * nodeinfo_Marked iterator -> f"{f3h_userData.PRX}_{f3h_userData.MARKED_ITER}
        * nodeinfo_Marked FF -> f"{f3h_userData.PRX}_{f3h_userData.MARKED_FF}
        * nodeinfo_XF VIZ -> f"{f3h_userData.PRX}_{f3h_userData.XFVIZ_SOLO}
        * XML_last_loaded -> f"{f3h_userData.XML_LAST}"

        Args:
            node(hou.SopNode): This FLAM3H™ node
            data(str): The name of the data to retrieve
            must_exist(bool): Default to: False</br>When True it will throw an error if the data do not exist, other will it will silently pass.
            
            
        Returns:
            (None):
        """
        if not must_exist:
            try:
                node.destroyUserData(data)
            except hou.OperationFailed:
                pass
        else:
            node.destroyUserData(data)
        
        
    @staticmethod
    def force_menu_var_update_FF(node: hou.SopNode) -> None:
        """Refresh/Force the iterator FF variation's menus to update.

        Args:
            (node): the FLAM3H™ node
            
        Returns:
            (None):
        """  
        n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
        prm_names: tuple[str, ...] = (f"{f3h_ffPrmPrx.PRM}{n.prevar_type_1}", 
                                    f"{f3h_ffPrmPrx.PRM}{n.var_type_1}",
                                    f"{f3h_ffPrmPrx.PRM}{n.var_type_2}",
                                    f"{f3h_ffPrmPrx.PRM}{n.postvar_type_1}",
                                    f"{f3h_ffPrmPrx.PRM}{n.postvar_type_2}")
        for name in prm_names: node.parm(name).pressButton()


    @staticmethod
    def menu_T_get_type_icon(w: float) -> str:
        """Return the proper bookmark icon to use in the menu label for the selected variation and weight.</br>
        This is to be used for the VAR section in the iterator (FLAME and FF tabs) 

        Args:
            w(float): the variation weight to derive the proper bookmark icon to use.
            
        Returns:
            (str): The full path of the bookmark icon to use in the menu based on this variation weight value.
        """
        if w > 1:
            return f3h_icons.STAR_FLAME_VAR_ACTV_OVER_ONE
        elif w > 0:
            return f3h_icons.STAR_FLAME_VAR_ACTV
        elif w < 0:
            return f3h_icons.STAR_FLAME_VAR_ACTV_NEGATIVE
        else:
            return f3h_icons.STAR_EMPTY_OPACITY

    @staticmethod
    def menu_T_PP_get_type_icon(w: float) -> str:
        """Return the proper bookmark icon to use in the menu label for the selected PRE or POST variation and weight.</br>
        This is to be used for the PRE and POST sections in the iterator (FLAME and FF tabs) 

        Args:
            w(float): the variation weight to derive the proper bookmark icon to use.
            
        Returns:
            (str): The full path of the bookmark icon to use in the menu based on this variation weight value.
        """
        if w > 1:
            return f3h_icons.STAR_FLAME_VAR_PP_ACTV_OVER_ONE
        elif w > 0:
            return f3h_icons.STAR_FLAME_VAR_PP_ACTV
        return f3h_icons.STAR_EMPTY_OPACITY


    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @property
    def kwargs(self) ->  dict[str, Any]:
        return self._kwargs
        
    @property
    def node(self) -> hou.SopNode:
        return self._node
    
    
    def iterator_affine_scale(self) -> None:
        """Scale the affine X and Y of an amount.</br>
        The default value is: 1 whitch mean 100% and so no scale.</br>
        Once changed it will scale the affine values and reset itself back to being: 1</br>
        For example if you type a value of: 1.2, it will scale the affine up by 20%.</br>
        It is an initial test, and it may or may not change/improve with time.

        Args:
            (self):

        Returns:
            (None):
        """  
        s_mp_index: int = self.kwargs['script_multiparm_index']
        scl_prm: hou.Parm = self.kwargs['parm']
        scl_prm.deleteAllKeyframes() # This parameter can not be animated
        
        scl: float = scl_prm.eval()
        prm_x: hou.ParmTuple = hou.parmTuple(f"x_{s_mp_index}")
        prm_y: hou.ParmTuple = hou.parmTuple(f"y_{s_mp_index}")
        x: tuple[float, ...] = prm_x.eval()
        y: tuple[float, ...] = prm_y.eval()
        m2_new: tuple[tuple[float, ...], ...] = (hou.Matrix2((x, y)) * hou.Matrix2(((scl, 0), (0, scl)))).asTupleOfTuples()
        for idx, prm in enumerate((prm_x, prm_y)):
            prm.lock(False)
            prm.set(hou.Vector2(m2_new[idx])) # type: ignore

        # Reset to no-scale value (1 being 100%)
        scl_prm.set(1) # type: ignore
        
        
    def iterator_post_affine_scale(self) -> None:
        """Scale the affine X and Y of an amount.</br>
        The default value is: 1 whitch mean 100% and so no scale.</br>
        Once changed it will scale the affine values and reset itself back to being: 1</br>
        For example if you type a value of: 1.2, it will scale the affine up by 20%.</br>
        The best way to use it is to click in the numeric field and use the mouse wheel to scale up and down.</br>
        Holding [SHIFT] will scale with an increment of: 0.01
        
        It is an initial test, and it may or may not change/improve with time.

        Args:
            (self):
            
        Returns:
            (None):
        """  
        s_mp_index: int = self.kwargs['script_multiparm_index']
        scl_prm: hou.Parm = self.kwargs['parm']
        scl_prm.deleteAllKeyframes() # This parameter can not be animated
        
        scl: float = scl_prm.eval()
        prm_px: hou.ParmTuple = hou.parmTuple(f"px_{s_mp_index}")
        prm_py: hou.ParmTuple = hou.parmTuple(f"py_{s_mp_index}")
        x: tuple[float, ...] = prm_px.eval()
        y: tuple[float, ...] = prm_py.eval()
        m2_new: tuple[tuple[float, ...], ...] = (hou.Matrix2((x, y)) * hou.Matrix2(((scl, 0), (0, scl)))).asTupleOfTuples()
        for idx, prm in enumerate((prm_px, prm_py)):
            prm.lock(False)
            prm.set(hou.Vector2(m2_new[idx])) # type: ignore

        # Reset to no-scale value (1 being 100%)
        scl_prm.set(1) # type: ignore
        
        
    def iterator_FF_affine_scale(self) -> None:
        """Scale the affine X and Y of an amount.</br>
        The default value is: 1 whitch mean 100% and so no scale.</br>
        Once changed it will scale the affine values and reset itself back to being: 1</br>
        For example if you type a value of: 1.2, it will scale the affine up by 20%.</br>
        It is an initial test, and it may or may not change/improve with time.

        Args:
            (self):
            
        Returns:
            (None):
        """  
        scl_prm: hou.Parm = self.kwargs['parm']
        scl_prm.deleteAllKeyframes() # This parameter can not be animated
        
        scl: float = scl_prm.eval()
        prm_x: hou.ParmTuple = hou.parmTuple("ffx")
        prm_y: hou.ParmTuple = hou.parmTuple("ffy")
        x: tuple[float, ...] = prm_x.eval()
        y: tuple[float, ...] = prm_y.eval()
        m2_new: tuple[tuple[float, ...], ...] = (hou.Matrix2((x, y)) * hou.Matrix2(((scl, 0), (0, scl)))).asTupleOfTuples()
        for idx, prm in enumerate((prm_x, prm_y)):
            prm.lock(False)
            prm.set(hou.Vector2(m2_new[idx])) # type: ignore

        # Reset to no-scale value (1 being 100%)
        scl_prm.set(1) # type: ignore
        
        
    def iterator_FF_post_affine_scale(self) -> None:
        """Scale the affine X and Y of an amount.</br>
        The default value is: 1 whitch mean 100% and so no scale.</br>
        Once changed it will scale the affine values and reset itself back to being: 1</br>
        For example if you type a value of: 1.2, it will scale the affine up by 20%.</br>
        It is an initial test, and it may or may not change/improve with time.

        Args:
            (self):
            
        Returns:
            (None):
        """  
        scl_prm: hou.Parm = self.kwargs['parm']
        scl_prm.deleteAllKeyframes() # This parameter can not be animated
        
        scl: float = scl_prm.eval()
        prm_px: hou.ParmTuple = hou.parmTuple("ffpx")
        prm_py: hou.ParmTuple = hou.parmTuple("ffpy")
        x: tuple[float, ...] = prm_px.eval()
        y: tuple[float, ...] = prm_py.eval()
        m2_new: tuple[tuple[float, ...], ...] = (hou.Matrix2((x, y)) * hou.Matrix2(((scl, 0), (0, scl)))).asTupleOfTuples()
        for idx, prm in enumerate((prm_px, prm_py)):
            prm.lock(False)
            prm.set(hou.Vector2(m2_new[idx])) # type: ignore
        
        # Reset to no-scale value (1 being 100%)
        scl_prm.set(1) # type: ignore

        
    def destroy_all_menus_data(self, node: hou.SopNode, f3h_all: bool = False) -> None:
        """Force all presets menus to update.</br>
        This is being added so we can force the presets menus to be rebuilt</br>
        everywhere we need to help keep them up to date in case the user</br>
        make any hand made modifications to the loaded files.

        Args:
            (self):
            node(hou.SopNode): The FLAM3H™ node.
            f3h_all(bool): Default to: False</br>Perform this for all FLAM3H™ nodes in the scene.
            
        Returns:
            (None):
        """  
        
        # Names of the cachedUserData
        data_names: tuple[str, ...] = (f3h_cachedUserData.cp_presets_menu, f3h_cachedUserData.cp_presets_menu_off, f3h_cachedUserData.in_presets_menu, f3h_cachedUserData.in_presets_menu_off, f3h_cachedUserData.out_presets_menu)
        
        if f3h_all:
            f3h_instances: tuple[hou.SopNode, ...] = node.type().instances()
            for f3h in f3h_instances:
                for name in data_names:
                    self.destroy_cachedUserData(f3h, name)
        else:
            for name in data_names: self.destroy_cachedUserData(node, name)
            

    def update_xml_last_loaded(self, menu_update: bool = True) -> None:
        """Force node user data "XML_last_loaded" to update.</br>
        It will update only if: xml and xml_isFile and xml == xml_history and inisvalidfile and inisvalidpreset and not clipboard</br></br>
        
        This definition is being run in several places to try to catch a change sooner than later.</br>
        
        Below is a list:

        * def flam3h_on_loaded(self) -> None:
        * def flam3h_on_deleted(self) -> None:
        * def menus_refresh_enum_prefs(self) -> None:
        * def flam3h_init_presets_CP_PRESETS(self, mode: int = 1, destroy_menus: bool = True, json_file: bool | None = None, f3h_json_file: bool | None = None, json_path_checked: str | bool | None = None) -> None:
        * def flam3h_init_presets_IN_PRESETS(self, mode: int = 1) -> None:
        * def flam3h_init_presets_OUT_PRESETS(self, destroy_menus: bool = True) -> None:
        * def refresh_iterator_vars_menu(self) -> None:
        * def menu_global_density_set(self) -> None:
        * def menu_global_density_set_default(self) -> None:
        * def prm_paste(self) -> None:
        * def prm_paste_FF_CTRL(self) -> None:
        * def prm_paste_sel_pre_affine(self) -> None:
        * def prm_paste_sel_post_affine(self) -> None:
        * def prm_paste_sel_pre_affine_FF(self) -> None:
        * def prm_paste_sel_post_affine_FF(self) -> None:
        * def flam3h_xaos_convert(self) -> None:
        * def swap_iter_pre_vars(self) -> None:
        * def iterators_count_not_zero(self, node: hou.SopNode) -> None:
        * def flam3h_ramp_save(self) -> None:
        * def json_to_flam3h_ramp_SET_PRESET_DATA(self, node: hou.SopNode) -> None:
        * def json_to_flam3h_ramp(self, use_kwargs: bool = True) -> None:
        * def ui_xaos_infos(self) -> None:
        * def in_copy_render_all_stats_msg(kwargs: dict,  apo_data: in_flame_iter_data | None = None, clipboard: bool = False, flash_message: bool = False) -> None:
        * def in_copy_sensor_stats_msg(kwargs: dict) -> None:
        * def in_copy_render_stats_msg(kwargs: dict) -> None:
        * def reset_OUT_kwargs(self) -> None:
        * def out_XML(self) -> None:
            
        Args:
            (self):
            menu_update(bool): Default to: True</br>If False, it will NOT force the IN and OUT tab presets menus to update.</br></br>Useful when coupled with:</br>def destroy_all_menus_data(self, node: hou.SopNode, f3h_all: bool = False) -> None: </br>(So not to force an update twice)
            
        Returns:
            (None):
        """  
            
        node: hou.SopNode = self.node
        
        # Updated the "XML_last_loaded" user data if there is a need to do so:
        inisvalidfile: int = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_FILE).eval()
        inisvalidpreset: int = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval()
        clipboard: int = node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval()
        xml: str = os.path.expandvars(node.parm(f3h_tabs.IN.PRM_PATH).eval())
        xml_isFile: bool = os.path.isfile(xml) if xml else False
        xml_history: str | None = node.cachedUserData(f3h_cachedUserData.in_presets_filepath)
        # Only if a valid preset has been loaded from a disk file ( not clipboard )
        if xml and xml_isFile and xml == xml_history and inisvalidfile and inisvalidpreset and not clipboard:
            
            # Build the apo data
            preset_id: int = int(node.parm(f3h_tabs.IN.PRM_PRESETS).eval())
            apo_data: in_flame_iter_data = in_flame_iter_data(node, xml, preset_id)
            if apo_data.isvalidtree:
                
                old_data: str | None = node.userData(f3h_userData.XML_LAST)
                now_data: str = lxmlET.tostring(apo_data.flame[preset_id], encoding="unicode")
                now_data_isvalid = _xml_tree(now_data).isvalidtree
                if old_data is not None and old_data != now_data and now_data_isvalid:
                    
                    if menu_update:
                        # Update IN presets menus.
                        # This just in case the changes are made to the currently loaded Flame preset name so those menus are up to date too.
                        self.destroy_cachedUserData(node, f3h_cachedUserData.in_presets_menu)
                        self.destroy_cachedUserData(node, f3h_cachedUserData.in_presets_menu_off)
                        # If the same Flame preset file is currently open also inside the OUT tab, force to update its presets menus as well for the same reason.
                        if node.parm(f3h_tabs.OUT.PVT_PRM_ISVALID_FILE).eval() and node.cachedUserData(f3h_cachedUserData.in_presets_filepath) == node.cachedUserData(f3h_cachedUserData.out_presets_filepath):
                            self.destroy_cachedUserData(node, f3h_cachedUserData.out_presets_menu)
                
                    # Update user data
                    node.setUserData(f3h_userData.XML_LAST, now_data)
                    # Update flame stats                    
                    parms_dict: dict = {f3h_tabs.IN.MSG_PRM_FLAMESTATS: in_flame_utils(self.kwargs).in_load_stats_msg(preset_id, apo_data, bool(clipboard), True), 
                                        f3h_tabs.IN.MSG_PRM_FLAMESENSOR: in_flame_utils.in_load_sensor_stats_msg(preset_id, apo_data, True), 
                                        f3h_tabs.IN.MSG_PRM_FLAMERENDER: in_flame_utils.in_load_render_stats_msg(preset_id, apo_data, True)}
                    flam3h_prm_utils.setParms(node, parms_dict)

                    _MSG_ALL = f"\"XML_last_loaded\" user data: Updated\n\nThe currently loaded IN Preset: \"{apo_data.name[preset_id]}\"\nhas been modified on disk. Reload the preset to update.\n\n-> Meanwhile,\nthe IN flame preset infos have been updated\nas well as its render properties infos."
                    _MSG_UI = f"The currently loaded IN Preset: \"{apo_data.name[preset_id]}\"\nhas been modified on disk."
                    hou.ui.displayMessage(_MSG_UI, buttons=("Got it, thank you",), severity = hou.severityType.ImportantMessage, default_choice = 0, close_choice = -1, help = None, title = "FLAM3H™ IN flame file modified", details = _MSG_ALL, details_label = None, details_expanded = False) # type: ignore
                    
                else:
                    if old_data is None:
                        _MSG: str = f"\"XML_last_loaded\" user data: Corrupted"
                        print(f"\n-> {datetime.now().strftime('%b-%d-%Y %H:%M:%S')}\n{node.name()}: {_MSG}")
                    elif not now_data_isvalid:
                        _MSG: str = f"\"XML loaded preset\" data: Corrupted"
                        print(f"\n-> {datetime.now().strftime('%b-%d-%Y %H:%M:%S')}\n{node.name()}: {_MSG}")
            
            else:
                # Fire messages
                _MSG: str = f"\"XML_last_loaded\" user data: Failed"
                print(f"{node.name()}: {_MSG}.\n")


    def refresh_iterator_vars_menu(self) -> None:
        """Refresh the iterator (FLAME and FF tabs) menus to update to the new menu style mode.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """  
        node: hou.SopNode = self.node
        _MSG_PRX: str = "Iterator var menus:"
        
        # Reset/Set density
        flam3h_general_utils.reset_density(node)
        # For some reasons the FF menus did not update so we force them to just in case
        self.force_menu_var_update_FF(node)
        # Change focus back to the FLAME's Tab
        flam3h_prm_utils.set(node, f3h_tabs.PRM_ITERATORS_TAB, (0,))
        # Check and Update this data
        self.update_xml_last_loaded()
        
        if not self.node.parm(f3h_tabs.PREFS.PRM_ITERATOR_BOOKMARK_ICONS).eval():
            
            # In H21.0.440 and UP the following is not needed anymore,
            # and we get the benefit of keeping the copy/paste marked iterator/FF data running smooth while switching modes.
            '''
            # Reset memory mpidx prm data
            flam3h_iterator_utils.iterator_mpidx_mem_set(node, 0)
            
            # Remove any comment and user data from the node
            if self.exist_user_data(node):
                self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                self.del_comment_and_user_data_iterator(node)
                hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = None # type: ignore
                hou.session.F3H_MARKED_ITERATOR_NODE: TA_MNode = None # type: ignore
            if self.exist_user_data(node, f3h_userData.MARKED_FF):
                self.del_comment_and_user_data_iterator(node, f3h_userData.MARKED_FF)
                hou.session.F3H_MARKED_FF_NODE: TA_MNode = None # type: ignore
                hou.session.F3H_MARKED_FF_CHECK: TA_M = None # type: ignore
            
            # This is the only way I found to update the FLAME tab multiparameter's menus, for now...
            node.type().definition().updateFromNode(node)
            node.matchCurrentDefinition()
            '''
            
            _MSG: str = f"{_MSG_PRX} SIMPLE"
            flam3h_general_utils.flash_message(node, f"{_MSG}")
            flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
            
        else:
            # We do not need this data anymore if we are using BOOKMARK ICONS
            self.destroy_cachedUserData(node, f3h_cachedUserData.vars_menu_all_simple)
            
            _MSG: str = f"{_MSG_PRX} ICONS"
            flam3h_general_utils.flash_message(node, f"{_MSG}")
            flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'IMP')
        

    def destroy_data_note(self) -> None:
        """Update mini-menu iterator selection when we modify this parameter.</br>
        and provide a default name if no string in a FLAME tab iterator note parameter is left.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """  
        node: hou.SopNode = self.node
        self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
        prm = self.kwargs['parm']
        s_mp_index: int = self.kwargs['script_multiparm_index']
        if not prm.eval():
            prm.set(f"iterator_{s_mp_index}")
        else:
            prm.set(str(prm.eval()).strip())
            
            
    def note_FF(self) -> None:
        """Provide a default name if no string in the FF tab note parameter is left.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """  
        prm = self.kwargs['parm']
        if not prm.eval():
            prm.set(f"iterator_FF")
        else:
            prm.set(str(prm.eval()).strip())
            
        
    def menu_T_get_var_data(self) -> tuple[int, float]:
        """Get this menu variation type idx and its weight value.</br>
        
        Args:
            (self):

        Returns:
            (tuple[int, float]): int: variation idx.    float: weight value
        """  
        prm: hou.Parm = self.kwargs['parm']
        s_mp_index: int = self.kwargs['script_multiparm_index']
        _TYPE: int = prm.evalAsInt() # this can be animated with inbetween values so we always force cast it as int()
        _W: float = self.node.parm(f"{f3h_tabs.PRM_FLAME_TAB_MENU_T_W_MATCH[prm.name()[:-len(str(s_mp_index))]]}{s_mp_index}").eval()
        return _TYPE, _W
    
    
    def menu_T_FF_get_var_data(self) -> tuple[int, float]:
        """Get this FF menu variation type idx and its weight value.</br>
        
        Args:
            (self):

        Returns:
            (tuple[int, float]): int: variation idx.    float: weight value
        """  
        prm: hou.Parm = self.kwargs['parm']
        _TYPE: int = prm.evalAsInt() # this can be animated with inbetween values so we always force cast it as int()
        _W: float = self.node.parm(f3h_tabs.PRM_FF_TAB_MENU_T_W_MATCH[prm.name()]).eval()
        return _TYPE, _W

    
    def menu_T_data(self) -> tuple[int, str]:
        """Rerturn the selected variation index and the correct bookmark icon to use</br>
        based on its weight value.</br>
        
        Args:
            (self):
            
        Returns:
            (tuple[int, str]): int: variation idx.    str: icon
        """
        _TYPE, w = self.menu_T_get_var_data()
        return _TYPE, self.menu_T_get_type_icon(w)


    def menu_T_PP_data(self) -> tuple[int, str]:
        """Rerturn the selected variation index and the correct bookmark icon to use</br>
        based on its weight value.</br>
        
        Args:
            (self):

        Returns:
            (tuple[int, str]): int: variation idx.    str: icon
        """
        _TYPE, w = self.menu_T_get_var_data()
        return _TYPE, self.menu_T_PP_get_type_icon(w)
    
    
    def menu_T_FF_data(self) -> tuple[int, str]:
        """Rerturn the selected FF variation index and the correct bookmark icon to use</br>
        based on its weight value.</br>
        
        Args:
            (self):

        Returns:
            (tuple[int, str]): int: variation idx.    str: icon
        """
        _TYPE, w = self.menu_T_FF_get_var_data()
        return _TYPE, self.menu_T_get_type_icon(w)
    
    
    def menu_T_PP_FF_data(self) -> tuple[int, str]:
        """Rerturn the selected FF variation index and the correct bookmark icon to use</br>
        based on its weight value.</br>
        
        Args:
            (self):

        Returns:
            (tuple[int, str]): int: variation idx.    str: icon
        """
        _TYPE, w = self.menu_T_FF_get_var_data()
        return _TYPE, self.menu_T_PP_get_type_icon(w)
    
    
    def menu_T_pb_data(self) -> str:
        """Rerturn the bookmark icon to use for the Pre blur variation</br>
        based on its weight value.</br>
        
        Args:
            (self):

        Returns:
            (str): str: icon
        """
        s_mp_index: int = self.kwargs['script_multiparm_index']
        prm_weight_name: str = f"{flam3h_iterator_prm_names().prevar_weight_blur}_{s_mp_index}"

        w: float = self.node.parm(prm_weight_name).eval()

        if w > 1:
            return f3h_icons.STAR_FLAME_VAR_PP_ACTV_OVER_ONE
        elif w > 0:
            return f3h_icons.STAR_FLAME_VAR_PP_ACTV
        return f3h_icons.STAR_EMPTY_OPACITY
    
    
    def menu_T_ICON(self) -> TA_Menu:
        """Populate variation names parameter menu list and add proper bookmark icons based on their weights.</br>
        
        Note:
            When changing weight's value, the bookmark icon will updated too
            but it wont updated when we click the menu parameter to see all its entries until we dnt make a new selection.
            Not sure if this is to be considered a bug or is intended, perhaps I should note this to SideFx.
            
        Args:
            (self):

        Returns:
            (TA_Menu): return menu list
        """
        if self.node.parmTuple(f3h_tabs.PRM_ITERATORS_TAB).eval() != (0,):
            return []
        
        _TYPE, _ICON = self.menu_T_data()
        var: int | None = f3h_menus.VARS_ALL_INDEXES.get(_TYPE)
        if var is not None:
            menu: TA_Menu = copy(f3h_menus.VARS_ALL_SIMPLE)
            menu[var] = f"{_ICON} {str(menu[var])[:20]}"
            return menu

        return f3h_menus.VARS_ALL_SIMPLE
    
    
    def menu_T_ICON_FF(self) -> TA_Menu:
        """Populate FF variation names parameter menu list and add proper bookmark icons based on their weights.</br>
        
        Note:
            When changing weight's value, the bookmark icon will updated too
            but it wont updated when we click the menu parameter to see all its entries until we dnt make a new selection.
            Not sure if this is to be considered a bug or is intended, perhaps I should note this to SideFx.
            
        Args:
            (self):

        Returns:
            (TA_Menu): return menu list
        """
        
        _TYPE, _ICON = self.menu_T_FF_data()
        var: int | None = f3h_menus.VARS_ALL_INDEXES.get(_TYPE)
        if var is not None:
            menu: TA_Menu = copy(f3h_menus.VARS_ALL_SIMPLE)
            menu[var] = f"{_ICON} {str(menu[var])[:20]}"
            return menu

        return f3h_menus.VARS_ALL_SIMPLE

    def menu_T_PP_ICON(self) -> TA_Menu:
        """Populate variation names parameter menu list and add proper bookmark icons based on their weights.</br>
        
        Note:
            When changing weight's value, the bookmark icon will updated too
            but it wont updated when we click the menu parameter to see all its entries until we dnt make a new selection.
            Not sure if this is to be considered a bug or is intended, perhaps I should note this to SideFx.
            
        Args:
            (self):

        Returns:
            (TA_Menu): return menu list
        """
        if self.node.parmTuple(f3h_tabs.PRM_ITERATORS_TAB).eval() != (0,):
            return []
        
        _TYPE, _ICON = self.menu_T_PP_data()
        var: int | None = f3h_menus.VARS_ALL_INDEXES.get(_TYPE)
        if var is not None:
            menu: TA_Menu = copy(f3h_menus.VARS_ALL_SIMPLE)
            menu[var] = f"{_ICON} {str(menu[var])[:20]}"
            return menu

        return f3h_menus.VARS_ALL_SIMPLE
    

    def menu_T_PP_ICON_FF(self) -> TA_Menu:
        """Populate FF variation names parameter menu list and add proper bookmark icons based on their weights.</br>
        
        Note:
            When changing weight's value, the bookmark icon will updated too
            but it wont updated when we click the menu parameter to see all its entries until we dnt make a new selection.
            Not sure if this is to be considered a bug or is intended, perhaps I should note this to SideFx.
            
        Args:
            (self):

        Returns:
            (TA_Menu): return menu list
        """
        
        _TYPE, _ICON = self.menu_T_PP_FF_data()
        var: int | None = f3h_menus.VARS_ALL_INDEXES.get(_TYPE)
        if var is not None:
            menu: TA_Menu = copy(f3h_menus.VARS_ALL_SIMPLE)
            menu[var] = f"{_ICON} {str(menu[var])[:20]}"
            return menu

        return f3h_menus.VARS_ALL_SIMPLE
    

    def menu_T_simple(self) -> TA_Menu:
        """Populate variation names parameter menu list.</br>
        
        Args:
            (self):
            FF(bool): Default to: False</br>If true it will signal we are looking to deal with data for the FF(finalXform). In this specific definition this arg is present only for consistency.
            
        Returns:
            (TA_Menu): return menu list
        """
        self.node.setCachedUserData(f3h_cachedUserData.vars_menu_all_simple, f3h_menus.VARS_ALL_SIMPLE)
        return f3h_menus.VARS_ALL_SIMPLE

    
    def menu_T(self) -> TA_Menu:
        """Populate variation names parameter menu list.</br>
            
        Note:
            When changing a weight's value, the bookmark icon updates immediately.
            However, it will not refresh when opening the parameter menu until a new
            selection is made. It's unclear if this is intended behavior or a bug —
            consider reporting this to SideFX.

        Args:
            (self):
            
        Returns:
            (TA_Menu): return menu list
        """
        # node: hou.SopNode = self.node

        # This data get created inside: menu_T_simple(self) -> TA_Menu:
        # This data get destroyed inside: refresh_iterator_vars_menu(self) -> None:
        data: TA_Menu | None = self._node.cachedUserData(f3h_cachedUserData.vars_menu_all_simple)
        if data is not None: return data

        use_icons: int = self._node.parm(f3h_tabs.PREFS.PRM_ITERATOR_BOOKMARK_ICONS).eval()
        return (self.menu_T_simple, self.menu_T_ICON)[use_icons]()
    
    
    def menu_T_FF(self) -> TA_Menu:
        """Populate FF variation names parameter menu list.</br>
            
        Note:
            When changing a weight's value, the bookmark icon updates immediately.
            However, it will not refresh when opening the parameter menu until a new
            selection is made. It's unclear if this is intended behavior or a bug —
            consider reporting this to SideFX.

        Args:
            (self):
            
        Returns:
            (TA_Menu): return menu list
        """
        # node: hou.SopNode = self.node
        
        # This data get created inside: menu_T_simple(self) -> TA_Menu:
        # This data get destroyed inside: refresh_iterator_vars_menu(self) -> None:
        data: TA_Menu | None = self._node.cachedUserData(f3h_cachedUserData.vars_menu_all_simple)
        if data is not None: return data

        use_icons: int = self._node.parm(f3h_tabs.PREFS.PRM_ITERATOR_BOOKMARK_ICONS).eval()
        return (self.menu_T_simple, self.menu_T_ICON_FF)[use_icons]()

    
    def menu_T_PP(self) -> TA_Menu:
        """Populate variation names parameter menu list.</br>
        
        Note:
            When changing a weight's value, the bookmark icon updates immediately.
            However, it will not refresh when opening the parameter menu until a new
            selection is made. It's unclear if this is intended behavior or a bug —
            consider reporting this to SideFX.
            
        Args:
            (self):

        Returns:
            (TA_Menu): return menu list
        """
        # node: hou.SopNode = self.node
        
        # This data get created inside: menu_T_simple(self) -> TA_Menu:
        # This data get destroyed inside: refresh_iterator_vars_menu(self) -> None:
        data: TA_Menu | None = self._node.cachedUserData(f3h_cachedUserData.vars_menu_all_simple)
        if data is not None: return data

        use_icons: int = self._node.parm(f3h_tabs.PREFS.PRM_ITERATOR_BOOKMARK_ICONS).eval()
        return (self.menu_T_simple, self.menu_T_PP_ICON)[use_icons]()
    
    
    def menu_T_PP_FF(self) -> TA_Menu:
        """Populate FF PRE and/or POST variation names parameter menu list.</br>
        
        Note:
            When changing a weight's value, the bookmark icon updates immediately.
            However, it will not refresh when opening the parameter menu until a new
            selection is made. It's unclear if this is intended behavior or a bug —
            consider reporting this to SideFX.
            
        Args:
            (self):

        Returns:
            (TA_Menu): return menu list
        """
        # node: hou.SopNode = self.node
        
        # This data get created inside: menu_T_simple(self) -> TA_Menu:
        # This data get destroyed inside: refresh_iterator_vars_menu(self) -> None:
        data: TA_Menu | None = self._node.cachedUserData(f3h_cachedUserData.vars_menu_all_simple)
        if data is not None: return data

        use_icons: int = self._node.parm(f3h_tabs.PREFS.PRM_ITERATOR_BOOKMARK_ICONS).eval()
        return (self.menu_T_simple, self.menu_T_PP_ICON_FF)[use_icons]()
    
    
    def menu_T_pb(self) -> TA_Menu:
        """Populate variation name parameter menu list for Pre blur variation.</br>
        
        Note:
            When changing weight's value, the bookmark icon will updated too
            but it wont updated when we click the menu parameter to see all its entries until we dnt make a new selection.
            Not sure if this is to be considered a bug or is intended, perhaps I should note this to SideFx.
            
        Args:
            (self):

        Returns:
            (TA_Menu): return menu list
        """
        _ICON = self.menu_T_pb_data()
        return [ 0,  f"{_ICON} Pre blur                          "] # 26 times \s instead of 23 times as in H21


    def menu_select_iterator_data(self, data_now: tuple[list[Any] | Any, ...], data_names: tuple[str, ...]) -> TA_Menu:
        """Build a menu of iterators using their states as bookmark icon.</br>
        
        The args <b>data_cached</b> and <b>data_now</b> are composed as follow:
        * 0: iter_sel_n</br><b>list[str]</b></br>iterators names</br></br>
        * 1: iter_sel_a</br><b>list[int]</b></br>iterators active</br></br>
        * 2: iter_sel_w</br><b>list[float]</b></br>iterators Weights</br></br>
        * 3: iter_sel_o</br><b>list[float]</b></br>iterators shader's opacity</br></br>
        * 4: iter_xfviz_solo_idx</br><b>int</b></br>xform handle SOLO mode iterator mp idx</br></br>
        * 5: iter_xfviz_out_sensor</br><b>int</b></br>camera sensor toggle parameter</br></br>
        * 6: mem_id<b>int</b></br>The marked iterator number, Zero for no iterators being marked</br>

        Args:
            (self):
            data_now(tuple[list[Any] | Any, ...]): the now user data collected into a tuple.</br>Each entrie is a list (as many elements as the iterators count inside each list) plus some single values.</br>The order matter.
            data_names(tuple[str, ...]): The names of the cached user data we need to set, the order matter.</br>

        Returns:
            (TA_Menu): return menu list
        """
        
        with hou.undos.disabler(): # type: ignore
            
            node: hou.SopNode = self.node
            iter_count: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
            if not iter_count:
                self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                return f3h_menus.ZERO_ITERATORS
            
            # Unpack and cache
            note, active, weight, shader_opacity, xfviz_solo_idx, xfviz_out_sensor, _ = data_now
            for idx, this_data in enumerate(data_now): node.setCachedUserData(data_names[idx], this_data)
            
            # Get paste info once
            from_FLAM3H_NODE, mp_id_from, _ = self.prm_paste_update_for_undo(node)
            node.setCachedUserData(f3h_cachedUserData.iter_sel_id, mp_id_from)
            
            # Pre compute to avoid repeated checks
            _is_sensor_int: bool = isinstance(xfviz_out_sensor, int)
            _node_matches: bool = node == from_FLAM3H_NODE
            
            # Build menu with header
            menu: TA_Menu = [0, ""]
            
            for i in range(iter_count):
                
                idx: int = i + 1
                _n, _a, _w, _o = note[i], active[i], weight[i], shader_opacity[i]
                
                # Xfviz: compute only if needed
                _xfviz: int = 0 if idx != xfviz_solo_idx else (1 - xfviz_out_sensor if _is_sensor_int else 1)
                
                # Marked state
                _marked: int = 1 if (_node_matches and mp_id_from == idx) else 0
                
                # Icon selection
                if _a:
                    _icon = f3h_icons.SEL_ITER_BOOKMARK_ACTIVE_AND_WEIGHT[_xfviz][_marked] if _w > 0 else f3h_icons.SEL_ITER_BOOKMARK_ACTIVE_AND_WEIGHT_ZERO[_xfviz][_marked]
                else:
                    _icon = f3h_icons.SEL_ITER_BOOKMARK_OFF[_xfviz][_marked]
                
                # Build entry
                _opacity_str: str = "[ZERO opacity] " if _o == 0 else ""
                menu.extend([idx, f"{_icon}  {idx}:  {_opacity_str}{_n}"])
            
            node.setCachedUserData(f3h_cachedUserData.iter_sel, menu)
            return menu
    
    
    def menu_select_iterator(self) -> TA_Menu:
        """Cache or rebuild the menu on demand.</br>

        Args:
            (self):
            
        Returns:
            (TA_Menu): return menu list
        """
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            node: hou.SopNode = self.node
            n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
            
            mem_id: int = node.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX).eval()
            if node.cachedUserData(f3h_cachedUserData.iter_sel_id) != mem_id and mem_id:
                self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
            
            iter_count: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
            data_now: tuple[list[Any] | Any, ...] = tuple([node.parm(f'{prx}_{idx}').eval() for idx in range(1, iter_count + 1)] for prx in (n.main_note, n.main_vactive, n.main_weight, n.shader_alpha)) # The order matter, those are the parameter's names without the multiparameter number, just the base names.
            xfviz_mem_id: int = node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX).eval()
            xfviz_out_sensor: int = node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval()
            data_now += (xfviz_mem_id, xfviz_out_sensor, mem_id) # adding mem_id to catch an edge case when user change the memory id to another FLAM3H™ node and undoing it afterwards
            
            data_names: tuple[str, ...] = ( f3h_cachedUserData.iter_sel_n, 
                                            f3h_cachedUserData.iter_sel_a, 
                                            f3h_cachedUserData.iter_sel_w, 
                                            f3h_cachedUserData.iter_sel_o, 
                                            f3h_cachedUserData.iter_xfviz_solo_idx, 
                                            f3h_cachedUserData.iter_xfviz_out_sensor, 
                                            f3h_cachedUserData.mem_id
                                            ) # The order matter, they are the cached user data names being used
            
            iter_sel_cached: TA_Menu | None = node.cachedUserData(f3h_cachedUserData.iter_sel)
            if iter_sel_cached is not None:
                
                data_cached: tuple[list[Any] | Any, ...] = tuple(node.cachedUserData(name) for name in data_names)
                
                # For undos: compare old data_* against current data_*
                # Another piece for the undos to work is inside: def prm_paste_update_for_undo(self, node: hou.SopNode)
                if data_cached != data_now:
                    self.destroy_cachedUserData(node,f3h_cachedUserData.iter_sel)
                    return self.menu_select_iterator_data(data_now, data_names)
                
                return iter_sel_cached
            
            return self.menu_select_iterator_data(data_now, data_names)
        
    
    def prm_select_iterator(self) -> None:
        """Change multi-parameter index focus based on the selected iterator number from:
        * def menu_select_iterator(self) -> TA_Menu:
        
        Note:
            Need to investigate more how to control the Network Editor's Parameter Dialog displayed when pressing the "p" key.
            For now, it will just do nothing and let the user know.

        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        iter_count: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()

        if iter_count:
            
            # This definition probably can be made more light-weight for this particular case
            from_FLAM3H_NODE, mp_id_from, isDELETED = self.prm_paste_update_for_undo(node)
            
            prm: hou.Parm = node.parm(f3h_tabs.PRM_ITERATORS_COUNT)
            preset_id: int = node.parm(f3h_tabs.SYS.PRM_SELECT_ITERATOR).eval()
            
            try:
                # We first try to set them all with this
                # From Houdini 21.0.489 SideFX added multiParmTab and setMultiParmTab to hou.NetworkEditor.
                hou.ui.setMultiParmTabInEditors(prm, preset_id-1) # type: ignore
                
            except AttributeError:
                _CHECK = False
                
            else:
                _CHECK = True

            if _CHECK:
                
                # Change focus back to the FLAME's Tab
                flam3h_prm_utils.set(node, f3h_tabs.PRM_ITERATORS_TAB, (0,))
                # If any of the iterators is in SOLO mode, change accordeingly to the selection
                flam3h_general_utils(self.kwargs).flam3h_toggle_mp_xf_viz_solo_follow(str(preset_id))
                
                n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
                _MSG: str = f"iterator: {preset_id}"
                active: int = node.parm(f"{n.main_vactive}_{preset_id}").eval()
                weight: float = node.parm(f"{n.main_weight}_{preset_id}").eval()
                
                if node == from_FLAM3H_NODE and mp_id_from == preset_id:
                    if active and weight > 0:
                        flam3h_general_utils.flash_message(node, f"{_MSG} (Marked)")
                        flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} (Marked)", 'MSG')
                    elif active and weight == 0:
                        flam3h_general_utils.flash_message(node, f"{_MSG} (Zero Weight and Marked)")
                        flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} (Zero Weight and Marked)", 'MSG')
                    else:
                        flam3h_general_utils.flash_message(node, f"{_MSG} (Disabled and Marked)")
                        flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} (Disabled and Marked)", 'MSG')
                    
                else:
                    if active and weight > 0:
                        flam3h_general_utils.flash_message(node, _MSG)
                        flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                    elif active and weight == 0:
                        flam3h_general_utils.flash_message(node, f"{_MSG} (Zero Weight)")
                        flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} (Zero Weight)", 'MSG')
                    else:
                        flam3h_general_utils.flash_message(node, f"{_MSG} (Disabled)")
                        flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} (Disabled)", 'MSG')
                
            else:
                # If we can not set them all, lets see different cases one by one
                
                paneTab_uc = hou.ui.paneTabUnderCursor() # type: ignore

                if paneTab_uc is not None:

                    if paneTab_uc.type() == hou.paneTabType.Parm: # type: ignore
                        
                        paneTab_uc.setMultiParmTab(prm.name(), preset_id-1)
                        
                        # Change focus back to the FLAME's Tab
                        flam3h_prm_utils.set(node, f3h_tabs.PRM_ITERATORS_TAB, (0,))
                        # If any of the iterators is in SOLO mode, change it accordingly based on the user' selection
                        flam3h_general_utils(self.kwargs).flam3h_toggle_mp_xf_viz_solo_follow(str(preset_id))
                        
                        _MSG: str = f"iterator: {preset_id}"
                        active: int = node.parm(f"{flam3h_iterator_prm_names().main_vactive}_{preset_id}").eval()
                        
                        if node == from_FLAM3H_NODE and mp_id_from == preset_id:
                            if active:
                                flam3h_general_utils.flash_message(node, f"{_MSG} (Marked)")
                                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} (Marked)", 'MSG')
                            else:
                                flam3h_general_utils.flash_message(node, f"{_MSG} (Disabled and Marked)")
                                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} (Disabled and Marked)", 'MSG')
                                
                        else:
                            if active:
                                flam3h_general_utils.flash_message(node, _MSG)
                                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                            else:
                                flam3h_general_utils.flash_message(node, f"{_MSG} (Disabled)")
                                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} (Disabled)", 'MSG')
                        
                    elif paneTab_uc.type() == hou.paneTabType.NetworkEditor: # type: ignore
                        
                        # From Houdini 21.0.489 SideFX added multiParmTab and setMultiParmTab to hou.NetworkEditor.
                        if flam3h_general_utils.houdini_version(5) >= 210489:
                            
                            paneTab_uc.setMultiParmTab(prm.name(), preset_id-1)
                        
                        # For all Houdini versions prior to 21.0.489  
                        else:
                        
                            if hou.isUIAvailable():
                                _MSG: str = "This feature is not working over the Network Editor's Parameter Dialog displayed when pressing the \"p\" key.\nPlease, open a Parameter Editor in its own pane tab or floating panel for this feature to work.\n\nThis has been fixed from Houdini 21.0.489"
                                hou.ui.displayMessage(_MSG, buttons=("Got it, thank you",), severity = hou.severityType.ImportantMessage, default_choice = 0, close_choice = -1, help = None, title = "FLAM3H™ Select Iterator mini-menu", details = None, details_label = None, details_expanded = False) # type: ignore
                            
                            _MSG: str = "Selection do not work over Network Editors"
                            flam3h_general_utils.flash_message(node, f"{_MSG}")
                            flam3h_general_utils.set_status_msg(f"{node.name()}: Iterator's {_MSG.lower()}.", 'IMP')
                        
                    else:
                        _MSG: str = "Ops! That did not work!"
                        flam3h_general_utils.flash_message(node, f"{_MSG}")
                        flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} The pane under the cursor must be a valid Parameter Editor pane or floating panel.", 'WARN')
                    
                else:
                    _MSG: str = "Ops! That did not work!"
                    flam3h_general_utils.flash_message(node, f"{_MSG}")
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} The pane under the cursor must be a valid Parameter Editor pane or floating panel.", 'WARN')
        
        # reset selection to null value
        flam3h_prm_utils.set(node, f3h_tabs.SYS.PRM_SELECT_ITERATOR, 0)
        
        # Force select-iterator menu update in case an iterator is marked on this FLAM3H™ node
        self.prm_paste_sel_iter_sel_force_update(node)
    
    
    def flam3h_paste_reset_hou_session_data(self, hipLoad: bool = False) -> None:
        """init/clear copy/paste iterator's data and prm.</br>
        
        Args:
            (self):
            hipLoad(bool): Default to: False</br>To use when loading a hip file.
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        try:
            hou.session.F3H_MARKED_ITERATOR_NODE.type() # type: ignore
            
        except (AttributeError, hou.ObjectWasDeleted):
            from_FLAM3HNODE = None
            
        else:
            from_FLAM3HNODE: TA_MNode = hou.session.F3H_MARKED_ITERATOR_NODE # type: ignore
        
        if from_FLAM3HNODE is not None and node == from_FLAM3HNODE:
            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = None # type: ignore
            # Reset internal mpidx memory to a None value
            if node.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX).eval() != 0:
                self.iterator_mpidx_mem_set(node, 0)
            if hipLoad:
                # This is needed on hip file load to allow: def flam3h_init_hou_session_restore_from_user_data(node: hou.SopNode) -> None:
                # to rewire the FF copy/paste data properly on load, if any is present in the loaded FLAM3H™ nodes.
                if not self.exist_user_data(node, f3h_userData.MARKED_FF):
                    hou.session.F3H_MARKED_FF_NODE: TA_MNode = node # type: ignore
                    hou.session.F3H_MARKED_FF_CHECK: TA_M = None # type: ignore
            else:
                hou.session.F3H_MARKED_FF_NODE: TA_MNode = node # type: ignore
                hou.session.F3H_MARKED_FF_CHECK: TA_M = None # type: ignore
            # Remove any comment and user data from the node
            self.del_comment_and_user_data_iterator(node)
            self.del_comment_and_user_data_iterator(node, f3h_userData.MARKED_FF)
    
    
    def menu_global_density(self) -> TA_Menu:
        """Return a pre built static menu data.</br>
        It will use a different menu if the user is in xfomrs handles VIZ mode(ON or SOLO).</br>

        Args:
            (self):

        Returns:
            (TA_Menu): return menu list
        """
        node: hou.SopNode = self.node
        if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
            return f3h_menus.DENSITY
        
        elif node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ).eval():
            if node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO).eval() or node.parm(f3h_tabs.PREFS.PVT_PRM_XF_FF_VIZ_SOLO).eval():
                return f3h_menus.DENSITY_XFVIZ_ON_SOLO
            
            return f3h_menus.DENSITY_XFVIZ_ON
        
        else:
            return f3h_menus.DENSITY_XFVIZ_OFF
    
    
    def menu_global_density_set(self) -> None:
        """Set density menu parameter based on user choice.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """       
        node: hou.SopNode = self.node
        ptcount: int = node.parm(f3h_tabs.GLB.PRM_DENSITY).eval()
        sel: int = self.kwargs['parm'].evalAsInt()
        vals: dict[int, int] = { 1: 500000, 2: 1000000, 3: 2000000, 4: 5000000, 5: 15000000, 6: 25000000, 7: 50000000, 8: 100000000, 9: 150000000, 10: 250000000, 11: 500000000, 12: 750000000, 13: 1000000000}
        vals_name: dict[int, str] = { 1: "Default: 500K points", 2: "1 Millions points", 3: "2 Millions points", 4: "5 Millions points", 5: "15 Millions points", 6: "25 Millions points", 7: "50 Millions points", 8: "100 Millions points", 9: "150 Millions points", 10: "250 Millions points", 11: "500 Millions points", 12: "750 Millions points", 13: "1 Billions points"}
        
        val_get: int | None = vals.get(sel)
        if val_get is not None and ptcount != val_get:
            
            prm_density_presets = node.parm(f3h_tabs.GLB.PRM_DENSITY_PRESETS)
            prm_density_presets.lock(False)
            prm_density_presets.deleteAllKeyframes()
            flam3h_prm_utils.set(node, f3h_tabs.GLB.PRM_DENSITY, val_get)
            
            _MSG: str = f"{node.name()} -> SET Density: {vals_name.get(sel)}"
            flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            
        # Check and Update this data
        self.update_xml_last_loaded()


    def menu_global_density_set_default(self) -> None:
        """Revert density parameter to its default value.</br>
        Additionally give the ability to also set lower tier density presets: 300k, 200k, 100k.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        kwargs: dict = self.kwargs
        
        glb_density: int = node.parm(f3h_tabs.GLB.PRM_DENSITY).eval()
        
        if kwargs['shift']:
            if glb_density != 300000:
                parms_dict: dict = {f3h_tabs.GLB.PRM_DENSITY: 300000, 
                                    f3h_tabs.GLB.PRM_DENSITY_PRESETS: -1}
                flam3h_prm_utils.setParms(node, parms_dict)
                flam3h_general_utils.flash_message(node, 'Density: 300k')
                _MSG: str = f"{node.name()} -> SET Density: 300K points"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            else:
                _MSG: str = f"{node.name()}: Density already at: 300k points"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
        elif kwargs['ctrl']:
            if glb_density != 200000:
                parms_dict: dict = {f3h_tabs.GLB.PRM_DENSITY: 200000, 
                                    f3h_tabs.GLB.PRM_DENSITY_PRESETS: -1}
                flam3h_prm_utils.setParms(node, parms_dict)
                flam3h_general_utils.flash_message(node, 'Density: 200k')
                _MSG: str = f"{node.name()} -> SET Density: 200K points"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            else:
                _MSG: str = f"{node.name()}: Density already at: 200k points"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
        elif kwargs['alt']:
            if glb_density != 100000:
                parms_dict: dict = {f3h_tabs.GLB.PRM_DENSITY: 100000, 
                                    f3h_tabs.GLB.PRM_DENSITY_PRESETS: -1}
                flam3h_prm_utils.setParms(node, parms_dict)
                flam3h_general_utils.flash_message(node, 'Density: 100k')
                _MSG: str = f"{node.name()} -> SET Density: 100K points"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            else:
                _MSG: str = f"{node.name()}: Density already at: 100k points"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            
        else:
            # Default 500k
            if glb_density != f3h_tabs.GLB.DEFAULT_DENSITY:
                _MSG: str = f"{node.name()} -> SET default density preset: 500K points"
                flam3h_general_utils.set_status_msg(_MSG, 'IMP')
            else:
                _MSG: str = f"{node.name()}: Density already at its default value."
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
            # Reset/Set density
            flam3h_general_utils.reset_density(node)
                
        # Check and Update this data
        self.update_xml_last_loaded()
    
    
    def menu_copypaste(self) -> TA_Menu:
        """
        Build copy/paste parameter menu entries and eventually update its data if needed.</br>
        This menu, is the only one not being cached for reuse and always evaluated</br>
        It is important not to play the cache/destroy data mechanism because we need it to always evaluate to help us update other data as well.</br>
        It is our sentinel and always vigilant.</br>
        
        Args:
            (self):

        Returns:
            (TA_Menu): return menu list
        """    
        
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            node: hou.SopNode = self.node
            
            if self.exist_user_data(node):
                node.setGenericFlag(hou.nodeFlag.DisplayComment, True) # type: ignore
            
            # Update data for copy/paste iterator's methods in case of Undos.
            from_FLAM3H_NODE, mp_id_from, isDELETED = self.prm_paste_update_for_undo(node)
            
            if node.parmTuple(f3h_tabs.PRM_ITERATORS_TAB).eval() != (0,):
                return []
            
            if mp_id_from is not None:
                
                s_mp_index: int = self.kwargs['script_multiparm_index']
                
                assert from_FLAM3H_NODE is not None
                
                idx_from: str = str(mp_id_from)
                
                prm_selmem_name: str = f"selmem_{s_mp_index}"
                prm_selmem = node.parm(prm_selmem_name)
                if prm_selmem.eval() > 0:
                    # This menu try to be as fast as it can and do not really want
                    # to double check for those parms locks and keyframes at all
                    # as the user really must go in and change those on purpose to cause an issue.
                    prm_prmpastesel_name: str = f"prmpastesel_{s_mp_index}"
                    node.parm(prm_prmpastesel_name).set(0)
                    prm_selmem.set(0)
                    
                # Menu entrie sections bookmark icon
                try: active: int = from_FLAM3H_NODE.parm(f"vactive_{idx_from}").eval()
                except: return []
                else:
                    weight: float = from_FLAM3H_NODE.parm(f"iw_{idx_from}").eval()
                    if active and weight > 0: _ICON = f3h_icons.COPY_PASTE_ENTRIE
                    elif active and weight == 0: _ICON = f3h_icons.COPY_PASTE_ENTRIE_ZERO
                    else: _ICON = f3h_icons.COPY_PASTE_ENTRIE_ITER_OFF_MARKED

                    # Build menu
                    if node == from_FLAM3H_NODE and s_mp_index == mp_id_from:
                        return [ 0, f"{f3h_icons.COPY_PASTE_INFO}  {s_mp_index}: MARKED\n-> Select a different iterator number or a different FLAM3H™ node to paste its values.", 1,"" ]
                        
                    elif node == from_FLAM3H_NODE:
                        path: str = f"{_ICON}  {idx_from}"
                        return [ 0, "", 1, f"{f3h_icons.COPY_PASTE}  {idx_from}:  All (no xaos:)", 2, f"{path}", 3, f"{path}:  xaos:", 4, f"{path}:  shader", 5, f"{path}:  PRE", 6, f"{path}:  VAR", 7, f"{path}:  POST", 8, f"{path}:  pre affine", 9, f"{path}:  post affine", 10, "" ]
                    
                    else:
                        path: str = f"{_ICON}  .../{from_FLAM3H_NODE.parent()}/{from_FLAM3H_NODE.name()}.iter.{idx_from}"
                        return [ 0, "", 1, f"{f3h_icons.COPY_PASTE}  ... {idx_from}:  All (no xaos:)", 2, f"{path}", 3, f"{path}:  xaos:", 4, f"{path}:  shader", 5, f"{path}:  PRE", 6, f"{path}:  VAR", 7, f"{path}:  POST", 8, f"{path}:  pre affine", 9, f"{path}:  post affine", 10, "" ]
            
            else:
                if isDELETED:
                    return f3h_menus.ITER_COPY_PASTE_DELETED_MARKED
                
                if from_FLAM3H_NODE is not None:
                    
                    _FLAM3H_DATA_PRM_MPIDX: int = node.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX).eval()
                    __FLAM3H_DATA_PRM_MPIDX: int = from_FLAM3H_NODE.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX).eval()
                    
                    if node == from_FLAM3H_NODE and _FLAM3H_DATA_PRM_MPIDX == -1:
                        return f3h_menus.ITER_COPY_PASTE_REMOVED
                        
                    elif node != from_FLAM3H_NODE and __FLAM3H_DATA_PRM_MPIDX == -1:
                        path: str = f".../{from_FLAM3H_NODE.parent()}/{from_FLAM3H_NODE.name()}"
                        return [ 0, f"{f3h_icons.COPY_PASTE_INFO_WARN}  REMOVED: The marked iterator has been removed from node: {path}\n-> Mark an existing iterator instead.", 1, "" ]
                        
                    else:
                        return f3h_menus.ITER_COPY_PASTE_EMPTY
                
                return f3h_menus.ITER_COPY_PASTE_EMPTY

    
    def menu_copypaste_FF(self) -> TA_Menu:
        """
        Build copy/paste FF parameter menu entries and eventually update its data if needed.</br>
        This menu, together with: def menu_copypaste(self) -> TA_Menu: , are the only two menus not being cached for reuse.</br>
        It is important not to play the cache/destroy data mechanism on those two because we need them to always evaluate to help us update other data as well.</br>
        They are our sentinels and always vigilant.</br>
        
        Args:
            (self):

        Returns:
            (TA_Menu): return menu list
        """    

        if self.node.parmTuple(f3h_tabs.PRM_ITERATORS_TAB).eval() != (1,):
            return []
        
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            node: hou.SopNode = self.node
            # This is to make sure the hou.session's data is at least initialized.
            self.flam3h_init_hou_session_ff_data(node)
            # Update data for FF copy/paste iterator's methods in case of Undos.
            from_FLAM3H_NODE, from_FLAM3H_NODE_FF_CHECK, isDELETED = self.prm_paste_update_for_undo_ff(node)

            if from_FLAM3H_NODE_FF_CHECK is not None:

                flam3node_FF: TA_MNode = hou.session.F3H_MARKED_FF_NODE # type: ignore
                
                if node == flam3node_FF:
                    return f3h_menus.FF_COPY_PASTE_SELECT
                
                assert flam3node_FF is not None
                # Menu entrie sections bookmark icon
                active: int = flam3node_FF.parm(f3h_tabs.PREFS.PVT_PRM_DOFF).eval()
                _ICON: str = (f3h_icons.COPY_PASTE_FF_ENTRIE_OFF, f3h_icons.COPY_PASTE_FF_ENTRIE)[active]
                
                prm_selmem_name: str = f"{f3h_ffPrmPrx.PRM}selmem"
                prm_selmem = node.parm(prm_selmem_name)
                if prm_selmem.eval() > 0:
                    # This menu try to be as fast as it can and do not really want
                    # to double check for those parms locks and keyframes at all
                    # as the user really must go in and change those on purpose to cause an issue.
                    prm_prmpastesel_name: str = f"{f3h_ffPrmPrx.PRM}prmpastesel"
                    node.parm(prm_prmpastesel_name).set(0)
                    prm_selmem.set(0)
                
                path: str = f"{_ICON}  .../{flam3node_FF.parent()}/{flam3node_FF.name()}.FF"
                return [ 0, "", 1, f"{f3h_icons.COPY_PASTE_FF}  ... FF: All", 2, f"{path}:  PRE", 3, f"{path}:  VAR", 4, f"{path}:  POST", 5, f"{path}:  pre affine", 6, f"{path}:  post affine", 7, "" ]
            
            return f3h_menus.FF_COPY_PASTE_EMPTY
        
        
    def prm_paste_update_for_undo(self, node: hou.SopNode) -> tuple[hou.SopNode | None, int | None, bool]:
        """Updated data for copy/paste iterator's methods in case of Undos.</br>
        It will make sure that the houdini.session data about the iterator index</br>
        will always be up to date.</br>
        
        It is for:
        * hou.session.F3H_MARKED_ITERATOR_MP_IDX -> UNDO, so to speak -> prm: FLAM3H_DATA_PRM_MPIDX

        Args:
            (self):
            node(hou.SopNode): the current FLAM3H™ node

        Returns:
            (tuple[hou.SopNode | None, int | None, bool]): 
            
            * from_FLAM3H_NODE -> is the node we are copying the data from. 
            * mp_id_from -> Multiparameter index. Is the iterator number we are copying from inside "from_FLAM3H_NODE".
            * isDELETED -> will tell us if "from_FLAM3H_NODE" still exist.
        """
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            mp_id_from: TA_M = None
            isDELETED: bool = False
            _FLAM3H_DATA_PRM_MPIDX: int = node.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX).eval()
                
            try:
                from_FLAM3H_NODE: TA_MNode = hou.session.F3H_MARKED_ITERATOR_NODE # type: ignore 

            except AttributeError:
                from_FLAM3H_NODE = None
                __FLAM3H_DATA_PRM_MPIDX = 0
                
            else:
                
                try:
                    assert from_FLAM3H_NODE is not None
                    __FLAM3H_DATA_PRM_MPIDX = from_FLAM3H_NODE.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX).eval()
                    
                except (AttributeError, AssertionError):
                    from_FLAM3H_NODE = None
                    __FLAM3H_DATA_PRM_MPIDX = 0
                    
                except hou.ObjectWasDeleted:
                    return None, None, True
                
            try:
                # Do we have a marked iterator in the current scene
                # (This can also be: None - hence the double check)
                hou.session.F3H_MARKED_ITERATOR_NODE.type() # type: ignore
                
            except (AttributeError, hou.ObjectWasDeleted):
                self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                # This to avoid a wrong copy/paste info message
                try:
                    # If we really deleted a node with a marked iterator
                    if hou.session.F3H_MARKED_ITERATOR_MP_IDX is not None: # type: ignore
                        isDELETED = True
                        
                except AttributeError:
                    # otherwise leave things as they are
                    pass
            
            else:
                mp_id_from = hou.session.F3H_MARKED_ITERATOR_MP_IDX # type: ignore
                
                if node == from_FLAM3H_NODE:
                    if _FLAM3H_DATA_PRM_MPIDX > 0:
                        if mp_id_from != _FLAM3H_DATA_PRM_MPIDX:
                            mp_id_from = _FLAM3H_DATA_PRM_MPIDX
                            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = mp_id_from # type: ignore
                            self.del_comment_and_user_data_iterator(node)
                            self.set_comment_and_user_data_iterator(node, str(mp_id_from))
                            self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                            
                    else:
                        if _FLAM3H_DATA_PRM_MPIDX == -1:
                            mp_id_from = None
                            self.del_comment_and_user_data_iterator(node)
                            self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                            
                else:
                    if __FLAM3H_DATA_PRM_MPIDX > 0:
                        
                        if mp_id_from != __FLAM3H_DATA_PRM_MPIDX:
                            
                            assert from_FLAM3H_NODE is not None
                            
                            mp_id_from = __FLAM3H_DATA_PRM_MPIDX
                            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = mp_id_from # type: ignore
                            self.del_comment_and_user_data_iterator(from_FLAM3H_NODE)
                            self.set_comment_and_user_data_iterator(from_FLAM3H_NODE, str(mp_id_from))
                            self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                            
                        else:
                            # This is for an edge case so we dnt have marked iterators in multiple node's "select iterator" mini-menus
                            data: bool | None = node.cachedUserData(f3h_cachedUserData.edge_case_01)
                            if _FLAM3H_DATA_PRM_MPIDX == 0 and hou.session.F3H_MARKED_ITERATOR_MP_IDX is not None and data is None: # type: ignore
                                self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                                # This so we dnt fallback into this case again and again.
                                node.setCachedUserData(f3h_cachedUserData.edge_case_01, True)
                                
                    else:
                        
                        if __FLAM3H_DATA_PRM_MPIDX == -1:
                            
                            assert from_FLAM3H_NODE is not None
                            
                            mp_id_from = None
                            self.del_comment_and_user_data_iterator(from_FLAM3H_NODE)
                            self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                            
                        # This is for an edge case so we dnt have marked iterators in multiple node's "select iterator" mini-menus
                        elif _FLAM3H_DATA_PRM_MPIDX == 0 and hou.session.F3H_MARKED_ITERATOR_MP_IDX is None: # type: ignore
                            try:
                                hou.session.F3H_MARKED_ITERATOR_NODE.type() # type: ignore
                            except (AttributeError, hou.ObjectWasDeleted):
                                pass
                            else:
                                self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                                # This so we dnt fallback into this case again and again.
                                hou.session.F3H_MARKED_ITERATOR_NODE: TA_MNode = None # type: ignore
            
            finally:
                
                # It happened sometime that the hou.undoGroup() break and it doesnt group operation anylonger, especially after multiple Undos.
                # The following will try to pick up the pieces and put them together to keep the copy/paste iterators data going smooth.
                #
                if mp_id_from is not None and from_FLAM3H_NODE is not None:
                    
                    # Mark, mark another node, Undo
                    if node == from_FLAM3H_NODE and self.exist_user_data(from_FLAM3H_NODE) is False:
                        for f3h in node.type().instances():
                            if f3h != node and self.exist_user_data(f3h):
                                s_mp_index: int | None = int(self.get_user_data(f3h))
                                from_FLAM3H_NODE = hou.session.F3H_MARKED_ITERATOR_NODE = f3h # type: ignore
                                mp_id_from = hou.session.F3H_MARKED_ITERATOR_MP_IDX = s_mp_index # type: ignore
                                self.iterator_mpidx_mem_set(f3h, s_mp_index)
                                # Always on ourself since we dnt care about others FLAM3H™ nodes SYS tab's Select Iterator mini-menus
                                self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                                break
                            
                    # Mark, mark another node, Undo, Redo
                    elif node != from_FLAM3H_NODE and self.exist_user_data(node):
                        s_mp_index: int | None = int(self.get_user_data(node))
                        from_FLAM3H_NODE = hou.session.F3H_MARKED_ITERATOR_NODE = node # type: ignore
                        mp_id_from = hou.session.F3H_MARKED_ITERATOR_MP_IDX = s_mp_index # type: ignore
                        self.iterator_mpidx_mem_set(node, s_mp_index)
                        self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)

                # Mark, Clear, Mark, Undo
                elif mp_id_from is None and from_FLAM3H_NODE is not None:
                    if node == from_FLAM3H_NODE and self.exist_user_data(from_FLAM3H_NODE):
                        s_mp_index: int | None = int(self.get_user_data(from_FLAM3H_NODE))
                        mp_id_from = hou.session.F3H_MARKED_ITERATOR_MP_IDX = s_mp_index # type: ignore
                        self.iterator_mpidx_mem_set(from_FLAM3H_NODE, s_mp_index)
                        self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)


                if isDELETED is False:
                    if mp_id_from is not None and from_FLAM3H_NODE is not None:
                        if not self.exist_user_data(from_FLAM3H_NODE):
                            mp_id_from = None
                            self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                            
            # Return the desire data
            return from_FLAM3H_NODE, mp_id_from, isDELETED


    def prm_paste_update_for_undo_ff(self, node: hou.SopNode) -> tuple[hou.SopNode | None, int | None, bool]:
        """Updated data for copy/paste iterator's methods in case of Undos.</br>
        It will make sure that the houdini.session data about the iterator index</br>
        will always be up to date.</br>
        
        It is for:
        * hou.session.F3H_MARKED_ITERATOR_MP_IDX -> UNDO, so to speak -> prm: FLAM3H_DATA_PRM_MPIDX

        Args:
            (self):
            node(hou.SopNode): the current FLAM3H™ node

        Returns:
            (tuple[hou.SopNode | None, int | None, bool]): 
            
            * from_FLAM3H_NODE -> is the node we are copying the data from. 
            * from_FLAM3H_NODE_FF_CHECK -> Is the FF being marked or not".
            * isDELETED -> will tell us if "from_FLAM3H_NODE" still exist.
        """     
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            from_FLAM3H_NODE: TA_MNode = hou.session.F3H_MARKED_FF_NODE # type: ignore
            from_FLAM3H_NODE_FF_CHECK: TA_M = hou.session.F3H_MARKED_FF_CHECK # type: ignore
            
            isDELETED = False
            
            try:
                assert from_FLAM3H_NODE is not None
                from_FLAM3H_NODE.type()
                
            except (AttributeError, AssertionError):
                from_FLAM3H_NODE_FF_CHECK = None
                from_FLAM3H_NODE = None
                isDELETED = True

            # It happened sometime that the hou.undoGroup() break and it doesnt group operation anylonger, especially after multiple Undos.
            # The following will try to pick up the pieces and put them together to keep the copy/paste FF data going smooth.
            #
            # -> def menu_copypaste_FF(self) -> TA_Menu:
            if from_FLAM3H_NODE_FF_CHECK is not None and from_FLAM3H_NODE is not None:
                
                # Mark, mark another node, Undos
                if node == from_FLAM3H_NODE and self.exist_user_data(from_FLAM3H_NODE, f3h_userData.MARKED_FF) is False:
                    for f3h in node.type().instances():
                        if f3h != node and self.exist_user_data(f3h, f3h_userData.MARKED_FF):
                            from_FLAM3H_NODE = hou.session.F3H_MARKED_FF_NODE = f3h # type: ignore
                            from_FLAM3H_NODE_FF_CHECK = hou.session.F3H_MARKED_FF_CHECK = 1  # type: ignore
                            break
                        
                # Mark, mark another node, Undo, Redos
                elif node != from_FLAM3H_NODE and self.exist_user_data(node, f3h_userData.MARKED_FF):
                    from_FLAM3H_NODE = hou.session.F3H_MARKED_FF_NODE = node # type: ignore
                    from_FLAM3H_NODE_FF_CHECK = hou.session.F3H_MARKED_FF_CHECK = 1  # type: ignore
                    
            # Mark, unmark, Undos
            elif from_FLAM3H_NODE_FF_CHECK is None and from_FLAM3H_NODE is not None:
                if node == from_FLAM3H_NODE and self.exist_user_data(from_FLAM3H_NODE, f3h_userData.MARKED_FF):
                    from_FLAM3H_NODE_FF_CHECK = hou.session.F3H_MARKED_FF_CHECK = 1  # type: ignore

            if isDELETED is False:
                
                if from_FLAM3H_NODE_FF_CHECK is not None and from_FLAM3H_NODE is not None:
                    if not self.exist_user_data(from_FLAM3H_NODE, f3h_userData.MARKED_FF):
                        from_FLAM3H_NODE_FF_CHECK = None
                        
            return from_FLAM3H_NODE, from_FLAM3H_NODE_FF_CHECK, isDELETED


    def prm_paste_CTRL(self, id: int) -> None:
        """Everything about paste iterator's data.</br>

        Args:
            (self):
            id(int): current multi parameter index

        Returns:
            (None):
        """    
        node: hou.SopNode = self.node
        # Update data for copy/paste iterator's methods in case of Undos.
        from_FLAM3H_NODE, mp_id_from, isDELETED = self.prm_paste_update_for_undo(node)
                
        if mp_id_from is not None:
            
            idx: str = str(id)
            idx_from: str = str(mp_id_from)
            
            if node == from_FLAM3H_NODE and id == mp_id_from:
                _MSG: str = f"{node.name()}: This iterator is marked: {idx_from} -> Select a different iterator number or a different FLAM3H™ node to paste its values."
                flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                flam3h_general_utils.flash_message(node, f"This iterator is Marked")
            else:
                self.pastePRM_T_from_list(node, from_FLAM3H_NODE, flam3h_iterator().allT, flam3h_varsPRM().varsPRM, idx, idx_from)
                self.paste_from_list(node, from_FLAM3H_NODE, flam3h_iterator().allMisc, idx, idx_from)
                self.paste_set_note(node, from_FLAM3H_NODE, 0, f3h_copyPaste.DEFAULT_SEC_ALL, idx, idx_from)

        else:
            if isDELETED:
                _MSG_DEL: str = "Marked iterator's node has been deleted"
                _MSG: str = f"{node.name()}: {_MSG_DEL} -> {f3h_copyPaste.DEFAULT_MSG_MARK_ITER_STATUS_BAR}"
                flam3h_general_utils.set_status_msg(_MSG, 'WARN') 
                flam3h_general_utils.flash_message(node, _MSG_DEL)
                
            else:
                _MSG_REM: str = "Marked iterator has been removed"
                if node == from_FLAM3H_NODE:
                    _FLAM3H_DATA_PRM_MPIDX = node.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX).eval()
                    if _FLAM3H_DATA_PRM_MPIDX == -1:
                        _MSG: str = f"{node.name()} -> {_MSG_REM} -> {f3h_copyPaste.DEFAULT_MSG_MARK_ITER_STATUS_BAR}"
                        flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                        flam3h_general_utils.flash_message(node, _MSG_REM)
                    else:
                        _MSG: str = f"{node.name()} -> {f3h_copyPaste.DEFAULT_MSG_MARK_ITER_STATUS_BAR}"
                        flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                        flam3h_general_utils.flash_message(node, f3h_copyPaste.DEFAULT_MSG_MARK_ITER)
                        
                elif node != from_FLAM3H_NODE:
                    
                    try:
                        assert from_FLAM3H_NODE is not None
                    
                    except AssertionError:
                        pass
                    
                    else:
                        
                        __FLAM3H_DATA_PRM_MPIDX = from_FLAM3H_NODE.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX).eval()
                        
                        if __FLAM3H_DATA_PRM_MPIDX == -1:
                            _MSG: str = f"{node.name()} -> {_MSG_REM} from node: {from_FLAM3H_NODE.name()} -> {f3h_copyPaste.DEFAULT_MSG_MARK_ITER_STATUS_BAR}"
                            flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                            flam3h_general_utils.flash_message(node, _MSG_REM)
                        else:
                            _MSG: str = f"{node.name()} -> {f3h_copyPaste.DEFAULT_MSG_MARK_ITER_STATUS_BAR}"
                            flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                            flam3h_general_utils.flash_message(node, f3h_copyPaste.DEFAULT_MSG_MARK_ITER)
                        
                else:
                    _MSG: str = f"{node.name()} -> {f3h_copyPaste.DEFAULT_MSG_MARK_ITER_STATUS_BAR}"
                    flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                    flam3h_general_utils.flash_message(node, f3h_copyPaste.DEFAULT_MSG_MARK_ITER)


    def prm_paste_SHIFT(self, id: int) -> None:
        """Everything about unmarking iterators from being copied.</br>

        Args:
            (self):
            id(int): current multi parameter index

        Returns:
            (None):
        """   
        node: hou.SopNode = self.node
        idx: str = str(id)
        # Update data for copy/paste iterator's methods in case of Undos.
        from_FLAM3H_NODE, mp_id_from, isDELETED = self.prm_paste_update_for_undo(node)

        _MSG_UNMARKED = "This iterator is Unmarked already"
        
        if node == from_FLAM3H_NODE:
            
            assert from_FLAM3H_NODE is not None
            
            if mp_id_from is not None:
                _MSG: str = f"{node.name()}: iterator UNMARKED: {mp_id_from}"
                hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = None # type: ignore
                self.iterator_mpidx_mem_set(node, 0)
                self.del_comment_and_user_data_iterator(node)
                
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                flam3h_general_utils.flash_message(node, f"UNMARKED")
                
            else:
                if from_FLAM3H_NODE.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX).eval() == -1:
                    _MSG: str = f"{node.name()}: {_MSG_UNMARKED}:  {idx}   Unmarked removed iterator -> {hou.session.F3H_MARKED_ITERATOR_MP_IDX}" # type: ignore
                else:
                    _MSG: str = f"{node.name()}: {_MSG_UNMARKED} -> {idx}"
                    
                hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = None # type: ignore
                self.iterator_mpidx_mem_set(node, 0)
                self.del_comment_and_user_data_iterator(node)
                
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
        else:
            if isDELETED:
                _MSG_DEL: str = "Marked iterator's node has been deleted"
                _MSG: str = f"{node.name()}: {_MSG_DEL}. Mark a new iterator first."
                flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                flam3h_general_utils.flash_message(node, _MSG_DEL)
                
            else:
                
                try:
                    assert from_FLAM3H_NODE is not None
                    
                except AssertionError:
                    _MSG: str = f"{node.name()}: {_MSG_UNMARKED}"
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                    pass
                
                else:
                    __FLAM3H_DATA_PRM_MPIDX = from_FLAM3H_NODE.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX).eval()
                    
                    if __FLAM3H_DATA_PRM_MPIDX == -1:
                        _MSG: str = f"{node.name()}: {_MSG_UNMARKED} -> The marked iterator has been removed from node: {from_FLAM3H_NODE.name()} ->  Mark an existing iterator instead." # type: ignore
                        flam3h_general_utils.set_status_msg(_MSG, 'IMP')
                    else:
                        _MSG: str = f"{node.name()}: {_MSG_UNMARKED} -> The marked iterator is from node: {from_FLAM3H_NODE.name()}.iterator.{mp_id_from}" # type: ignore
                        flam3h_general_utils.set_status_msg(_MSG, 'IMP')
        

    def prm_paste_CLICK(self, id: int) -> None:
        """Everything about marking iterators for being copied.</br>

        Args:
            (self):
            id(int): current multi parameter index

        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        idx: str = str(id)
        # Update data for copy/paste iterator's methods in case of Undos.
        from_FLAM3H_NODE, mp_id_from, isDELETED = self.prm_paste_update_for_undo(node)
                
        if self.exist_user_data(node):
            if node.isGenericFlagSet(hou.nodeFlag.DisplayComment) is False: # type: ignore
                node.setGenericFlag(hou.nodeFlag.DisplayComment, True) # type: ignore

        if node == hou.session.F3H_MARKED_ITERATOR_NODE: # type: ignore
            
            if hou.session.F3H_MARKED_ITERATOR_MP_IDX != id: # type: ignore
                hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = id # type: ignore
                hou.session.F3H_MARKED_ITERATOR_NODE: TA_MNode = self.node # type: ignore
                self.iterator_mpidx_mem_set(node, id)
                self.del_comment_and_user_data_iterator(node)
                self.set_comment_and_user_data_iterator(node, idx)
                
                _MSG: str = f"{self.node.name()}: iterator MARKED:  {hou.session.F3H_MARKED_ITERATOR_MP_IDX}" # type: ignore
                flam3h_general_utils.set_status_msg(_MSG, 'IMP')
                flam3h_general_utils.flash_message(node, f"{hou.session.F3H_MARKED_ITERATOR_MP_IDX}: MARKED") # type: ignore
                
            else:
                self.iterator_mpidx_mem_set(node, id)
                self.del_comment_and_user_data_iterator(node)
                self.set_comment_and_user_data_iterator(node, idx)
                
                _MSG: str = f"{self.node.name()}: This iterator is already Marked." # type: ignore
                flam3h_general_utils.set_status_msg(_MSG, 'IMP')
                
        else:
            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = id # type: ignore
            hou.session.F3H_MARKED_ITERATOR_NODE: TA_MNode = self.node # type: ignore
            self.iterator_mpidx_mem_set(node, id)
            self.del_comment_and_user_data_iterator(node)
            self.set_comment_and_user_data_iterator(node, idx)
            
            # Reset the other node mp_idx data
            if from_FLAM3H_NODE is not None:
                self.iterator_mpidx_mem_set(from_FLAM3H_NODE, 0)
                self.del_comment_and_user_data_iterator(from_FLAM3H_NODE)
                
            _MSG: str = f"{self.node.name()}: iterator MARKED:  {hou.session.F3H_MARKED_ITERATOR_MP_IDX}" # type: ignore
            flam3h_general_utils.set_status_msg(_MSG, 'IMP')
            flam3h_general_utils.flash_message(node, f"{hou.session.F3H_MARKED_ITERATOR_MP_IDX}: MARKED") # type: ignore


    def prm_paste(self) -> None:
        """Paste the entire iterator's data.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """    
        
        node: hou.SopNode = self.node
        mpmem_name: str = flam3h_iterator_prm_names().main_mpmem
        
        # Check and Update this data
        self.update_xml_last_loaded()
        # Clear menu cache
        self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
        
        s_mp_index: int = self.kwargs['script_multiparm_index']
        iter_num: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        
        # This is to make sure the hou.session's data is at least initialized.
        self.flam3h_init_hou_session_iterator_data(node)
        
        # Adding ability to reset the current iterator to its default values. 
        if self.kwargs["ctrl"]:
            with hou.undos.group(f"FLAM3H™ reset iterator {s_mp_index}"): # type: ignore
                self.flam3h_reset_iterator()
                _MSG: str = f"{node.name()}: Iterator {s_mp_index} -> RESET"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
        elif self.kwargs["shift"]:
            with hou.undos.group(f"FLAM3H™ unmark iterator SHIFT {s_mp_index}"): # type: ignore
                self.destroy_cachedUserData_all_f3h(node, f3h_cachedUserData.edge_case_01)
                self.prm_paste_SHIFT(s_mp_index)
                     
        elif self.kwargs["alt"]:
            with hou.undos.group(f"FLAM3H™ paste iterator data CTRL {s_mp_index}"): # type: ignore
                self.prm_paste_CTRL(s_mp_index)
        
        else:
            if self.exist_user_data(node) and int(self.get_user_data(node)) == s_mp_index and s_mp_index == hou.session.F3H_MARKED_ITERATOR_MP_IDX and node == hou.session.F3H_MARKED_ITERATOR_NODE: # type: ignore
                with hou.undos.group(f"FLAM3H™ unmark iterator CLICK {s_mp_index}"): # type: ignore
                    self.destroy_cachedUserData_all_f3h(node, f3h_cachedUserData.edge_case_01)
                    self.prm_paste_SHIFT(s_mp_index)
                    
            else:
                with hou.undos.group(f"FLAM3H™ mark iterator CLICK {s_mp_index}"): # type: ignore
                    self.destroy_cachedUserData_all_f3h(node, f3h_cachedUserData.edge_case_01)
                    self.prm_paste_CLICK(s_mp_index)
                    
    
    def prm_paste_FF_CTRL(self) -> None:
        """Everything about paste FF's data.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """    
        node: hou.SopNode = self.node
        
        # Check and Update this data
        self.update_xml_last_loaded()
        
        # Update data for FF copy/paste iterator's methods in case of Undos.
        from_FLAM3H_NODE, from_FLAM3H_NODE_FF_CHECK, isDELETED = self.prm_paste_update_for_undo_ff(node)
            
        if from_FLAM3H_NODE_FF_CHECK is not None:
            
            if node == from_FLAM3H_NODE:
                _MSG: str = f"{node.name()}: This FF is marked. Select a different FLAM3H™ node's FF to paste its values."
                flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                flam3h_general_utils.flash_message(node, f"Select a different FLAM3H™ node's FF")
            else:
                f3h_iter_FF: flam3h_iterator_FF = flam3h_iterator_FF()
                self.pastePRM_T_from_list(node, from_FLAM3H_NODE, f3h_iter_FF.sec_prevarsT_FF, flam3h_varsPRM_FF(f3h_ffPrmPrx.PRM_PP).varsPRM_FF(), "", "")
                self.pastePRM_T_from_list(node, from_FLAM3H_NODE, f3h_iter_FF.sec_varsT_FF, flam3h_varsPRM_FF(f3h_ffPrmPrx.PRM).varsPRM_FF(), "", "")
                self.pastePRM_T_from_list(node, from_FLAM3H_NODE, f3h_iter_FF.sec_postvarsT_FF, flam3h_varsPRM_FF(f3h_ffPrmPrx.PRM_PP).varsPRM_FF(), "", "")
                self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter_FF.allMisc_FF, "", "")
                self.paste_set_note(node, from_FLAM3H_NODE, 1, f3h_copyPaste.DEFAULT_SEC_ALL, "", "")

        else:
            
            if isDELETED:
                _MSG: str = f"{node.name()}: Marked FF's node has been deleted -> {f3h_copyPaste.DEFAULT_MSG_MARK_FF_STATUS_BAR}"
                flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                flam3h_general_utils.flash_message(node, f"Marked FF's node has been deleted")
            else:
                _MSG: str = f"{node.name()} -> {f3h_copyPaste.DEFAULT_MSG_MARK_FF_STATUS_BAR}"
                flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                flam3h_general_utils.flash_message(node, f3h_copyPaste.DEFAULT_MSG_MARK_FF)
    
    
    def prm_paste_FF_SHIFT(self) -> None:
        """Everything about unmarking FF from being copied.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """  
        node: hou.SopNode = self.node
        # Update data for FF copy/paste iterator's methods in case of Undos.
        from_FLAM3H_NODE, from_FLAM3H_NODE_FF_CHECK, isDELETED = self.prm_paste_update_for_undo_ff(node)
            
        if from_FLAM3H_NODE_FF_CHECK is not None: # type: ignore
            
            if node == from_FLAM3H_NODE:
                
                assert from_FLAM3H_NODE is not None
                
                _MSG: str = f"{node.name()}: FF UNMARKED: {from_FLAM3H_NODE.name()}.FF" # type: ignore
                hou.session.F3H_MARKED_FF_CHECK: TA_M = None # type: ignore
                hou.session.F3H_MARKED_FF_NODE: TA_MNode = node # type: ignore
                
                self.del_comment_and_user_data_iterator(node, f3h_userData.MARKED_FF)
                
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                flam3h_general_utils.flash_message(node, f"FF UNMARKED")
            else:
                _MSG: str = f"{node.name()}: This FF is Unmarked already. The marked FF is from node: {hou.session.F3H_MARKED_FF_NODE}.FF" # type: ignore
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
        else:
            
            if isDELETED:
                _MSG: str = f"{node.name()}: Marked FF's node has been deleted. Mark a new FF first."
                flam3h_general_utils.set_status_msg(_MSG, 'WARN')
            else:
                _MSG: str = f"{node.name()}: This FF is Unmarked already"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')


    def prm_paste_FF_CLICK(self) -> None:
        """Everything about marking FF for being copied.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """ 
        node: hou.SopNode = self.node
        # Update data for FF copy/paste iterator's methods in case of Undos.
        from_FLAM3H_NODE, from_FLAM3H_NODE_FF_CHECK, isDELETED = self.prm_paste_update_for_undo_ff(node)
        
        if self.exist_user_data(node, f3h_userData.MARKED_FF):
            if node.isGenericFlagSet(hou.nodeFlag.DisplayComment) is False: # type: ignore
                node.setGenericFlag(hou.nodeFlag.DisplayComment, True) # type: ignore
            
        if from_FLAM3H_NODE_FF_CHECK and node == from_FLAM3H_NODE:
            _MSG: str = f"{self.node.name()}: This FF is already Marked." # type: ignore
            flam3h_general_utils.set_status_msg(_MSG, 'MSG')

        else:
            # Remove the FF data and comment from the other node
            if from_FLAM3H_NODE is not None:
                
                self.del_comment_and_user_data_iterator(from_FLAM3H_NODE, f3h_userData.MARKED_FF)
                
            hou.session.F3H_MARKED_FF_CHECK: TA_M = 1 # type: ignore
            hou.session.F3H_MARKED_FF_NODE: TA_MNode = self.node # type: ignore
            
            self.del_comment_and_user_data_iterator(node, f3h_userData.MARKED_FF)
            self.set_comment_and_user_data_iterator(node, "Yes", f3h_userData.MARKED_FF)

            _MSG: str = f"{self.node.name()}: FF MARKED" # type: ignore
            flam3h_general_utils.set_status_msg(_MSG, 'IMP')
            flam3h_general_utils.flash_message(node, f"FF MARKED")


    def prm_paste_FF(self) -> None:
        """Paste the entire FF data.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """   
        
        node: hou.SopNode = self.node
        # This is to make sure the hou.session's data is at least initialized.
        self.flam3h_init_hou_session_ff_data(node)
        
        # Adding ability to reset the FF to its default values. 
        if self.kwargs["ctrl"]:
            with hou.undos.group(f"FLAM3H™ FF RESET"): # type: ignore
                self.flam3h_reset_FF()
                _MSG: str = f"{node.name()}: FF RESET"
                flam3h_general_utils.set_status_msg(_MSG, 'IMP')
                
        elif self.kwargs["shift"]:
            with hou.undos.group(f"FLAM3H™ unmark FF SHIFT"): # type: ignore
                self.prm_paste_FF_SHIFT()

        elif self.kwargs["alt"]:
            with hou.undos.group(f"FLAM3H™ paste FF data CTRL"): # type: ignore
                self.prm_paste_FF_CTRL()
        
        else:
            if self.exist_user_data(node, f3h_userData.MARKED_FF) and hou.session.F3H_MARKED_FF_CHECK is not None and node == hou.session.F3H_MARKED_FF_NODE: # type: ignore
                with hou.undos.group(f"FLAM3H™ unmark FF CLICK"): # type: ignore
                    self.prm_paste_FF_SHIFT()
            else:
                with hou.undos.group(f"FLAM3H™ mark FF CLICK"): # type: ignore
                    self.prm_paste_FF_CLICK()


    def prm_paste_sel_iter_sel_force_update(self, node: hou.SopNode) -> None:
        """Force select-iterator menu update in case an iterator is marked on this FLAM3H™ node.</br>
        This is being added to deal with a mismatch during undos.</br>
        
        Args:
            (self):
            node(hou.SopNode): This FLAM3H™ node

        Returns:
            (None):
        """   
        try:
            if hou.session.F3H_MARKED_ITERATOR_MP_IDX is not None and hou.session.F3H_MARKED_ITERATOR_NODE == node: # type: ignore
                self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                self.destroy_cachedUserData_all_f3h(node, f3h_cachedUserData.edge_case_01)
        except AttributeError:
            pass


    def prm_paste_sel(self) -> None:
        """Paste only sections of an iterator.
        
        Args:
            (self):

        Returns:
            (None):
        """    

        node: hou.SopNode = self.node
        # prm names
        n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
        
        # Marked iterator ( not needed but just in case lets "try" so to speak )
        try:
            mp_id_from: TA_M = hou.session.F3H_MARKED_ITERATOR_MP_IDX # type: ignore
            from_FLAM3H_NODE: TA_MNode = hou.session.F3H_MARKED_ITERATOR_NODE # type: ignore
        except AttributeError:
            mp_id_from: TA_M = None
            from_FLAM3H_NODE: TA_MNode = None

        if mp_id_from is not None:
            
            assert isinstance(from_FLAM3H_NODE, hou.SopNode)

            # current iterator
            s_mp_index: int = self.kwargs['script_multiparm_index']
            mp_idx: str = str(s_mp_index)
            idx_from = str(mp_id_from)
            
            # Get user selection of paste methods
            paste_sel: int = node.parm(f"{n.main_prmpastesel}_{s_mp_index}").eval()
            prm_selmem = node.parm(f"{n.main_selmem}_{s_mp_index}")
            flam3h_prm_utils.set(node, prm_selmem, paste_sel)

            f3h_iter: flam3h_iterator = flam3h_iterator()
            varsPRM = flam3h_varsPRM().varsPRM
            
            match paste_sel:
                
                # set ALL
                case 1:
                    self.prm_paste_CTRL(s_mp_index)
                    
                # set MAIN
                case 2:
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter.sec_main, mp_idx, idx_from)
                    self.paste_set_note(node, from_FLAM3H_NODE, 0, f3h_copyPaste.DEFAULT_SEC_MAIN, mp_idx, idx_from)
                    
                # set XAOS
                case 3:
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter.sec_xaos, mp_idx, idx_from)
                    self.paste_set_note(node, from_FLAM3H_NODE, 0, f3h_copyPaste.DEFAULT_SEC_XAOS, mp_idx, idx_from)
                    self.auto_set_xaos()
                    
                # set SHADER 
                case 4:
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter.sec_shader, mp_idx, idx_from)
                    self.paste_set_note(node, from_FLAM3H_NODE, 0, f3h_copyPaste.DEFAULT_SEC_SHADER, mp_idx, idx_from)
                    
                # set PRE VARS
                case 5:
                    self.pastePRM_T_from_list(node, from_FLAM3H_NODE, f3h_iter.sec_prevarsT, varsPRM, mp_idx, idx_from)
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter.sec_prevarsW, mp_idx, idx_from)
                    self.paste_set_note(node, from_FLAM3H_NODE, 0, f3h_copyPaste.DEFAULT_SEC_PREVARS, mp_idx, idx_from)
                    
                # set VARS
                case 6:
                    self.pastePRM_T_from_list(node, from_FLAM3H_NODE, f3h_iter.sec_varsT, varsPRM, mp_idx, idx_from)
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter.sec_varsW, mp_idx, idx_from)
                    self.paste_set_note(node, from_FLAM3H_NODE, 0, f3h_copyPaste.DEFAULT_SEC_VARS, mp_idx, idx_from)
                    
                # set POST VARS
                case 7:
                    self.pastePRM_T_from_list(node, from_FLAM3H_NODE, f3h_iter.sec_postvarsT, varsPRM, mp_idx, idx_from)
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter.sec_postvarsW, mp_idx, idx_from)
                    self.paste_set_note(node, from_FLAM3H_NODE, 0, f3h_copyPaste.DEFAULT_SEC_POSTVARS, mp_idx, idx_from)
                    
                # set PRE AFFINE
                case 8:
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter.sec_preAffine, mp_idx, idx_from)
                    if not self.is_iterator_affine_default(node, from_FLAM3H_NODE, f3h_iter.sec_preAffine, mp_idx, idx_from):
                        self.paste_set_note(node, from_FLAM3H_NODE, 0, f3h_copyPaste.DEFAULT_SEC_PREAFFINE, mp_idx, idx_from)
                        
                # set POST AFFINE
                case 9:
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter.sec_postAffine, mp_idx, idx_from)
                    if not self.is_iterator_affine_default(node, from_FLAM3H_NODE, f3h_iter.sec_postAffine, mp_idx, idx_from, True):
                        self.paste_set_note(node, from_FLAM3H_NODE, 0, f3h_copyPaste.DEFAULT_SEC_POSTAFFINE, mp_idx, idx_from)
                        
            parms_dict: dict = {f"{n.main_prmpastesel}_{s_mp_index}": 0, 
                                f"{n.main_selmem}_{s_mp_index}": paste_sel}
            flam3h_prm_utils.setParms(node, parms_dict)
            
            # Force select-iterator menu update in case an iterator is marked on this FLAM3H™ node
            self.prm_paste_sel_iter_sel_force_update(node)
            
        else:
            _MSG: str = f"{node.name()} -> {f3h_copyPaste.DEFAULT_MSG_MARK_ITER_STATUS_BAR}"
            flam3h_general_utils.set_status_msg(_MSG, 'WARN')
        
        # Delete keyframes from all iterators copy/paste menus
        iter_count: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        prm_name: str = n.main_prmpastesel

        for idx_mp in range(1, iter_count + 1):
            prm: hou.Parm = node.parm(f"{prm_name}_{idx_mp}")
            if prm is not None and prm.keyframes():
                prm.deleteAllKeyframes()
        
        if node != from_FLAM3H_NODE and from_FLAM3H_NODE is not None:
            for idx_mp in range(1, iter_count + 1):
                prm: hou.Parm = from_FLAM3H_NODE.parm(f"{prm_name}_{idx_mp}")
                if prm is not None and prm.keyframes():
                    prm.deleteAllKeyframes()
            

    def prm_paste_sel_pre_affine(self) -> None:
        """Copy/Paste POST affine inside the PRE affine.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """    
        # Check and Update this data
        self.update_xml_last_loaded()
        
        # current iterator
        s_mp_index: int = self.kwargs['script_multiparm_index']
        mp_idx: str = str(s_mp_index)
        kwargs: dict = self.kwargs
        
        f3h_iter: flam3h_iterator = flam3h_iterator()
        if kwargs['shift']:
            self.paste_from_list_affine(self.node, f3h_iter.sec_postAffine[1:-2], f3h_iter.sec_preAffine[:-2], mp_idx)
            _MSG: str = f"iterator.{s_mp_index} - POST affine X and Y copied into the PRE affine."
            
        elif kwargs['ctrl']:
            self.paste_from_list_affine(self.node, f3h_iter.sec_postAffine[3:-1], f3h_iter.sec_preAffine[2:-1], mp_idx)
            _MSG: str = f"iterator.{s_mp_index} - POST affine OFFSET copied into the PRE affine."
            
        elif kwargs['alt']:
            self.paste_from_list_affine(self.node, f3h_iter.sec_postAffine[4:], f3h_iter.sec_preAffine[3:], mp_idx)
            _MSG: str = f"iterator.{s_mp_index} - POST affine ROT angle copied into the PRE affine."
            
        else:
            self.paste_from_list_affine(self.node, f3h_iter.sec_postAffine[1:], f3h_iter.sec_preAffine, mp_idx)
            _MSG: str = f"iterator.{s_mp_index} - POST affine ALL values copied into the PRE affine."
            
        flam3h_general_utils.set_status_msg(f"{self.node.name()}: {_MSG}", 'IMP')
        
        
    def prm_paste_sel_post_affine(self) -> None:
        """Copy/Paste PRE affine inside the POST affine.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """    
        # Check and Update this data
        self.update_xml_last_loaded()
        
        # current iterator
        s_mp_index: int = self.kwargs['script_multiparm_index']
        mp_idx: str = str(s_mp_index)
        kwargs: dict = self.kwargs
        
        f3h_iter: flam3h_iterator = flam3h_iterator()
        if kwargs['shift']:
            self.paste_from_list_affine(self.node, f3h_iter.sec_preAffine[:-2], f3h_iter.sec_postAffine[1:-2], mp_idx)
            _MSG: str = f"iterator.{s_mp_index} - PRE affine X and Y copied into the POST affine."
            
        elif kwargs['ctrl']:
            self.paste_from_list_affine(self.node, f3h_iter.sec_preAffine[2:-1], f3h_iter.sec_postAffine[3:-1], mp_idx)
            _MSG: str = f"iterator.{s_mp_index} - PRE affine OFFSET copied into the POST affine."
            
        elif kwargs['alt']:
            self.paste_from_list_affine(self.node, f3h_iter.sec_preAffine[3:], f3h_iter.sec_postAffine[4:], mp_idx)
            _MSG: str = f"iterator.{s_mp_index} - PRE affine ROT angle copied into the POST affine."
            
        else:
            self.paste_from_list_affine(self.node, f3h_iter.sec_preAffine, f3h_iter.sec_postAffine[1:], mp_idx)
            _MSG: str = f"iterator.{s_mp_index} - PRE affine ALL values copied into the POST affine."
            
        flam3h_general_utils.set_status_msg(f"{self.node.name()}: {_MSG}", 'IMP')
        
        
    def prm_paste_sel_pre_affine_FF(self) -> None:
        """Paste only either the FF POST affine.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """    
        # Check and Update this data
        self.update_xml_last_loaded()
        
        kwargs: dict = self.kwargs
        
        f3h_iter_FF: flam3h_iterator_FF = flam3h_iterator_FF()
        if kwargs['shift']:
            self.paste_from_list_affine(self.node, f3h_iter_FF.sec_postAffine_FF[1:-2], f3h_iter_FF.sec_preAffine_FF[:-2], "")
            _MSG: str = f"FF POST affine X and Y copied into the FF PRE affine."
            
        elif kwargs['ctrl']:
            self.paste_from_list_affine(self.node, f3h_iter_FF.sec_postAffine_FF[3:-1], f3h_iter_FF.sec_preAffine_FF[2:-1], "")
            _MSG: str = f"FF POST affine OFFSET copied into the FF PRE affine."
            
        elif kwargs['alt']:
            self.paste_from_list_affine(self.node, f3h_iter_FF.sec_postAffine_FF[4:], f3h_iter_FF.sec_preAffine_FF[3:], "")
            _MSG: str = f"FF POST affine ROT angle copied into the FF PRE affine."
            
        else:
            self.paste_from_list_affine(self.node, f3h_iter_FF.sec_postAffine_FF[1:], f3h_iter_FF.sec_preAffine_FF, "")
            _MSG: str = f"FF POST affine ALL values copied into the FF PRE affine."
            
        flam3h_general_utils.set_status_msg(f"{self.node.name()}: {_MSG}", 'IMP')
        
        
    def prm_paste_sel_post_affine_FF(self) -> None:
        """Paste only either the FF PRE affine.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """    
        # Check and Update this data
        self.update_xml_last_loaded()
        
        kwargs: dict = self.kwargs
        
        f3h_iter_FF: flam3h_iterator_FF = flam3h_iterator_FF()
        if kwargs['shift']:
            self.paste_from_list_affine(self.node, f3h_iter_FF.sec_preAffine_FF[:-2], f3h_iter_FF.sec_postAffine_FF[1:-2], "")
            _MSG: str = f"FF PRE affine X and Y copied into the FF POST affine."
            
        elif kwargs['ctrl']:
            self.paste_from_list_affine(self.node, f3h_iter_FF.sec_preAffine_FF[2:-1], f3h_iter_FF.sec_postAffine_FF[3:-1], "")
            _MSG: str = f"FF PRE affine OFFSET copied into the FF POST affine."
            
        elif kwargs['alt']:
            self.paste_from_list_affine(self.node, f3h_iter_FF.sec_preAffine_FF[3:], f3h_iter_FF.sec_postAffine_FF[4:], "")
            _MSG: str = f"FF PRE affine ROT angle copied into the FF POST affine."
            
        else:
            self.paste_from_list_affine(self.node, f3h_iter_FF.sec_preAffine_FF, f3h_iter_FF.sec_postAffine_FF[1:], "")
            _MSG: str = f"FF PRE affine values ALL copied into the FF POST affine."
            
        flam3h_general_utils.set_status_msg(f"{self.node.name()}: {_MSG}", 'IMP')
            
            
    def prm_paste_sel_FF(self) -> None:
        """Paste only sections of a FF.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """    
        
        node: hou.SopNode = self.node
        
        n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()

        # Marked FF check ( not needed but just in case lets "try" so to speak )
        try:
            from_FLAM3H_NODE_FF_CHECK: TA_M = hou.session.F3H_MARKED_FF_CHECK # type: ignore
        except AttributeError:
            from_FLAM3H_NODE_FF_CHECK: TA_M = None
            
        if from_FLAM3H_NODE_FF_CHECK is not None:
            
            # Marked FF node
            from_FLAM3H_NODE: TA_MNode = hou.session.F3H_MARKED_FF_NODE # type: ignore
            assert isinstance(from_FLAM3H_NODE, hou.SopNode)
            
            # Get user selection of paste methods
            prm_sel = node.parm(f"{f3h_ffPrmPrx.PRM}{n.main_prmpastesel}")
            paste_sel_FF: int = prm_sel.eval()
            prm_selmem_FF = node.parm(f"{f3h_ffPrmPrx.PRM}{n.main_selmem}")
            flam3h_prm_utils.set(node, prm_selmem_FF, paste_sel_FF)
            
            f3h_iter_FF: flam3h_iterator_FF = flam3h_iterator_FF()
            
            match paste_sel_FF:
                
                # set FF ALL
                case 1:
                    self.prm_paste_FF_CTRL()
                    
                # set FF PRE VARS
                case 2:
                    self.pastePRM_T_from_list(node, from_FLAM3H_NODE, f3h_iter_FF.sec_prevarsT_FF, flam3h_varsPRM_FF(f3h_ffPrmPrx.PRM_PP).varsPRM_FF(), "", "")
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter_FF.sec_prevarsW_FF, "", "")
                    self.paste_set_note(node, from_FLAM3H_NODE, 2, f3h_copyPaste.DEFAULT_SEC_PREVARS, "", "")
                    
                # set FF VARS
                case 3:
                    self.pastePRM_T_from_list(node, from_FLAM3H_NODE, f3h_iter_FF.sec_varsT_FF, flam3h_varsPRM_FF(f3h_ffPrmPrx.PRM).varsPRM_FF(), "", "")
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter_FF.sec_varsW_FF, "", "")
                    self.paste_set_note(node, from_FLAM3H_NODE, 2, f3h_copyPaste.DEFAULT_SEC_VARS, "", "")
                    
                # set FF POST VARS
                case 4:
                    self.pastePRM_T_from_list(node, from_FLAM3H_NODE, f3h_iter_FF.sec_postvarsT_FF, flam3h_varsPRM_FF(f3h_ffPrmPrx.PRM_PP).varsPRM_FF(), "", "")
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter_FF.sec_postvarsW_FF, "", "")
                    self.paste_set_note(node, from_FLAM3H_NODE, 2, f3h_copyPaste.DEFAULT_SEC_POSTVARS, "", "")
                    
                # set FF PRE AFFINE
                case 5:
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter_FF.sec_preAffine_FF, "", "")
                    if not self.is_FF_affine_default(node, from_FLAM3H_NODE, f3h_iter_FF.sec_preAffine_FF):
                        self.paste_set_note(node, from_FLAM3H_NODE, 2, f3h_copyPaste.DEFAULT_SEC_PREAFFINE, "", "")
                        
                # set FF POST AFFINE
                case 6:
                    self.paste_from_list(node, from_FLAM3H_NODE, f3h_iter_FF.sec_postAffine_FF, "", "")
                    if not self.is_FF_affine_default(node, from_FLAM3H_NODE, f3h_iter_FF.sec_postAffine_FF, True):
                        self.paste_set_note(node, from_FLAM3H_NODE, 2, f3h_copyPaste.DEFAULT_SEC_POSTAFFINE, "", "")

            flam3h_prm_utils.set(node, prm_sel, 0)
            # Delete all keyframes from the copy/paste menu parameter
            # This node parameter has been unlocked and cleared already from the above definition
            if from_FLAM3H_NODE is not None:
                from_prm_sel = from_FLAM3H_NODE.parm(f"{f3h_ffPrmPrx.PRM}{n.main_prmpastesel}")
                from_prm_sel.lock(False)
                from_prm_sel.deleteAllKeyframes()
                    
        else:
            _MSG: str = f"{node.name()} -> {f3h_copyPaste.DEFAULT_MSG_MARK_FF_STATUS_BAR}"
            flam3h_general_utils.set_status_msg(_MSG, 'WARN')
            

    def flam3h_xaos_convert(self) -> None:
        """Here I am using a class function call from: out_flame_utils.out_xf_xaos_from()</br>
        down below inside the save XML/FLAME file section of this file.</br>
        The class function: out_flame_utils.out_xf_xaos_from(0) convert xaos from TO to FROM and back in one call.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        # Check and Update this data
        self.update_xml_last_loaded()
        
        node: hou.SopNode = self.node
        # AUTO DIV XAOS strings
        div_xaos, div_weight = self.auto_set_xaos_div_str(node)
        
        # Get xaos
        f3d: out_flame_utils = out_flame_utils(self.kwargs)
        # Convert xaos
        xaos_new: tuple[str, ...] = f3d.out_xf_xaos_from(0)
        # update parameterUserData: flam3h_xaos_iterators_prev
        self.auto_set_xaos_data_set_XAOS_PREV(node, xaos_new)
        
        prm_xaos: str = flam3h_iterator_prm_names().xaos
        for idx in range(f3d.iter_count):
            # Build
            value: str = div_xaos
            if xaos_new[idx]:
                value += div_weight.join(xaos_new[idx].split())
            # Set
            prm = node.parm(f"{prm_xaos}_{idx + 1}")
            flam3h_prm_utils.set(node, prm, value)

        # Get preference xaos mode and print to Houdini's status bar
        if f3d.xm:
            _MSG: str = f"{node.name()}: Xaos mode: FROM"
        else:
            _MSG: str = f"{node.name()}: Xaos mode: TO"
        flam3h_general_utils.set_status_msg(_MSG, 'IMP')


    def reset_preaffine(self) -> None:
        """Reset an iterator pre affine values to their defaults.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
        s_mp_index: int = self.kwargs['script_multiparm_index']
        check = True
        
        current: dict = { "affine_x": node.parmTuple(f"{n.preaffine_x}_{s_mp_index}"), "affine_y": node.parmTuple(f"{n.preaffine_y}_{s_mp_index}"), "affine_o": node.parmTuple(f"{n.preaffine_o}_{s_mp_index}"), "angle": node.parm(f"{n.preaffine_ang}_{s_mp_index}") }
        
        if self.kwargs["shift"]:
            for prm in (current["affine_x"], current["affine_y"]):
                prm.lock(False)
                prm.deleteAllKeyframes()
            for key in list(f3h_affineDefaults.DEFAULT_DICT.keys())[:1]:
                if current[key].eval() != f3h_affineDefaults.DEFAULT_DICT.get(key):
                    check = False
                    # pre affine
                    current["affine_x"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_x"))
                    current["affine_y"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_y"))
                    # Print to Houdini's status bar
                    _MSG: str = f"{node.name()}: Iterator.{s_mp_index} PRE Affine X and Y -> RESET"
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                    break
            if check:
                _MSG: str = f"{node.name()}: Iterator.{s_mp_index} PRE Affine X and Y -> already at their default values."
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
        elif self.kwargs["ctrl"]:
            current["affine_o"].lock(False)
            current["affine_o"].deleteAllKeyframes()
            if current["affine_o"].eval() != f3h_affineDefaults.DEFAULT_DICT.get("affine_o"):
                check = False
                current["affine_o"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_o"))
                # Print to Houdini's status bar
                _MSG: str = f"{node.name()}: Iterator.{s_mp_index} PRE Affine OFFSET -> RESET"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            if check:
                _MSG: str = f"{node.name()}: Iterator.{s_mp_index} PRE Affine OFFSET -> already at its default values."
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
        elif self.kwargs["alt"]:
            current["angle"].lock(False)
            current["angle"].deleteAllKeyframes()
            if current["angle"].eval() != f3h_affineDefaults.DEFAULT_DICT.get("angle"):
                check = False
                current["angle"].set(f3h_affineDefaults.DEFAULT_DICT.get("angle"))
                # Print to Houdini's status bar
                _MSG: str = f"{node.name()}: Iterator.{s_mp_index} PRE Affine ROT Angle -> RESET"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            if check:
                _MSG: str = f"{node.name()}: Iterator.{s_mp_index} PRE Affine ROT Angle -> already at its default values."
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            
        else:
            for prm in current.values():
                prm.lock(False)
                prm.deleteAllKeyframes()
            for key in list(f3h_affineDefaults.DEFAULT_DICT.keys()):
                if current[key].eval() != f3h_affineDefaults.DEFAULT_DICT[key]:
                    check = False
                    # pre affine
                    current["affine_x"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_x"))
                    current["affine_y"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_y"))
                    current["affine_o"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_o"))
                    current["angle"].set(f3h_affineDefaults.DEFAULT_DICT.get("angle"))
                    # Print to Houdini's status bar
                    _MSG: str = f"{node.name()}: Iterator.{s_mp_index} PRE Affine ALL -> RESET"
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                    break
            if check:
                _MSG: str = f"{node.name()}: Iterator.{s_mp_index} PRE Affine ALL -> already at their default values."
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')


    def reset_postaffine(self) -> None:
        """Reset an iterator post affine values to their defaults.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
        s_mp_index: int = self.kwargs['script_multiparm_index']
        
        if node.parm(f"{n.postaffine_do}_{s_mp_index}").eval(): # This can be omitted as the post affine tab wont be accessible if this toggle is off.
                
            check: bool = True
            current: dict = { "affine_x": node.parmTuple(f"{n.postaffine_x}_{s_mp_index}"), "affine_y": node.parmTuple(f"{n.postaffine_y}_{s_mp_index}"), "affine_o": node.parmTuple(f"{n.postaffine_o}_{s_mp_index}"), "angle": node.parm(f"{n.postaffine_ang}_{s_mp_index}") }
                
            if self.kwargs["shift"]:
                for prm in (current["affine_x"], current["affine_y"]):
                    prm.lock(False)
                    prm.deleteAllKeyframes()
                for key in list(f3h_affineDefaults.DEFAULT_DICT.keys())[:1]:
                    if current[key].eval() != f3h_affineDefaults.DEFAULT_DICT[key]:
                        check = False
                        # pre affine
                        current["affine_x"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_x"))
                        current["affine_y"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_y"))
                        # Print to Houdini's status bar
                        _MSG: str = f"{node.name()}: Iterator.{s_mp_index} POST Affine X and Y -> RESET"
                        flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                        break
                if check:
                    _MSG: str = f"{node.name()}: Iterator.{s_mp_index} POST Affine X and Y -> already at their default values."
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                    
            elif self.kwargs["ctrl"]:
                current["affine_o"].lock(False)
                current["affine_o"].deleteAllKeyframes()
                if current["affine_o"].eval() != f3h_affineDefaults.DEFAULT_DICT.get("affine_o"):
                    check = False
                    current["affine_o"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_o"))
                    # Print to Houdini's status bar
                    _MSG: str = f"{node.name()}: Iterator.{s_mp_index} POST Affine OFFSET -> RESET"
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                if check:
                    _MSG: str = f"{node.name()}: Iterator.{s_mp_index} POST Affine OFFSET -> already at its default values."
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                    
            elif self.kwargs["alt"]:
                current["angle"].lock(False)
                current["angle"].deleteAllKeyframes()
                if current["angle"].eval() != f3h_affineDefaults.DEFAULT_DICT.get("angle"):
                    check = False
                    # post affine
                    current["angle"].set(f3h_affineDefaults.DEFAULT_DICT.get("angle"))
                    # Print to Houdini's status bar
                    _MSG: str = f"{node.name()}: Iterator.{s_mp_index} POST Affine ROT Angle -> RESET"
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                if check:
                    _MSG: str = f"{node.name()}: Iterator.{s_mp_index} POST Affine ROT Angle -> already at its default value."
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
            else:
                for prm in current.values():
                    prm.lock(False)
                    prm.deleteAllKeyframes()
                for key in list(f3h_affineDefaults.DEFAULT_DICT.keys()):
                    if current[key].eval() != f3h_affineDefaults.DEFAULT_DICT[key]:
                        check = False
                        # post affine
                        current["affine_x"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_x"))
                        current["affine_y"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_y"))
                        current["affine_o"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_o"))
                        current["angle"].set(f3h_affineDefaults.DEFAULT_DICT.get("angle"))
                        # Print to Houdini's status bar
                        _MSG: str = f"{node.name()}: Iterator.{s_mp_index} POST Affine ALL -> RESET"
                        flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                        break
                if check:
                    _MSG: str = f"{node.name()}: Iterator.{s_mp_index} POST Affine ALL -> already at their default values."
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
        
        
    def reset_preaffine_FF(self) -> None:
        """Reset FF pre affine values to their defaults.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
        check: bool = True
        
        current: dict = { "affine_x": node.parmTuple(f"{f3h_ffPrmPrx.PRM}{n.preaffine_x}"), "affine_y": node.parmTuple(f"{f3h_ffPrmPrx.PRM}{n.preaffine_y}"), "affine_o": node.parmTuple(f"{f3h_ffPrmPrx.PRM}{n.preaffine_o}"), "angle": node.parm(f"{f3h_ffPrmPrx.PRM}{n.preaffine_ang}") }
            
        if self.kwargs["shift"]:
            for prm in (current["affine_x"], current["affine_y"]):
                prm.lock(False)
                prm.deleteAllKeyframes()
            for key in list(f3h_affineDefaults.DEFAULT_DICT.keys())[:1]:
                if current[key].eval() != f3h_affineDefaults.DEFAULT_DICT[key]:
                    check = False
                    # pre affine
                    current["affine_x"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_x"))
                    current["affine_y"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_y"))
                    # Print to Houdini's status bar
                    _MSG: str = f"{node.name()}: FF PRE Affine X and Y -> RESET"
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                    break
            if check:
                _MSG: str = f"{node.name()}: FF PRE Affine X and Y -> already at their default values."
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')

        elif self.kwargs["ctrl"]:
            current["affine_o"].lock(False)
            current["affine_o"].deleteAllKeyframes()
            if current["affine_o"].eval() != f3h_affineDefaults.DEFAULT_DICT.get("affine_o"):
                check = False
                current["affine_o"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_o"))
                # Print to Houdini's status bar
                _MSG: str = f"{node.name()}: FF PRE Affine OFFSET -> RESET"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            if check:
                _MSG: str = f"{node.name()}: FF PRE Affine OFFSET -> already at its default values."
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
        elif self.kwargs["alt"]:
            current["angle"].lock(False)
            current["angle"].deleteAllKeyframes()
            if current["angle"].eval() != f3h_affineDefaults.DEFAULT_DICT.get("angle"):
                check = False
                current["angle"].set(f3h_affineDefaults.DEFAULT_DICT.get("angle"))
                # Print to Houdini's status bar
                _MSG: str = f"{node.name()}: FF PRE Affine ROT Angle -> RESET"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            if check:
                _MSG: str = f"{node.name()}: FF PRE Affine ROT Angle -> already at its default value."
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
        else:
            for prm in current.values():
                prm.lock(False)
                prm.deleteAllKeyframes()
            for key in list(f3h_affineDefaults.DEFAULT_DICT.keys()):
                if current[key].eval() != f3h_affineDefaults.DEFAULT_DICT[key]:
                    check = False
                    # pre affine
                    current["affine_x"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_x"))
                    current["affine_y"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_y"))
                    current["affine_o"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_o"))
                    current["angle"].set(f3h_affineDefaults.DEFAULT_DICT.get("angle"))
                    # Print to Houdini's status bar
                    _MSG: str = f"{node.name()}: FF PRE Affine ALL -> RESET"
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                    break
            if check:
                _MSG: str = f"{node.name()}: FF PRE Affine ALL -> already at their default values."
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')


    def reset_postaffine_FF(self) -> None:
        """Reset FF post affine values to their defaults.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
        
        if node.parm(f"{f3h_ffPrmPrx.PRM}{n.postaffine_do}").eval(): # This can be omitted as the post affine tab wont be accessible if this toggle is off.
                
            check: bool = True
            current: dict = { "affine_x": node.parmTuple(f"{f3h_ffPrmPrx.PRM}{n.postaffine_x}"), "affine_y": node.parmTuple(f"{f3h_ffPrmPrx.PRM}{n.postaffine_y}"), "affine_o": node.parmTuple(f"{f3h_ffPrmPrx.PRM}{n.postaffine_o}"), "angle": node.parm(f"{f3h_ffPrmPrx.PRM}{n.postaffine_ang}") }
            
            if self.kwargs["shift"]:
                for prm in (current["affine_x"], current["affine_y"]):
                    prm.lock(False)
                    prm.deleteAllKeyframes()
                for key in list(f3h_affineDefaults.DEFAULT_DICT.keys())[:1]:
                    if current[key].eval() != f3h_affineDefaults.DEFAULT_DICT[key]:
                        check = False
                        # pre affine
                        current["affine_x"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_x"))
                        current["affine_y"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_y"))
                        # Print to Houdini's status bar
                        _MSG: str = f"{node.name()}: FF POST Affine X and Y -> RESET"
                        flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                        break
                if check:
                    _MSG: str = f"{node.name()}: FF POST Affine X and Y -> already at their default values."
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                    
            elif self.kwargs["ctrl"]:
                current["affine_o"].lock(False)
                current["affine_o"].deleteAllKeyframes()
                if current["affine_o"].eval() != f3h_affineDefaults.DEFAULT_DICT.get("affine_o"):
                    check = False
                    current["affine_o"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_o"))
                    # Print to Houdini's status bar
                    _MSG: str = f"{node.name()}: FF POST Affine OFFSET -> RESET"
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                if check:
                    _MSG: str = f"{node.name()}: FF POST Affine OFFSET -> already at their default values."
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
            elif self.kwargs["alt"]:
                current["angle"].lock(False)
                current["angle"].deleteAllKeyframes()
                if current["angle"].eval() != f3h_affineDefaults.DEFAULT_DICT.get("angle"):
                    check = False
                    # post affine
                    current["angle"].set(f3h_affineDefaults.DEFAULT_DICT.get("angle"))
                    # Print to Houdini's status bar
                    _MSG: str = f"{node.name()}: FF POST Affine ROT Angle -> RESET"
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                if check:
                    _MSG: str = f"{node.name()}: FF POST Affine ROT Angle -> already at their default value."
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')

            else:
                for prm in current.values():
                    prm.lock(False)
                    prm.deleteAllKeyframes()
                for key in list(f3h_affineDefaults.DEFAULT_DICT.keys()):
                    if current[key].eval() != f3h_affineDefaults.DEFAULT_DICT[key]:
                        check = False
                        # post affine
                        current["affine_x"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_x"))
                        current["affine_y"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_y"))
                        current["affine_o"].set(f3h_affineDefaults.DEFAULT_DICT.get("affine_o"))
                        current["angle"].set(f3h_affineDefaults.DEFAULT_DICT.get("angle"))
                        # Print to Houdini's status bar
                        _MSG: str = f"{node.name()}: FF POST Affine ALL -> RESET"
                        flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                        break
                if check:
                    _MSG: str = f"{node.name()}: FF POST Affine ALL -> already at their default values."
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')


    def swap_iter_pre_vars(self) -> None:
        """Swap the selected iterator PRE vars order or swap only their names.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        
        node: hou.SopNode = self.node
        
        # Check and Update this data
        self.update_xml_last_loaded()
        
        s_mp_index: int = self.kwargs['script_multiparm_index']
        _MSG: str = f"{node.name()}.iterator.{s_mp_index} PRE variations -> SWAP"
        
        # Get prm names
        pvT: tuple[str, ...] = flam3h_iterator().sec_prevarsT
        pvW: tuple[tuple[str, int], ...] = flam3h_iterator().sec_prevarsW[1:]
        
        # Get prm
        pvT_prm: tuple[hou.Parm, ...] = (node.parm(f"{pvT[0]}{s_mp_index}"), node.parm(f"{pvT[1]}{s_mp_index}"))
        pvW_prm: tuple[hou.Parm, ...] = (node.parm(f"{pvW[0][0]}{s_mp_index}"), node.parm(f"{pvW[1][0]}{s_mp_index}"))
        # get tmp prm
        __pvT_prm: tuple[hou.Parm, ...] = (node.parm(f3h_tabs.PREFS.PVT_PRM_INT_0), node.parm(f3h_tabs.PREFS.PVT_PRM_INT_1))
        __pvW_prm: tuple[hou.Parm, ...] = (node.parm(f3h_tabs.PREFS.PVT_PRM_FLOAT_0), node.parm(f3h_tabs.PREFS.PVT_PRM_FLOAT_1))
        
        # Only types
        if self.kwargs["ctrl"]:
            
            # COPY TYPES into tmp
            self.paste_from_prm(pvT_prm[0], __pvT_prm[0], True)
            self.paste_from_prm(pvT_prm[1], __pvT_prm[1], True)
            # SWAP TYPES from tmp
            self.paste_from_prm(__pvT_prm[0], pvT_prm[1])
            self.paste_from_prm(__pvT_prm[1], pvT_prm[0])
            # Clear tmp parms so in case of keyframes or expression they wont evaluate
            self.tmp_prm_clear_and_reset(node, __pvT_prm[0], __pvT_prm[1])
            
            flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            
        # Types and their weights
        else:
            
            # COPY TYPES into tmp
            self.paste_from_prm(pvT_prm[0], __pvT_prm[0], True)
            self.paste_from_prm(pvT_prm[1], __pvT_prm[1], True)
            # SWAP TYPES from tmp
            self.paste_from_prm(__pvT_prm[0], pvT_prm[1])
            self.paste_from_prm(__pvT_prm[1], pvT_prm[0])
            # Clear tmp parms so in case of keyframes or expression they wont evaluate
            self.tmp_prm_clear_and_reset(node, __pvT_prm[0], __pvT_prm[1])

            # COPY WEIGHTS into tmp
            self.paste_from_prm(pvW_prm[0], __pvW_prm[0], True)
            self.paste_from_prm(pvW_prm[1], __pvW_prm[1], True)
            # SWAP WEIGHTS from tmp
            self.paste_from_prm(__pvW_prm[0], pvW_prm[1])
            self.paste_from_prm(__pvW_prm[1], pvW_prm[0])
            # Clear tmp parms so in case of keyframes or expression they wont evaluate
            self.tmp_prm_clear_and_reset(node, __pvW_prm[0], __pvW_prm[1])
            
            flam3h_general_utils.set_status_msg(_MSG, 'IMP')
            
                
    def swap_FF_post_vars(self) -> None:
        """Swap the FF iterator POST vars order or swap only their names.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        _MSG: str = f"{node.name()}: FF POST variations -> SWAP"
        
        # Get prm names
        pvT: tuple[str, ...] = flam3h_iterator_FF().sec_postvarsT_FF
        pvW: tuple[tuple[str, int], ...] = flam3h_iterator_FF().sec_postvarsW_FF
        
        # Get prm
        pvT_prm: tuple[hou.Parm, ...] = (node.parm(f"{pvT[0]}"), node.parm(f"{pvT[1]}"))
        pvW_prm: tuple[hou.Parm, ...] = (node.parm(f"{pvW[0][0]}"), node.parm(f"{pvW[1][0]}"))
        # get tmp prm
        __pvT_prm: tuple[hou.Parm, ...] = (node.parm(f3h_tabs.PREFS.PVT_PRM_INT_0), node.parm(f3h_tabs.PREFS.PVT_PRM_INT_1))
        __pvW_prm: tuple[hou.Parm, ...] = (node.parm(f3h_tabs.PREFS.PVT_PRM_FLOAT_0), node.parm(f3h_tabs.PREFS.PVT_PRM_FLOAT_1))
        
        # Only types
        if self.kwargs["ctrl"]:
            
            # Copy types into tmp
            self.paste_from_prm(pvT_prm[0], __pvT_prm[0], True)
            self.paste_from_prm(pvT_prm[1], __pvT_prm[1], True)
            # Swap types from tmp
            self.paste_from_prm(__pvT_prm[0], pvT_prm[1])
            self.paste_from_prm(__pvT_prm[1], pvT_prm[0])
            # Clear tmp prm so in case of keyframes or expression it doesnt evaluate
            self.tmp_prm_clear_and_reset(node, __pvT_prm[0], __pvT_prm[1])
            
            flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            
        # Types and their weights
        else:
            
            # Copy types into tmp
            self.paste_from_prm(pvT_prm[0], __pvT_prm[0], True)
            self.paste_from_prm(pvT_prm[1], __pvT_prm[1], True)
            # Swap types from tmp
            self.paste_from_prm(__pvT_prm[0], pvT_prm[1])
            self.paste_from_prm(__pvT_prm[1], pvT_prm[0])
            # Clear tmp prm so in case of keyframes or expression it doesnt evaluate
            self.tmp_prm_clear_and_reset(node, __pvT_prm[0], __pvT_prm[1])

            # Copy weights into tmp
            self.paste_from_prm(pvW_prm[0], __pvW_prm[0], True)
            self.paste_from_prm(pvW_prm[1], __pvW_prm[1], True)
            # Swap types from tmp
            self.paste_from_prm(__pvW_prm[0], pvW_prm[1])
            self.paste_from_prm(__pvW_prm[1], pvW_prm[0])
            # Clear tmp prm so in case of keyframes or expression it doesnt evaluate
            self.tmp_prm_clear_and_reset(node, __pvW_prm[0], __pvW_prm[1])
            
            flam3h_general_utils.set_status_msg(_MSG, 'IMP')


    def flam3h_default(self) -> None:
        """Default Flame preset and FLAM3H™ settings parameters vaules on creation.</br>
        This is used to reset back FLAM3H™ node entire parameter template.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        
        node: hou.SopNode = self.node
        # Clear menu cache
        self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
        self.destroy_cachedUserData(node, f3h_cachedUserData.edge_case_01)
        self.destroy_all_menus_data(node, False)
        # Iterators reset
        in_flame_utils(self.kwargs).in_to_flam3h_reset_iterators_parms(node, 3)
        # update xaos
        self.auto_set_xaos()
        # resets Tab contexts
        self.flam3h_reset_FF()
        flam3h_general_utils(self.kwargs).reset_SYS(1, f3h_tabs.GLB.DEFAULT_ITERATIONS, 1)
        flam3h_palette_utils(self.kwargs).reset_CP()
        flam3h_general_utils(self.kwargs).reset_MB()
        in_flame_utils(self.kwargs).reset_IN()
        out_flame_utils(self.kwargs).reset_OUT(1) # dnt clear the MSG_OUT if any
        flam3h_general_utils(self.kwargs).reset_PREFS()
        # Reset/Set density
        flam3h_general_utils.reset_density(node)
        # Updated the OUT preset name if needed
        out_flame_utils(self.kwargs).out_auto_change_iter_num_to_prm()
        # Sierpiński triangle settings
        self.sierpinski_settings(node)
        # OUT render curves reset and set
        out_flame_utils.out_render_curves_set_and_retrieve_defaults(node)
        # init/clear copy/paste iterator's data and prm if needed.
        self.flam3h_paste_reset_hou_session_data()
        # BUILD XFVIZ
        flam3h_general_utils.util_xf_viz_force_cook(node, self.kwargs)
        
        # Destroy data
        flam3h_iterator_utils.destroy_userData(node, f3h_userData.XML_LAST)
        
        # Print if the node has its display flag ON
        if node.isGenericFlagSet(hou.nodeFlag.Display): # type: ignore
            # Print to Houdini's status bar
            _MSG: str = f"{node.name()}: LOAD Flame preset: \"Sierpiński triangle\" -> Completed"
            flam3h_general_utils.set_status_msg(_MSG, 'IMP')
            flam3h_general_utils.flash_message(node, f"Sierpiński triangle::10")
            
    
    def flam3h_reset_iterator(self) -> None:
        """Reset selected iterator to its default parameter's values.</br>
        Include parametrics too.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        s_mp_index: int = self.kwargs['script_multiparm_index']
        
        # prm names
        n: flam3h_iterator_prm_names_collections = flam3h_iterator_prm_names_collections()

        # Delete all keyframes
        for prm_name in n.prm_iterator:
            prm = node.parm(f"{prm_name}_{s_mp_index}")
            prm.lock(False)
            prm.deleteAllKeyframes()
        for prm_name in n.prm_iterator_tuple:
            prm = node.parmTuple(f"{prm_name}_{s_mp_index}")
            prm.lock(False)
            prm.deleteAllKeyframes()
        # Delete all keyframes parametrics and revert to defaults
        for prm_name in n.prm_parametrics:
            prm = node.parm(f"{prm_name}_{s_mp_index}")
            prm.lock(False)
            prm.deleteAllKeyframes()
            prm.revertToDefaults()
        for prm_name in n.prm_parametrics_tuple:
            prm = node.parmTuple(f"{prm_name}_{s_mp_index}")
            prm.lock(False)
            prm.deleteAllKeyframes()
            prm.revertToDefaults()

        # iter idx
        #
        # iter main
        node.setParms(  # type: ignore
                        {f"{n.main_note}_{s_mp_index}": f"iterator_{s_mp_index}", 
                        f"{n.main_weight}_{s_mp_index}": 0.5}
                        )
        
        # We leave xaos untouched becasue its handy to keep it and just reset it in a second step if desired
        #
        # iter shader
        node.setParms(  # type: ignore
                        {f"{n.shader_color}_{s_mp_index}": 0, 
                        f"{n.shader_speed}_{s_mp_index}": 0, 
                        f"{n.shader_alpha}_{s_mp_index}": 1.0}
                        )

        # iter vars
        for prm in n.prm_iterator_vars_all:
            prm_name: str = f"{prm}_{s_mp_index}"
            node.parm(prm_name).set(1) if prm == n.var_weight_1 else node.parm(prm_name).set(0)
        
        # Iterator Affines
        parms_affines_dict: dict[str, hou.Vector2 | float | None] = {   
                                                                    f"{n.preaffine_x}_{s_mp_index}": f3h_affineDefaults.DEFAULT_DICT.get("affine_x"),
                                                                    f"{n.preaffine_y}_{s_mp_index}": f3h_affineDefaults.DEFAULT_DICT.get("affine_y"),
                                                                    f"{n.preaffine_o}_{s_mp_index}": f3h_affineDefaults.DEFAULT_DICT.get("affine_o"),
                                                                    f"{n.preaffine_ang}_{s_mp_index}": f3h_affineDefaults.DEFAULT_DICT.get("angle"),
                                                                    f"{n.postaffine_do}_{s_mp_index}": 0,
                                                                    f"{n.postaffine_x}_{s_mp_index}": f3h_affineDefaults.DEFAULT_DICT.get("affine_x"),
                                                                    f"{n.postaffine_y}_{s_mp_index}": f3h_affineDefaults.DEFAULT_DICT.get("affine_y"),
                                                                    f"{n.postaffine_o}_{s_mp_index}": f3h_affineDefaults.DEFAULT_DICT.get("affine_o"),
                                                                    f"{n.postaffine_ang}_{s_mp_index}": f3h_affineDefaults.DEFAULT_DICT.get("angle")
                                                                    }
        
        flam3h_prm_utils.setParms(node, parms_affines_dict)
    
    
    def flam3h_reset_FF(self) -> None:
        """Reset the FLAM3H™ FF Tab parameters.</br>
        Include parametrics too (PRE, VAR and POST)</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node

        # prm names
        n: flam3h_iterator_prm_names_collections = flam3h_iterator_prm_names_collections()
        
        # Delete all keyframes and revert to defaults
        #
        # For FF tuple and normal params
        for prm_name in n.prm_FF:
            prm = node.parm(f"{f3h_ffPrmPrx.PRM}{prm_name}")
            prm.lock(False)
            prm.deleteAllKeyframes()
            prm.revertToDefaults()
            
        for prm_name in n.prm_FF_tuple:
            prm = node.parmTuple(f"{f3h_ffPrmPrx.PRM}{prm_name}")
            prm.lock(False)
            prm.deleteAllKeyframes()
            prm.revertToDefaults()

        # For parametrics (PRE and POST)
        for prm_name in n.prm_parametrics:
            for prefix in (f3h_ffPrmPrx.PRM, f3h_ffPrmPrx.PRM_PP):
                prm = node.parm(f"{prefix}_{prm_name}")
                prm.lock(False)
                prm.deleteAllKeyframes()
                prm.revertToDefaults()
                
        for prm_name in n.prm_parametrics_tuple:
            for prefix in (f3h_ffPrmPrx.PRM, f3h_ffPrmPrx.PRM_PP):
                prm = node.parmTuple(f"{prefix}_{prm_name}")
                prm.lock(False)
                prm.deleteAllKeyframes()
                prm.revertToDefaults()

        # FF note
        node.parm(f"{f3h_ffPrmPrx.PRM}{n.main_note}").set("iterator_FF")
        
        # FF vars        
        for prm_name in n.prm_FF_vars_all:
            value = 1 if prm_name == n.var_weight_1 else 0
            prm = node.parm(f"{f3h_ffPrmPrx.PRM}{prm_name}")
            node.parm(f"{f3h_ffPrmPrx.PRM}{prm_name}").set(value)

        # FF Affines
        parms_affines_dict: dict[str, hou.Vector2 | float | None] = {f"{f3h_ffPrmPrx.PRM}{n.preaffine_x}": f3h_affineDefaults.DEFAULT_DICT.get("affine_x"),
                                                                     f"{f3h_ffPrmPrx.PRM}{n.preaffine_y}": f3h_affineDefaults.DEFAULT_DICT.get("affine_y"),
                                                                     f"{f3h_ffPrmPrx.PRM}{n.preaffine_o}": f3h_affineDefaults.DEFAULT_DICT.get("affine_o"),
                                                                     f"{f3h_ffPrmPrx.PRM}{n.preaffine_ang}": f3h_affineDefaults.DEFAULT_DICT.get("angle"),
                                                                     f"{f3h_ffPrmPrx.PRM}{n.postaffine_do}": 0,
                                                                     f"{f3h_ffPrmPrx.PRM}{n.postaffine_x}": f3h_affineDefaults.DEFAULT_DICT.get("affine_x"),
                                                                     f"{f3h_ffPrmPrx.PRM}{n.postaffine_y}": f3h_affineDefaults.DEFAULT_DICT.get("affine_y"),
                                                                     f"{f3h_ffPrmPrx.PRM}{n.postaffine_o}": f3h_affineDefaults.DEFAULT_DICT.get("affine_o"),
                                                                     f"{f3h_ffPrmPrx.PRM}{n.postaffine_ang}": f3h_affineDefaults.DEFAULT_DICT.get("angle")
                                                                    }
        
        flam3h_prm_utils.setParms(node, parms_affines_dict)


    def auto_set_xaos(self) -> None:
        """Set iterator's xaos values every time an iterator is added or removed.</br>
        It will also update the data for the xform handles VIZ SOLO mode if Active.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        
        node: hou.SopNode = self.node
        n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
        iter_count: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        # AUTO DIV XAOS strings
        div_xaos, div_weight = self.auto_set_xaos_div_str(node)
        
        # PRM DATA
        prm_mpidx = node.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX)
        # PRM XF VIZ
        prm_xfviz = node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ)
        prm_xfviz_solo = node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO)
        prm_xfviz_solo_mp_idx = node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX)
        _PVT_PARMS: tuple[hou.Parm, ...] = (prm_mpidx, prm_xfviz, prm_xfviz_solo, prm_xfviz_solo_mp_idx)
        # unlock
        for prm in _PVT_PARMS:
            prm.lock(False)
            prm.deleteAllKeyframes()
        
        # XF VIZ data name
        data_name: str = f"{f3h_userData.PRX}_{f3h_userData.XFVIZ_SOLO}"
        
        # init indexes
        idx_del_inbetween: int | None = None
        idx_add_inbetween: int | None = None
        
        mpmem: list[int] = []
        mpmem_hou_get: list[int] = []
        xaos_str_hou_get: list[list[str]] = []
        
        # get mpmem parms now
        mp_mem_name: str = n.main_mpmem
        _mpmem_append: Callable[[int], None] = mpmem.append
        for mp_idx in range(1, iter_count + 1): _mpmem_append(int(node.parm(f"{mp_mem_name}_{mp_idx}").eval()))
        
        # get mpmem from CachedUserData
        __mpmem_hou_get: list[int] | None = self.auto_set_xaos_data_get_MP_MEM(node)
        if __mpmem_hou_get is None:
            mpmem_hou_get = mpmem
        else:
            mpmem_hou_get = __mpmem_hou_get
        
        # collect all xaos
        val: TA_XAOS_Collect = out_flame_utils.out_xaos_collect(node, iter_count, n.xaos)
        # fill missing weights if any
        fill_all_xaos: list[list[float]] = [np_pad(item, (0, iter_count - len(item)), 'constant', constant_values = 1).tolist() for item in val]
        # convert all xaos into array of strings
        xaos_str: list[list[str]] = [[str(item) for item in xaos] for xaos in fill_all_xaos]
        
        # get xaos from CachedUserData
        __xaos_str_hou_get: list[list[str]] | None = self.auto_set_xaos_data_get_XAOS_PREV(node)
        if __xaos_str_hou_get is None:
            xaos_str_hou_get = xaos_str
        else:
            xaos_str_hou_get = __xaos_str_hou_get
            
        # Check if our current set of iterators is different from the history
        s_current: set = set(mpmem)
        s_history: set = set(mpmem_hou_get)
        _idx: list[int] = list(set(s_history - s_current))
        
        _XAOS_UPDATE: bool = False
        
        # If we added or removed multiple iterators in one go.
        # e.g. setting the iterators count from 6 to 3 (what we are interested in, but the other way around is also a possibility)
        if len(_idx) > 1:
            
            # if we removed
            if (len(s_history) > len(s_current)):
                
                _ITER_DEL: bool = False
                _XF_VIZ_DEL: bool = False
                
                # Clear menu cache
                self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)

                # update the xaos history
                # update parameterUserData: flam3h_xaos_iterators_prev
                self.auto_set_xaos_data_set_XAOS_PREV(node, xaos_str)
                
                # Update copy/paste iterator's index if there is a need to do so
                try:
                    flam3h_node_mp_id: TA_M = hou.session.F3H_MARKED_ITERATOR_MP_IDX # type: ignore
                except AttributeError:
                    flam3h_node_mp_id: TA_M = None
                
                if flam3h_node_mp_id is not None:
                    # Check if the node still exist
                    try:
                        hou.session.F3H_MARKED_ITERATOR_NODE.type() # type: ignore
                        
                    except (AttributeError, hou.ObjectWasDeleted):
                        flam3h_node: TA_MNode = None
                        
                    else:
                        flam3h_node: TA_MNode = hou.session.F3H_MARKED_ITERATOR_NODE # type: ignore
                        
                    # If the node exist
                    if node == flam3h_node:
                            
                        # did we have a marked iterator inside the group we just removed ?
                        if flam3h_node_mp_id > len(s_current):
                            
                            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = None # type: ignore
                            # set
                            prm_mpidx.set(-1)
                            self.del_comment_and_user_data_iterator(node)
                            # Let us know
                            _ITER_DEL = True
                        
                # XF VIZ
                if prm_xfviz.eval() and prm_xfviz_solo.eval():
                    
                    xf_viz_mp_idx: int = prm_xfviz_solo_mp_idx.eval()
                    if xf_viz_mp_idx  > len(s_current):
                        prm_xfviz_solo.set(0) # Turn Off iterator xf viz solo mode
                        prm_xfviz_solo_mp_idx.set(0) # Reset mp index to Off value: 0(Zero)
                        self.destroy_userData(node, f"{data_name}")
                        # Let us know
                        _XF_VIZ_DEL = True

                if _ITER_DEL and _XF_VIZ_DEL:
                    _MSG: str = f"{node.name()}: One of the iterators you just removed was marked for being copied and one had its XF VIZ in SOLO mode. Reverted to display all the xforms handles VIZ together. -> {f3h_copyPaste.DEFAULT_MSG_MARK_ITER_STATUS_BAR}"
                    flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                    
                elif _ITER_DEL:
                     _MSG: str = f"{node.name()}: One of the iterators you just removed was marked for being copied -> {f3h_copyPaste.DEFAULT_MSG_MARK_ITER_STATUS_BAR}"
                     flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                     
                elif _XF_VIZ_DEL:
                    _MSG: str = f"{node.name()}: One of the iterators you just removed had its XF VIZ in SOLO mode. Reverted to display all the xforms handles VIZ together."
                    flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                    
                else:
                    pass
                
            # BUILD XFVIZ if needed
            flam3h_general_utils.util_xf_viz_force_cook(node, self.kwargs)
        
        else:
            # We added or removed one iterator
            #
            # DEL: INBETWEEN get index: try
            if _idx: idx_del_inbetween = int(_idx[0]) - 1
            # ADD: INBETWEEN get index: try
            for mp in range(iter_count - 1):
                if mpmem[mp] == mpmem[mp + 1]:
                    idx_add_inbetween = mp
                    break
            
            # Check if Xaos need an update
            if idx_del_inbetween is not None or idx_add_inbetween is not None: _XAOS_UPDATE = True
        
        # If Xaos need to be updated
        if _XAOS_UPDATE:
            
            # DEL -> ONLY LAST ITERATOR
            if idx_del_inbetween is not None and idx_del_inbetween == iter_count:
                
                # Clear menu cache
                self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)

                # update the xaos history
                # update parameterUserData: flam3h_xaos_iterators_prev
                self.auto_set_xaos_data_set_XAOS_PREV(node, xaos_str)
                
                # Update copy/paste iterator's index if there is a need to do so
                try:
                    flam3h_node_mp_id: TA_M = hou.session.F3H_MARKED_ITERATOR_MP_IDX # type: ignore
                except AttributeError:
                    flam3h_node_mp_id: TA_M = None
                
                if flam3h_node_mp_id is not None:
                    # Check if the node still exist
                    try:
                        hou.session.F3H_MARKED_ITERATOR_NODE.type() # type: ignore
                        
                    except (AttributeError, hou.ObjectWasDeleted):
                        flam3h_node: TA_MNode = None
                        
                    else:
                        flam3h_node: TA_MNode = hou.session.F3H_MARKED_ITERATOR_NODE # type: ignore
                        
                    # If the node exist
                    if node == flam3h_node:
                            
                        if (idx_del_inbetween + 1) == flam3h_node_mp_id: # just in case..
                            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = None # type: ignore
                            # set
                            prm_mpidx.set(-1)
                            self.del_comment_and_user_data_iterator(node)
                            # Let us know
                            _MSG: str = f"{node.name()}: The iterator you just removed was marked for being copied -> {f3h_copyPaste.DEFAULT_MSG_MARK_ITER_STATUS_BAR}"
                            flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                        
                # XF VIZ
                if prm_xfviz.eval() and prm_xfviz_solo.eval():
                    
                    xf_viz_mp_idx: int = prm_xfviz_solo_mp_idx.eval()
                    if (idx_del_inbetween + 1) == xf_viz_mp_idx:
                        prm_xfviz_solo.set(0) # Turn Off iterator xf viz solo mode
                        prm_xfviz_solo_mp_idx.set(0) # Reset mp index to Off value: 0(Zero)
                        self.destroy_userData(node, f"{data_name}")
                        # Let us know
                        _MSG: str = f"{node.name()}: The iterators you just removed had its XF VIZ in SOLO mode. Reverted to display all the xforms handles VIZ together."
                        flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                        
                # BUILD XFVIZ if needed
                flam3h_general_utils.util_xf_viz_force_cook(node, self.kwargs)
                        
            # DEL
            elif idx_del_inbetween is not None and idx_del_inbetween < iter_count:
                
                # Clear menu cache
                self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)

                xaos_str = xaos_str_hou_get
                del xaos_str[idx_del_inbetween]
                for x in xaos_str:
                    del x[idx_del_inbetween]

                # update the xaos history
                # update parameterUserData: flam3h_xaos_iterators_prev
                self.auto_set_xaos_data_set_XAOS_PREV(node, xaos_str)
                
                # Update copy/paste iterator's index if there is a need to do so
                try:
                    flam3h_node_mp_id: TA_M = hou.session.F3H_MARKED_ITERATOR_MP_IDX # type: ignore
                except AttributeError:
                    flam3h_node_mp_id: TA_M = None
                
                if flam3h_node_mp_id is not None:
                    # Check if the node still exist
                    try:
                        hou.session.F3H_MARKED_ITERATOR_NODE.type() # type: ignore
                        
                    except (AttributeError, hou.ObjectWasDeleted):
                        flam3h_node: TA_MNode = None
                        
                    else:
                        flam3h_node: TA_MNode = hou.session.F3H_MARKED_ITERATOR_NODE # type: ignore
                        
                    # If the node exist and if it is the selected one
                    if node == flam3h_node:
                            
                        if (idx_del_inbetween + 1) < flam3h_node_mp_id:
                            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = flam3h_node_mp_id - 1 # type: ignore
                            # set
                            idx_new: int = prm_mpidx.eval() - 1
                            prm_mpidx.set(idx_new)
                            self.del_comment_and_user_data_iterator(node)
                            self.set_comment_and_user_data_iterator(node, str(idx_new))

                        elif (idx_del_inbetween + 1) == flam3h_node_mp_id:
                            
                            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = None # type: ignore
                            # set
                            prm_mpidx.set(-1)
                            self.del_comment_and_user_data_iterator(node)
                            # Let us know
                            _MSG: str = f"{node.name()}: The iterator you just removed was marked for being copied -> {f3h_copyPaste.DEFAULT_MSG_MARK_ITER_STATUS_BAR}"
                            flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                            
                        else:
                            pass
                        
                # XF VIZ
                if prm_xfviz.eval() and prm_xfviz_solo.eval():
                    
                    xf_viz_mp_idx: int = prm_xfviz_solo_mp_idx.eval()
                    if (idx_del_inbetween + 1) < xf_viz_mp_idx:
                        prm_xfviz_solo_mp_idx.set(xf_viz_mp_idx - 1)
                        node.setUserData(f"{data_name}", str(xf_viz_mp_idx - 1))
                    elif (idx_del_inbetween + 1) == xf_viz_mp_idx:
                        prm_xfviz_solo.set(0) # Turn Off iterator xf viz solo mode
                        prm_xfviz_solo_mp_idx.set(0) # Reset mp index to Off value: 0(Zero)
                        self.destroy_userData(node, f"{data_name}")
                        # Let us know
                        _MSG: str = f"{node.name()}: The iterators you just removed had its XF VIZ in SOLO mode. Reverted to display all the xforms handles VIZ together."
                        flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                        
                # BUILD XFVIZ if needed
                flam3h_general_utils.util_xf_viz_force_cook(node, self.kwargs)

            # otherwise ADD
            # If it is true that an iterator has been added in between ( 'idx_add_inbetween' not 'None' ) lets add the new weight at index
            elif idx_add_inbetween is not None:
                
                # Clear menu cache
                self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)

                for xidx, x in enumerate(xaos_str):
                    if xidx != idx_add_inbetween:
                        x.insert(idx_add_inbetween, '1.0')
                        # x already had the new iterator weight added to the end of it
                        # so lets remove the last element as it is not longer needed
                        del x[-1]
                        
                # update the xaos history
                # update parameterUserData: flam3h_xaos_iterators_prev
                self.auto_set_xaos_data_set_XAOS_PREV(node, xaos_str)
                
                # Update copy/paste iterator's index if there is a need to do so
                try:
                    flam3h_node_mp_id: TA_M = hou.session.F3H_MARKED_ITERATOR_MP_IDX # type: ignore
                except AttributeError:
                    flam3h_node_mp_id: TA_M = None
                
                if flam3h_node_mp_id is not None:
                    # Check if the node still exist
                    try:
                        hou.session.F3H_MARKED_ITERATOR_NODE.type() # type: ignore
                        
                    except (AttributeError, hou.ObjectWasDeleted):
                        flam3h_node: TA_MNode = None
                        
                    else:
                        flam3h_node: TA_MNode = hou.session.F3H_MARKED_ITERATOR_NODE # type: ignore
                        
                    # If the node exist and if it is the selected one
                    if node == flam3h_node:
                            
                        if (idx_add_inbetween + 1) <= flam3h_node_mp_id:
                            hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = flam3h_node_mp_id + 1 # type: ignore
                            # set
                            idx_new: int = prm_mpidx.eval() + 1
                            prm_mpidx.set(idx_new)
                            self.del_comment_and_user_data_iterator(node)
                            self.set_comment_and_user_data_iterator(node, str(idx_new))
                        
                # XF VIZ
                if prm_xfviz.eval() and prm_xfviz_solo.eval():
                    
                    xf_viz_mp_idx = prm_xfviz_solo_mp_idx.eval()
                    if (idx_add_inbetween + 1) <= xf_viz_mp_idx:
                        prm_xfviz_solo_mp_idx.set(xf_viz_mp_idx + 1)
                        node.setUserData(f"{data_name}", str(xf_viz_mp_idx + 1))
                        
                # BUILD XFVIZ if needed
                flam3h_general_utils.util_xf_viz_force_cook(node, self.kwargs)
        
        # Otherwise just update the xaos history
        else:
            # update parameterUserData: flam3h_xaos_iterators_prev
            self.auto_set_xaos_data_set_XAOS_PREV(node, xaos_str)
        
        # set all multi parms xaos strings parms
        _join: Callable[[Iterable[str]], str] = div_weight.join
        xaos_str_round_floats: list[str] = [_join(x) for x in out_flame_utils.out_util_round_floats(xaos_str)]
        prm_xaos_name: str = n.xaos
        for mp_idx in range(1, iter_count + 1):
            prm = node.parm(f"{prm_xaos_name}_{mp_idx}")
            prm.lock(False)
            prm.deleteAllKeyframes() # This parameter can not be animated
        for mp_idx, xaos in enumerate(xaos_str_round_floats): node.parm(f"{prm_xaos_name}_{mp_idx + 1}").set(div_xaos + xaos)
        
        # reset iterator's mpmem prm
        for mp_idx in range(1, iter_count + 1):
            prm = node.parm(f"{mp_mem_name}_{(mp_idx)}")
            flam3h_prm_utils.set(node, prm, str(mp_idx))
        
        # update flam3h_xaos_mpmem
        __mpmem_hou: list[int] = [int(node.parm(f"{mp_mem_name}_{mp_idx}").eval()) for mp_idx in range(1, iter_count + 1)]
        # export mpmem into CachedUserData
        self.auto_set_xaos_data_set_MP_MEM(node, __mpmem_hou)
        
        # Update iterator's names if there is a need ( If they have a default name )
        self.flam3h_update_iterators_names(node, iter_count)

        # lock
        for prm in _PVT_PARMS: prm.lock(True)


    def iterators_count_zero(self, node: hou.SopNode, do_msg: bool = True) -> None:
        """When the iterators' count is ZERO.</br>
        It will do all it's needed in this case.</br></br>
        
        It is meant to be run inside an IF statement that is checking if there are ZERO iterators left.</br>
        
        To be used specifically inside:
        - def iterators_count(self) -> None:

        Args:
            (self):
            node(hou.SopNode): this FLAM3H™ node
            do_msg(bool): Default to: True</br>If False it will not print a message to the status bar and not fire a flash message either.
            
        Returns:
            (None):
        """
        self.destroy_cachedUserData(node, f3h_cachedUserData.edge_case_01)
        
        # delete channel references
        for p in node.parms():
            if not p.isLocked():
                p.deleteAllKeyframes()
            
        # GLOBAL
        # Reset/Set density
        flam3h_general_utils.reset_density(node)
        # Iterations
        prm_iterations = node.parm(f3h_tabs.GLB.PRM_ITERATIONS)
        flam3h_prm_utils.set(node, prm_iterations, f3h_tabs.GLB.DEFAULT_ITERATIONS)

        # FF vars
        self.flam3h_reset_FF()
        # MB
        flam3h_general_utils(self.kwargs).reset_MB()
        # SYS, IN and PREFS
        for prm in (node.parm(f3h_tabs.PREFS.PRM_CAMERA_HANDLE), node.parm(f3h_tabs.PREFS.PRM_CAMERA_CULL)): flam3h_prm_utils.set(node, prm, 0)
        _IN_PVT_PRM: tuple[hou.Parm, ...] = (node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET), node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE))
        for prm in _IN_PVT_PRM: flam3h_prm_utils.private_prm_set(node, prm, 0)
        _PREFS_PVT_PRM: tuple[hou.Parm, ...] = (node.parm(f3h_tabs.PREFS.PVT_PRM_DOFF), node.parm(f3h_tabs.PREFS.PVT_PRM_RIP), node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO), node.parm(f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX), node.parm(f3h_tabs.PREFS.PVT_PRM_XF_FF_VIZ_SOLO))
        for prm in _PREFS_PVT_PRM: flam3h_prm_utils.private_prm_set(node, prm, 0)

        flam3h_iterator_utils.destroy_userData(node, f"{f3h_userData.PRX}_{f3h_userData.XFVIZ_SOLO}")
        # descriptive message parameter
        flam3h_prm_utils.set(node, f3h_tabs.PRM_DESCRIPTIVE, '')
        
        # init/clear copy/paste iterator's data and prm
        self.flam3h_paste_reset_hou_session_data()
        
        # Destroy data
        self.destroy_userData(node, f3h_userData.XML_LAST)
        
        # Updated the OUT flame name if any
        out_flame_utils(self.kwargs).out_auto_change_iter_num_to_prm()
        
        # OUT render curves reset and set
        out_flame_utils.out_render_curves_set_and_retrieve_defaults(node)
        
        # Reset IN Folder settings heading
        flam3h_prm_utils.set(node, f3h_tabs.IN.MSG_PRM_STATS_HEADING, '')
        flam3h_prm_utils.set(node, f3h_tabs.IN.MSG_PRM_SETTINGS_HEADING, '')
        
        # Force this node to cook to get a warning message show up upstream.
        # It failed on me once, hence the try except block
        # Probably becasue I am now raising an error from the xaos cvex code and when it does
        # it is not allowed to cook ? Need to investigate...
        try:
            hou.node(flam3h_general_utils(self.kwargs).get_node_path(f3h_nodeNames.DEFAULT_TFFA_XAOS)).cook(force=True)
        except AttributeError as e:
            F3H_Exception.F3H_traceback_print_infos(e)
            pass
        except hou.OperationFailed:
            pass
        
        if do_msg:
            # Print to Houdini's status bar
            _MSG_str = f"{f3h_tabs.DEFAULT_MSG_ZERO_ITERATORS} Add at least one iterator or load a valid IN flame file"
            _MSG: str = f"{node.name()}: {_MSG_str}"
            flam3h_general_utils.set_status_msg(_MSG, 'IMP')
            flam3h_general_utils.flash_message(node, f"Iterators count ZERO")
        
        
    def iterators_count_not_zero(self, node: hou.SopNode) -> None:
        """When the iterators' count is NOT Zero.</br>
        It will do all it's needed in this case.</br></br>
        
        It is meant to be run inside an IF statement that is checking if there are any iterators left.</br>
        
        To be used specifically inside:
        - def iterators_count(self) -> None:

        Args:
            (self):
            node(hou.SopNode): this FLAM3H™ node
            
        Returns:
            (None):
        """
        # set xaos and updated presets menus every time an iterator is added or removed
        self.auto_set_xaos()
        self.destroy_all_menus_data(node, False)
        # Check and Update this data
        self.update_xml_last_loaded(False)
        
        # Clear status bar msg if needed
        if  f3h_tabs.DEFAULT_MSG_ZERO_ITERATORS in hou.ui.statusMessage()[0]: # type: ignore
            flam3h_general_utils.set_status_msg('', 'MSG')
            

    def iterators_count(self) -> None:
        """This is used as a callback script.</br></br>
        
        Every time an iterator is added or removed</br>
        this will run and execute based on iterator's number: Zero or more then Zero.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """

        node: hou.SopNode = self.node
        # Clear menu cache
        self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
        
        iterators_count: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        
        if not iterators_count:
            
            # Do all it's needed in this case
            self.iterators_count_zero(node)
            
        else:
            
            # Do all it's needed in this case
            self.iterators_count_not_zero(node)

        # This is probably not needed but I leave it here for now
        #
        # If OUT Camera sensor viz mode is ON.
        if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
            # We can avoid to set the clipping planes as they are already set
            flam3h_general_utils(self.kwargs).util_set_front_viewer()
            
            
    def iterator_vactive_and_update(self) -> None:
        """Force menu updates and toggle ON/OFF if the correct parameter is being used.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """  
        node: hou.SopNode = self.node
        # Clear menu cache
        self.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
        
        # Do toggle ON/OFF if the correct parameter is being used
        if 'doiter_' in self.kwargs['parm'].name():
            s_mp_index: int = self.kwargs['script_multiparm_index']
            vactive_prm_name: str = f"vactive_{s_mp_index}"
            flam3h_general_utils(self.kwargs).flam3h_toggle(vactive_prm_name)


# FLAM3H™ PALETTE start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class flam3h_palette_utils:
    """
class flam3h_palette_utils

@STATICMETHODS
* build_ramp_palette_default(ramp_parm: hou.Parm) -> None:
* build_ramp_palette_temp(ramp_tmp_parm: hou.Parm) -> None:
* build_ramp_palette_error() -> tuple[list, list, list]:
* delete_ramp_all_keyframes(ramp_parm: hou.Parm) -> None:
* get_ramp_keys_count(ramp: hou.Ramp) -> str:
* isJSON_F3H_get_first_preset(filepath: str | bool) -> str | bool:
* isJSON_F3H(node: hou.SopNode, filepath: str | bool,  msg: bool = True, parm_path_name: str = f3h_tabs.CP.PRM_PATH) -> tuple[bool, bool]:
* isJSON_F3H_on_preset_load(node: hou.SopNode, filepath: str | bool,  msg: bool = True, parm_path_name: str = f3h_tabs.CP.PRM_PATH) -> tuple[bool, bool]:
* rgb_to_hex(rgb: tuple[float, ...]) -> str:
* hex_to_rgb(hex: str) -> tuple[int, ...]:
* find_nearest_idx(array: list | tuple, value: int | float) -> int | float:
* json_to_flam3h_palette_plus_MSG(node: hou.SopNode, HEXs: list, mode: bool = False, palette_plus_msg: bool = False) -> None:
* json_to_flam3h_palette_plus_preset_MSG(node: hou.SopNode, _MSG: str) -> None:
* json_to_flam3h_get_preset_name_and_id(node: hou.SopNode) -> tuple[str, int]:
* menu_cp_presets_loop(node: hou.SopNode, menu: TA_Menu, i: int, item: str) -> None:
* menu_cp_presets_loop_enum(node: hou.SopNode, menu: TA_Menu, i: int, item: str) -> None:
* menu_cp_presets_empty_loop(node: hou.SopNode, menu: TA_Menu, i: int, item: str) -> None:
* menu_cp_presets_empty_loop_enum(node: hou.SopNode, menu: TA_Menu, i: int, item: str) -> None:

@METHODS
* cp_bases_selection_msg(self) -> None:
* cp_preset_name_set(self) -> None:
* menu_cp_presets_data(self, node: hou.SopNode, json_file_path: str, json_is_file: bool) -> TA_Menu:
* menu_cp_presets(self) -> TA_Menu:
* menu_cp_presets_empty_data(self, node: hou.SopNode, json_file_path: str, json_is_valid: bool) -> TA_Menu:
* menu_cp_presets_empty(self) -> TA_Menu:
* flam3h_ramp_save_JSON_DATA(self) -> tuple[dict, str]:
* flam3h_ramp_save(self) -> None:
* json_to_flam3h_ramp_initialize(self, rgb_from_XML_PALETTE: list[list[float]]) -> tuple[hou.Ramp, int, bool]:
* json_to_flam3h_ramp_set_HSV(self, node, hsv_check: bool, hsv_vals: list) -> None:
* json_to_flam3h_ramp_SET_PRESET_DATA(self, node: hou.SopNode) -> None:
* json_to_flam3h_ramp_sys(self, use_kwargs: bool = True) -> None:
* json_to_flam3h_ramp_SHIFT(self, node: hou.SopNode) -> None:
* json_to_flam3h_ramp_CTRL(self, node: hou.SopNode) -> None:
* json_to_flam3h_ramp_ALT(self, node: hou.SopNode) -> None:
* json_to_flam3h_ramp(self, use_kwargs: bool = True) -> None:
* palette_cp(self, palette_plus_msg: bool = False) -> None:
* palette_cp_to_tmp(self) -> None:
* palette_hsv(self) -> None:
* palette_lock(self) -> None:
* reset_CP_LOCK_MSG(self) -> None:
* reset_CP_TMP(self) -> None:
* reset_CP_options(self) -> None:
* reset_CP_run_0(self) -> None:
* reset_CP_run_2(self) -> None:
* reset_CP_run_3(self) -> None:
* reset_CP(self, mode: int=0) -> None:
* reset_CP_palette_action(self) -> None:
    """
    
    __slots__ = ("_kwargs", "_node", "_palette_plus_do")
    
    def __init__(self, kwargs: dict) -> None:
        """
        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """ 
        self._kwargs: dict[str, Any] = kwargs
        self._node: hou.SopNode = kwargs['node']
        self._palette_plus_do: int = self._node.parm(f3h_tabs.CP.PRM_PALETTE_256_PLUS).eval()
        
        
    @staticmethod
    def build_ramp_palette_default(ramp_parm: hou.Parm) -> None:
        """Build a ramp data with default value for the FLAM3H™ main palette and set it.</br>
        
        Args:
            ramp_parm(hou.Parm): The ramp parameter to set the default data to. Note this is a hou.Parm and not a hou.Ramp

        Returns:
            (None):
        """
        cp_def_bases: list[hou.EnumValue] = [hou.rampBasis.Linear] * 4 # type: ignore
        cp_def_keys: list[float] = [0.0, 0.25, 0.5, 0.75, 1.0]
        cp_def_values: list[tuple[float, ...]] = [(0.2, 0.05, 1), (0.1, 0.85 , 1), (0.05, 1, 0.1), (0.95, 1, 0.1), (1, 0.05, 0.05)]
        ramp_parm.lock(False)
        ramp_parm.set(hou.Ramp(cp_def_bases, cp_def_keys, cp_def_values)) # type: ignore
        
        
    @staticmethod
    def build_ramp_palette_temp(ramp_tmp_parm: hou.Parm) -> None:
        """Build a ramp data with default value for the FLAM3H™ temp palette and set it.
        
        Args:
            ramp_tmp_parm(hou.Parm): The ramp parameter to set the default data to. Note this is a hou.Parm and not a hou.Ramp
            
        Returns:
            (None):
        """
        cp_tmp_bases: list[hou.EnumValue] = [hou.rampBasis.Linear] * 2  # type: ignore
        cp_tmp_keys: list[float] = [0.0, 1.0]
        cp_tmp_values: list[tuple[float, ...]] = [(0.9989989989989989987654, 0, 0), (0.9989989989989989987654, 0 , 0)]
        ramp_tmp_parm.lock(False)
        ramp_tmp_parm.set(hou.Ramp(cp_tmp_bases, cp_tmp_keys, cp_tmp_values)) # type: ignore
        
        
    @staticmethod
    def build_ramp_palette_error() -> tuple[list, list, list]:
        """Build a ramp data with value the signify an error has accurred.</br>
        
        Args:
            (None):

        Returns:
            (tuple): BASEs, POSs, COLORs for the ramp to be build.
        """
        return [hou.rampBasis.Linear], [0], [(1,0,0)] # type: ignore
    
    
    @staticmethod
    def delete_ramp_all_keyframes(ramp_parm: hou.Parm) -> None:
        """Delete all ramp keyframes for all its positon and color keys values.</br>
        
        Args:
            ramp_parm(hou.Parm): The ramp parameter to clear from all its keyframes if any. Note this is a hou.Parm and not a hou.Ramp

        Returns:
            (None):
        """
        # pre-compute some data
        parm_path: str = ramp_parm.path()
        posList_len: int = len(ramp_parm.evalAsRamp().keys()) + 1
        
        for i in range(1, posList_len):
            
            # Delete position keyframes
            pos_parm = hou.parm(f"{parm_path}{i}pos")
            if pos_parm:
                pos_parm.lock(False)
                pos_parm.deleteAllKeyframes()
            
            # Delete color keyframes
            color_parm = hou.parmTuple(f"{parm_path}{i}c")
            if color_parm:
                color_parm.lock(False)
                color_parm.deleteAllKeyframes()

        
    @staticmethod 
    def get_ramp_keys_count(ramp: hou.Ramp) -> str:
        """Based on how many color keys are present in the provided ramp,</br>
        select a palette colors/keys count preset to use for better resample it.</br></br>
        
        Note:
            This need to be revised and smartened up a little as there may be cases where it will fail
            to sample the palette enough to collect the proper colors based on their location and proxymity to each other in the ramp.

        Args:
            ramp(hou.Ramp): The current ramp being considered.

        Returns:
            (str): a palette colors/keys count string preset.
        """
        keys_count: int = len(ramp.keys())
        
        if keys_count <= 128:
            return f3h_tabs.CP.DEFAULT_COUNT_128
        
        elif keys_count <= 256:
            return f3h_tabs.CP.DEFAULT_COUNT_256
        
        else:
            # This message when the CP options: palette 256+ toggle is OFF
            _MSG: str = f'{str(hou.pwd())}: Colors: {keys_count}: to many colors and will default back to the standard 256 color keys for this palette.'
            flam3h_general_utils.set_status_msg(_MSG, 'IMP')
            print(f"{_MSG}\n")
            return f3h_tabs.CP.DEFAULT_COUNT_256
        
        
    @staticmethod
    def isJSON_F3H_get_first_preset(filepath: str | bool) -> str | bool:
        """Try to get the first palette preset of a JSON FLAM3H™ palette file.</br>

        Args:
            filepath(str | bool): The JSON FLAM3H™ Palette file path

        Returns:
            (str | bool): The preset name, or False if not.
        """
        try:
            with open(filepath, 'r') as r:
                preset_name: str = list(json.load(r).keys())[0]
            return preset_name
        
        except PermissionError:
            return False
        
        except FileNotFoundError:
            return False
        
        except json.decoder.JSONDecodeError:
            return False


    @staticmethod
    def isJSON_F3H(node: hou.SopNode, filepath: str | bool,  msg: bool = True, parm_path_name: str = f3h_tabs.CP.PRM_PATH) -> tuple[bool, bool]:
        """Check if the loaded palette lib file is a valid FLAM3H™ palette json file.</br>

        Args:
            node(hou.SopNode): current FLAM3H™ node
            filepath(str | bool): Palette lib full file path.
            msg(bool): Default to: True</br>print out messages to the Houdini's status bar.</br>Set it to False to not print out messages.
            parm_path_name(str): Default to: CP_PATH</br>The actual Houdini's palette file parameter name.

        Returns:
            (tuple[bool, bool]): True if valid. False if not valid.
        """      
        if filepath is not False:
            
            preset: str | bool = flam3h_palette_utils.isJSON_F3H_get_first_preset(filepath)
            if preset is not False:
                
                # If we made it this far, mean we loaded a valid JSON file,
                # lets now check if the preset is actually a F3H Palette preset.
                with open(filepath, 'r') as r:
                    data: dict = json.load(r)[preset]
                    
                # This is the moment of the truth ;)
                try:
                    data[f3h_tabs.CP.DEFAULT_JSON_KEY_NAME_HEX]
                    
                except (KeyError, TypeError) as e:
                    _MSG_C: str = f"JSON file is legitimate, but it does not contain any valid FLAM3H™ Palette data."
                    F3H_Exception.F3H_traceback_print_infos(e, extra_info=_MSG_C)
                    if msg:
                        _MSG_H: str = f"{node.name()}: Palette JSON load -> {_MSG_C}"
                        flam3h_general_utils.set_status_msg(_MSG_H, 'WARN')
                        flam3h_general_utils.flash_message(node, f"CP LOAD: Not a valid palette file")
                    del data
                    
                    return True, False
                
                # Validate the file path setting it
                flam3h_prm_utils.set(node, parm_path_name, filepath)
                
                sm: tuple[str, hou.severityType] = hou.ui.statusMessage() # type: ignore
                if sm[0] and msg:
                    flam3h_general_utils.set_status_msg('', 'MSG')
                del data
                
                return True, True
            
            # The following is clearing up status messages it should have not
            # flam3h_general_utils.set_status_msg('', 'MSG')
            return False, False
        
        flam3h_general_utils.set_status_msg('', 'MSG')
        return False, False
        
        
    @staticmethod
    def isJSON_F3H_on_preset_load(node: hou.SopNode, filepath: str | bool,  msg: bool = True, parm_path_name: str = f3h_tabs.CP.PRM_PATH) -> tuple[bool, bool]:
        """This the same as: def isJSON_F3H(...) but wit a few condition to try to speedup things a little.</br>

        Args:
            node(hou.SopNode): current FLAM3H™ node
            filepath(str | bool): Palette lib full file path.
            msg(bool): Default to: True</br>Print out messages to the Houdini's status bar.</br>Set it to False to not print out messages.
            parm_path_name(str): Default to: f3h_tabs.CP.PATH</br>The actual Houdini's palette file parameter name.

        Returns:
            (tuple[bool, bool]): True if valid. False if not valid.
        """      
        if not node.parm(f3h_tabs.CP.PVT_PRM_ISVALID_PRESET).eval():
            return flam3h_palette_utils.isJSON_F3H(node, filepath, msg, parm_path_name)
            
        elif node.parm(f3h_tabs.CP.PVT_PRM_ISVALID_FILE).eval() and node.parm(f3h_tabs.CP.PVT_PRM_ISVALID_PRESET).eval():
            # If a preset has been loaded already, we assume it mean the loaded lib file is valid.
            # This is risky but it make things faster
            return True, True
        
        else:
            flam3h_general_utils.set_status_msg('', 'MSG')
            return False, False
        
        
    @staticmethod
    def rgb_to_hex(rgb: tuple[float, ...]) -> str:
        """Convert a RGB color values into HEX color values.</br>

        Args:
            rgb(tuple[float, ...]): the RGB color value to convert.

        Returns:
            (str): HEX color value
        """
        hex: str = ''.join(['{:02X}'.format(int(round(x))) for x in [flam3h_general_utils.clamp(255*x) for x in rgb]])
        return hex


    @staticmethod
    def hex_to_rgb(hex: str) -> tuple[int, ...]:
        """Convert a HEX color value into RGB color value.</br>

        Args:
            rgb(str): the HEX color value to convert.

        Returns:
            (tuple): RGB color value
        """   
        return tuple(int(hex[i:i + 2], 16) for i in (0, 2, 4))
    
    
    @staticmethod
    def find_nearest_idx(array: list | tuple, value: int | float) -> int | float:
        """Given a value, find the closest value in the array that is bigger than the value passed in.</br>
        
        Args:
            array(list, tuple): the array of values to search into.
            value:(int, float): The value to use to find its closest and bigger value into the array.

        Returns:
            (int | float): the closest value in the array that is bigger than the value passed in. Can be either an integer or a float
        """   
        idx: int = int(np_searchsorted(array, value, side="left"))
        return array[idx]
    
    
    @staticmethod
    def json_to_flam3h_palette_plus_MSG(node: hou.SopNode, HEXs: list, mode: bool = False, palette_plus_msg: bool = False) -> None:
        """Given a value, find the closest value in the array that is bigger than the value passed in.</br></br>
       
        I am using a manual f-string build here.</br>
        Probably dynamically build a list would be better but if i'll need to add more strings i'll look into it.
        
        Args:
            node(hou.SopNode): The current FLAM3H™ node.
            HEXs(list): The array/list of hex colors.
                         In case of: palette_cp(self) definition -> this argument will be the number of the (source)palette color keys 
                                                                    and it is used only to check if we need to update the palette message while editing it.
            mode(bool): Default to: False</br>For now True only to use inside: palette_cp(self) -> None:
            palette_plus_msg(bool): Default to: False</br>Do not print out messages. Set it to True to print.

        Returns:
            (None):
        """  
        palette_msg: str = node.parm(f3h_tabs.CP.MSG_PRM_PALETTE).eval()
        if len(HEXs) > 256:
            if f3h_tabs.CP.DEFAULT_MSG_PLUS in palette_msg:
                pass
            
            else:
                flam3h_prm_utils.set(node, f3h_tabs.CP.MSG_PRM_PALETTE, f"{f3h_tabs.CP.DEFAULT_MSG_PLUS.strip()} {palette_msg.strip()}")
                
                if palette_plus_msg and node.parm(f3h_tabs.PREFS.PRM_PALETTE_256_PLUS).eval():
                    _MSG: str = f"OUT Palette 256+: ON"
                    flam3h_general_utils.flash_message(node, f3h_tabs.CP.DEFAULT_MSG_PLUS)
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'IMP')
        else:
            if f3h_tabs.CP.DEFAULT_MSG_PLUS in palette_msg:
                flam3h_prm_utils.set(node, f3h_tabs.CP.MSG_PRM_PALETTE, f"{palette_msg[len(f3h_tabs.CP.DEFAULT_MSG_PLUS.strip()):]}")
                
                if palette_plus_msg and node.parm(f3h_tabs.PREFS.PRM_PALETTE_256_PLUS).eval():
                    _MSG: str = f"OUT Palette 256+: OFF"
                    flam3h_general_utils.flash_message(node, f"{f3h_tabs.CP.DEFAULT_MSG_PLUS} OFF")
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                
            else:
                if not mode:
                    pass
                
                else:
                    # I do not remember why I am doing this else statement
                    # ...I leave it here for now as there must be a reason for this to exist ;)
                    #
                    # I think it was because from inside the palette_cp(self) definition we are constantly checking
                    # if the current number of color keys are greater than 256 and adjust the palette msg on the fly.
                    flam3h_palette_utils.json_to_flam3h_palette_plus_preset_MSG(node, palette_msg)
                
    
    @staticmethod 
    def json_to_flam3h_palette_plus_preset_MSG(node: hou.SopNode, _MSG: str) -> None:
        """Check is the plaette plus str "[256+]" is displayed already and add a custom string message(_MSG) to it.</br></br>
        
        This is used inside:
        * flam3h_init_presets_CP_PRESETS(self, mode=1)</br>and its run everytime we load a FLAM3H™ palette file while the presets menu is being initialized.
        
        Args:
            node(hou.SopNode): The current FLAM3H™ node.
            _MSG(str): The message to add
            
        Returns:
            (None):
        """  
        
        palette_msg: str = node.parm(f3h_tabs.CP.MSG_PRM_PALETTE).eval()
        if f3h_tabs.CP.DEFAULT_MSG_PLUS in palette_msg:
            node.parm(f3h_tabs.CP.MSG_PRM_PALETTE).set(f"{f3h_tabs.CP.DEFAULT_MSG_PLUS.strip()} {_MSG.strip()}")
        else:
            node.parm(f3h_tabs.CP.MSG_PRM_PALETTE).set(f"{_MSG}")


    @staticmethod
    def json_to_flam3h_get_preset_name_and_id(node: hou.SopNode) -> tuple[str, int]:
        """Get the selected palette preset name string and its preset_id(index)</br>

        Args:
            node(hou.SopNode): The FLAM3H™ node
        
        Returns:
            tuple[str, int]: preset: str, preset_id: int . The selected palette preset name string stripped from the icon and enumeration index and the preset_id(index).
        """
        
        # get current preset name
        if node.parm(f3h_tabs.CP.PVT_PRM_ISVALID_PRESET).eval():
            preset_id: int = int(node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS).eval())
            menu_label: str = str(node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS).menuLabels()[preset_id]).split(f3h_icons.STAR_PALETTE_LOAD)[-1].strip()
        else:
            preset_id: int = int(node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS_OFF).eval())
            menu_label: str = str(node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS_OFF).menuLabels()[preset_id]).split(f3h_icons.STAR_PALETTE_LOAD_EMPTY)[-1].strip()
        
        # Remove the enumeration menu index string from the preset name.
        #
        # We are using "str.lstrip()" because the preset name has been "str.strip()" already on save from inside: self.flam3h_ramp_save_JSON_DATA()
        # and there are only the leading white spaces left from the menu enumaration index number string to remove.
        if node.parm(f3h_tabs.PREFS.PRM_ENUMERATE_MENU).eval():
            return ':'.join(menu_label.split(':')[1:]).lstrip(), preset_id
        
        return menu_label, preset_id
        
            
    @staticmethod
    def menu_cp_presets_loop(node: hou.SopNode, menu: TA_Menu, i: int, item: str) -> None:
        """This is spcifically to be run inside a list comprehension.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node.
            menu(TA_Menu): the menu list to populate.
            i(int): The outer loop index/iteration.
            item(str): The outer loop item at index/iteration.

        Returns:
            (None):
        """  
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            menu.append(str(i)) # This menu is a string parameter so I do believe this is the correct way
            
            # ICON tag
            if i == int(node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS).eval()):
                node.setCachedUserData(f3h_cachedUserData.cp_presets_menu_idx, str(i))
                menu.append(f"{f3h_icons.STAR_PALETTE_LOAD}  {item}     ") # 5 ending \s to be able to read the full label
                
            else:
                menu.append(f"{item}")
            
            
    @staticmethod
    def menu_cp_presets_loop_enum(node: hou.SopNode, menu: TA_Menu, i: int, item: str) -> None:
        """This is spcifically to be run inside a list comprehension.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node.
            menu(TA_Menu): the menu list to populate.
            i(int): The outer loop index/iteration.
            item(str): The outer loop item at index/iteration.

        Returns:
            (None):
        """  
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            menu.append(str(i)) # This menu is a string parameter so I do believe this is the correct way
            enum_label: str = str(i + 1) # start count from 1
            
            # ICON tag
            if i == int(node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS).eval()):
                node.setCachedUserData(f3h_cachedUserData.cp_presets_menu_idx, str(i))
                menu.append(f"{f3h_icons.STAR_PALETTE_LOAD}  {enum_label}:  {item}     ") # 5 ending \s to be able to read the full label
                
            else:
                menu.append(f"{enum_label}:  {item}")
            
            
    @staticmethod
    def menu_cp_presets_empty_loop(node: hou.SopNode, menu: TA_Menu, i: int, item: str) -> None:
        """This is spcifically to be run inside a list comprehension.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node.
            menu(TA_Menu): the menu list to populate.
            i(int): The outer loop index/iteration.
            item(str): The outer loop item at index/iteration.

        Returns:
            (None):
        """  
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            menu.append(str(i)) # This menu is a string parameter so I do believe this is the correct way
            
            # ICON tag
            if i == int(node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS_OFF).eval()):
                node.setCachedUserData(f3h_cachedUserData.cp_presets_menu_off_idx, str(i))
                menu.append(f"{f3h_icons.STAR_PALETTE_LOAD_EMPTY}  {item}     ") # 5 ending \s to be able to read the full label
                
            else:
                menu.append(f"{item}")
            
            
    @staticmethod
    def menu_cp_presets_empty_loop_enum(node: hou.SopNode, menu: TA_Menu, i: int, item: str) -> None:
        """This is spcifically to be run inside a list comprehension.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node.
            menu(TA_Menu): the menu list to populate.
            i(int): The outer loop index/iteration.
            item(str): The outer loop item at index/iteration.

        Returns:
            (None):
        """  
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            menu.append(str(i)) # This menu is a string parameter so I do believe this is the correct way
            enum_label = str(i + 1) # start count from 1
            
            # ICON tag
            if i == int(node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS_OFF).eval()):
                node.setCachedUserData(f3h_cachedUserData.cp_presets_menu_off_idx, str(i))
                menu.append(f"{f3h_icons.STAR_PALETTE_LOAD_EMPTY}  {enum_label}:  {item}     ") # 5 ending \s to be able to read the full label
                
            else:
                menu.append(f"{enum_label}:  {item}")


    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @property
    def kwargs(self) ->  dict[str, Any]:
        return self._kwargs
    
    @property
    def node(self) -> hou.SopNode:
        return self._node
    
    @property
    def palette_plus_do(self) -> int:
        return self._palette_plus_do
    
    
    def cp_bases_selection_msg(self) -> None:
        """Print messages in the status bar and as a flash message about the selected cp lookup samples basis.</br>

        Args:
            (self):

        Returns:
            (None):
        """
        with hou.undos.disabler(): # type: ignore
            
            node: hou.SopNode = self.node
            selection: int = node.parm(f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES_BASES).eval()
            basis: str | None = f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES_BASES_DICT.get(selection)
            if basis is not None:
                _MSG: str = f"{basis.upper()}"
                flam3h_general_utils.set_status_msg(f"{node.name()}: CP Palette lookup samples basis: {_MSG}", 'MSG')
                flam3h_general_utils.flash_message(node, f"basis: {_MSG}")
            
    
    def cp_preset_name_set(self) -> None:
        """Set the CP Palette preset name parameter after its string is being checked and corrected.</br>

        Args:
            (self):

        Returns:
            (None):
        """
        node: hou.SopNode = self.node

        prm = node.parm(f3h_tabs.CP.PRM_PALETTE_PRESET_NAME)
        preset_name: str = prm.eval()
        preset_name_checked: str = out_flame_utils.out_auto_add_iter_num(0, preset_name, 1, False)
        flam3h_prm_utils.set(node, prm, preset_name_checked)


    def menu_cp_presets_data(self, node: hou.SopNode, json_file_path: str, json_is_file: bool) -> TA_Menu:
        """Build the palette preset parameter menu entries based on the loaded json palette lib file.</br>
        When a palette preset is currently loaded. This will use the color star icon to signal wich preset is being loaded.</br>

        Args:
            (self):
            node(hou.SopNode): this FLAM3H™ node
            json_file_path(str): the CP_PATH parameter string.
            json_is_valid(bool): wether the json_file_path file is an existing file. True or False
            
        Returns:
            (TA_Menu): return menu
        """
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            # Pre compute all parameter evals once instead of inline
            _is_valid_file: bool = node.parm(f3h_tabs.CP.PVT_PRM_ISVALID_FILE).eval()
            _is_valid_preset: bool = self.node.parm(f3h_tabs.CP.PVT_PRM_ISVALID_PRESET).eval()
            
            if json_is_file and _is_valid_file and _is_valid_preset:
                    
                with open(json_file_path) as f:
                    menuitems: list = list(json.load(f).keys())
                
                enum: bool = node.parm(f3h_tabs.PREFS.PRM_ENUMERATE_MENU).eval()
                _menu_func: Callable[[hou.SopNode, TA_Menu, int, str], None] = (self.menu_cp_presets_loop_enum if enum else self.menu_cp_presets_loop)
                
                menu: TA_Menu = []
                for i, item in enumerate(menuitems):
                    _menu_func(node, menu, i, item)

                node.setCachedUserData(f3h_cachedUserData.cp_presets_menu, menu)
                return menu
            
            flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.cp_presets_menu)
            head_tail: tuple[str, str] = os.path.split(json_file_path)
            
            if json_file_path and not json_is_file and os.path.isdir(head_tail[0]):
                return f3h_menus.PRESETS_SAVEONE
            
            elif json_file_path and not json_is_file:
                return f3h_menus.PRESETS_INVALID
            
            else:
                return f3h_menus.PRESETS_EMPTY
    
    
    def menu_cp_presets(self) -> TA_Menu:
        """Rerturn either a cached menu data or rebuild that data on the fly if needed.</br>

        Args:
            (self):
            
        Returns:
            (TA_Menu): return menu
        """
        node: hou.SopNode = self.node
        if hou.isUIAvailable() is False: node.updateParmStates()
        
        # Cache parm reads
        cp_path: str = node.parm(f3h_tabs.CP.PRM_PATH).eval()
        
        # Quick return
        if self.kwargs['parm'].isHidden():
            return [] # f3h_menus.PRESETS_EMPTY_HIDDEN
        elif not cp_path:
            return f3h_menus.PRESETS_EMPTY
        
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            data: TA_Menu | None = node.cachedUserData(f3h_cachedUserData.cp_presets_menu)
            data_idx: str | None = node.cachedUserData(f3h_cachedUserData.cp_presets_menu_idx)
            preset_idx: str = node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS).eval()
            
            # Double check 
            json_file_path: str = os.path.expandvars(cp_path) if cp_path else ''
            json_is_file: bool = os.path.isfile(json_file_path) if json_file_path else False
            
            if json_file_path and not json_is_file:
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_FILE, 0)
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
                data = None
                
            elif json_file_path and json_is_file:
                # This caused some pain becasue it is forcing us not to tell the truth sometime
                # but its quick and we added double checks for each file types (Palette or Flame) inside each menus empty presets (CP, IN and OUT)
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_FILE, 1)
                
            if data is not None and data_idx == preset_idx:
                return data
            
            return self.menu_cp_presets_data(node, json_file_path, json_is_file)
    

    def menu_cp_presets_empty_data(self, node: hou.SopNode, json_file_path: str, json_is_valid: bool) -> TA_Menu:
        """Build the palette preset parameter menu entries based on the loaded json palette lib file.</br>
        When no palette preset has been loaded. This will use the empty star icon to signal wich preset is being selected but not loaded.</br>

        This definition exist only becasue if I change the icon dynamically inside:
        * def menu_cp_presets(self) -> TA_Menu:
        
        Houdini will not update them until I dnt execute a "next" selection in the menu parameter.

        Args:
            (self):
            node(hou.SopNode): this FLAM3H™ node
            json_file_path(str): the f3h_tabs.CP.PATH parameter string.
            json_is_valid(bool): wether the json_file_path file is an existing file. True or False
            
        Returns:
            (TA_Menu): return menu
        """
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore

            # Pre compute all parameter evals once instead of inline
            _is_valid_file: bool = node.parm(f3h_tabs.CP.PVT_PRM_ISVALID_FILE).eval()
            _is_valid_preset: bool = node.parm(f3h_tabs.CP.PVT_PRM_ISVALID_PRESET).eval()
            
            if self.isJSON_F3H(node, json_file_path, False)[-1] and _is_valid_file and not _is_valid_preset:
                    
                with open(json_file_path) as f:
                    menuitems: list = list(json.load(f).keys())
                    
                enum: bool = node.parm(f3h_tabs.PREFS.PRM_ENUMERATE_MENU).eval()
                _menu_func: Callable[[hou.SopNode, TA_Menu, int, str], None] = (self.menu_cp_presets_empty_loop_enum if enum else self.menu_cp_presets_empty_loop)
                
                menu: TA_Menu = []
                for i, item in enumerate(menuitems):
                    _menu_func(node, menu, i, item)

                node.setCachedUserData(f3h_cachedUserData.cp_presets_menu_off, menu)
                return menu
                
            flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.cp_presets_menu_off)
            head_tail: tuple[str, str] = os.path.split(json_file_path)
            if json_file_path  and not json_is_valid and os.path.isdir(head_tail[0]):
                return f3h_menus.PRESETS_SAVEONE
            
            if json_file_path and not json_is_valid:
                return f3h_menus.PRESETS_INVALID
            
            return f3h_menus.PRESETS_EMPTY
    
    
    def menu_cp_presets_empty(self) -> TA_Menu:
        """Rerturn either a cached menu data or rebuild that data on the fly if needed.</br>

        Args:
            (self):
            
        Returns:
            (TA_Menu): return menu
        """
        node: hou.SopNode = self.node
        if hou.isUIAvailable() is False: node.updateParmStates()
        
        # Cache parm reads
        cp_path: str = node.parm(f3h_tabs.CP.PRM_PATH).eval()
        
        # Quick return
        if self.kwargs['parm'].isHidden():
            return [] # f3h_menus.PRESETS_EMPTY_HIDDEN
        elif not cp_path:
            return f3h_menus.PRESETS_EMPTY
        
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            data: TA_Menu | None = node.cachedUserData(f3h_cachedUserData.cp_presets_menu_off)
            data_idx: str | None = node.cachedUserData(f3h_cachedUserData.cp_presets_menu_off_idx)
            preset_idx: str = node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS_OFF).eval()
            
            # Double check 
            json_file_path: str = os.path.expandvars(cp_path) if cp_path else ''
            json_is_file: bool = os.path.isfile(json_file_path) if json_file_path else False
            
            if json_file_path and not json_is_file:
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_FILE, 0)
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
                data = None
            elif json_file_path and json_is_file:
                # This caused some pain becasue it is forcing us not to tell the truth sometime
                # but its quick and we added double checks for each file types (Palette or Flame) inside each menus empty presets (CP, IN and OUT)
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_FILE, 1)
                
            if data is not None and data_idx == preset_idx:
                return data
            
            return self.menu_cp_presets_empty_data(node, json_file_path, json_is_file)


    def flam3h_ramp_save_JSON_DATA(self) -> tuple[dict, str]:
        """Build palette data to save out into a *.json file.</br>

        Args:
            (self):

        Returns:
            (tuple[dict, str]): (dict): Raw json data dictionary. (str): indented json data as string
        """
        node: hou.SopNode = self.node
        # get user's preset name or build an automated one
        presetname: str = str(node.parm(f3h_tabs.CP.PRM_PALETTE_PRESET_NAME).eval()).strip()
        if not presetname:
            presetname: str = datetime.now().strftime("Palette_%b-%d-%Y_%H%M%S")

        # Update HSV ramp before getting it
        self.palette_cp()

        hsv_vals_prm: tuple[float, float, float] = node.parmTuple(f3h_tabs.CP.PRM_RAMP_HSV_VAL_NAME).eval()
        if node.parm(f3h_tabs.CP.PRM_RAMP_SAVE_HSV).eval():
            palette: hou.Ramp = node.parm(f3h_tabs.CP.PRM_RAMP_HSV_NAME).evalAsRamp()
            hsv_vals_prm = (1.0, 1.0, 1.0)
        else:
            palette: hou.Ramp = node.parm(f3h_tabs.CP.PRM_RAMP_SRC_NAME).evalAsRamp()
            
        keys_count: str = out_flame_utils(self.kwargs).out_palette_keys_count(self.palette_plus_do, len(palette.keys()), 1, False)
        POSs: list[int | float] = list(it_islice(it_count(0, 1.0/(int(keys_count)-1)), int(keys_count)))
        _rgb_to_hex: Callable[[tuple[float, ...]], str] = self.rgb_to_hex
        HEXs: list[str] = [_rgb_to_hex(palette.lookup(p)) for p in POSs]
        
        if hsv_vals_prm[0] == hsv_vals_prm[1] == hsv_vals_prm[2] == 1:
            json_dict: dict[str, dict[str, str]] = { presetname: {f3h_tabs.CP.DEFAULT_JSON_KEY_NAME_HEX: ''.join(HEXs),  } }
        else:
            hsv_vals: str = ' '.join([str(x) for x in hsv_vals_prm])
            json_dict: dict[str, dict[str, str]] = { presetname: {f3h_tabs.CP.DEFAULT_JSON_KEY_NAME_HEX: ''.join(HEXs), f3h_tabs.CP.DEFAULT_JSON_KEY_NAME_HSV: hsv_vals} }
            
        # OUTPUT DATA
        return json_dict, json.dumps(json_dict, indent=4)


    def flam3h_ramp_save(self) -> None:
        """Save the current color palette into a json file.</br>
        This wil also save the HSV values along with it.</br></br>
        
        There is also the option to save the HSV palette instead but be cautious</br>
        as when saving the HSV palette, its colors will be clamped. [0-255]</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """        
        node: hou.SopNode = self.node
        # Force this data to be rebuilt
        flam3h_iterator_utils(self.kwargs).destroy_all_menus_data(node)
        # Check and Update this data
        flam3h_iterator_utils(self.kwargs).update_xml_last_loaded(False)
        
        # ALT - Copy palette to the clipboard
        if self.kwargs['alt']:
            
            json_dict, json_data = self.flam3h_ramp_save_JSON_DATA()
            hou.ui.copyTextToClipboard(json_data) # type: ignore
            # Clear up palette preset name if any
            prm = node.parm(f3h_tabs.CP.PRM_PALETTE_PRESET_NAME)
            flam3h_prm_utils.set(node, prm, '')

            # Satus message
            _MSG: str = f"{node.name()}: SAVE Palette Clipboard. Palette copied to the clipboard -> Completed"
            flam3h_general_utils.set_status_msg(_MSG, 'IMP')
            flam3h_general_utils.flash_message(node, f"CP SAVED to the Clipboard")
        
        # Save palette into a file
        else:
            palettepath: str = node.parm(f3h_tabs.CP.PRM_PATH).eval()
            out_path_checked: str | bool = out_flame_utils.out_check_outpath(node, palettepath, f3h_tabs.CP.DEFAULT_FILE_EXT, f3h_tabs.CP.DEFAULT_AUTO_NAME)

            if out_path_checked is not False:
                assert isinstance(out_path_checked, str)
                
                # SHIFT - Open a file explorer to the file location
                if self.kwargs['shift']:
                    flam3h_general_utils.util_open_file_explorer(out_path_checked)
                    
                else:
                    
                    if flam3h_general_utils.isLOCK(out_path_checked):
                        ui_text = f"This Palette library is Locked."
                        ALL_msg = f"This Palette library is Locked and you can not modify this file.\n\nTo Lock a Palete lib file just rename it using:\n\"{FLAM3H_LIB_LOCK}\" as the start of the filename.\n\nOnce you are happy with a palette library you built, you can rename the file to start with: \"{FLAM3H_LIB_LOCK}\"\nto prevent any further modifications to it. For example if you have a lib file call: \"my_rainbows_colors.json\"\nyou can rename it to: \"{FLAM3H_LIB_LOCK}_my_rainbows_colors.json\" to keep it safe."
                        _MSG: str = f"{node.name()}: PALETTE library file -> is LOCKED"
                        flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                        flam3h_general_utils.flash_message(node, f"This Palette file is LOCKED")
                        if hou.isUIAvailable():
                            hou.ui.displayMessage(ui_text, buttons=("Got it, thank you",), severity = hou.severityType.ImportantMessage, default_choice = 0, close_choice = -1, help = None, title = "FLAM3H™ Palette Lock", details = ALL_msg, details_label = None, details_expanded = False) # type: ignore
                        
                        # Clear up status bar msg
                        flam3h_general_utils.set_status_msg('', 'MSG')
                        
                    else:
                        _isNEW: bool = False
                        # F3H palette json file checks
                        json_file, f3h_json_file = self.isJSON_F3H(node, out_path_checked, False)
                        
                        # build palette data to save
                        json_dict, json_data = self.flam3h_ramp_save_JSON_DATA()

                        if self.kwargs["ctrl"]:
                            
                            if not os.path.exists(out_path_checked):
                                with open(out_path_checked,'w') as w:
                                    w.write(json_data)
                                    
                            elif json_file and f3h_json_file:
                                os.remove(out_path_checked)
                                with open(out_path_checked,'w') as w:
                                    w.write(json_data)
                                    
                            else:
                                _MSG: str = f"{node.name()}: Palette JSON SAVE: Although the JSON file you loaded is legitimate, it does not contain any valid FLAM3H™ Palette data."
                                flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                                flam3h_general_utils.flash_message(node, f"CP SAVE: Not a valid palette file")
                                
                        else:
                            # if the file exist and is a valid JSON file
                            if json_file and f3h_json_file:
                                
                                with open(out_path_checked,'r') as r:
                                    prevdata = json.load(r)
                                    
                                newdata: dict = json_dict
                                prevdata.update(newdata)
                                data: dict | str = json.dumps(prevdata, indent = 4)
                                assert isinstance(data, str)
                                with open(out_path_checked, 'w') as w:
                                    w.write(data)
                                    
                            # Otherwise mean it is either not a F3H json file, empty or not exist,
                            # just create one with the current ramp in it
                            #
                            # Note that we already checked for a proper file extension with:
                            # def out_flame_utils.out_check_outpath(...)
                            # so to not override something else by accident
                            else:
                                # If the file do not exist, lets create it and save the palette in it
                                if not os.path.isfile(out_path_checked):
                                    with open(out_path_checked,'w') as w:
                                        w.write(json_data)
                                    # Mark as a new file
                                    _isNEW = True

                        # We do this again so we can read the newly created file if any 
                        json_file, f3h_json_file = self.isJSON_F3H(node, out_path_checked, False)
                        if json_file and f3h_json_file:
                            
                            # Set some parameters
                            with open(out_path_checked) as f:
                                data: dict | str = json.load(f)
                            
                            # Set all CP preset menus parameter index
                            assert isinstance(data, dict)
                            for prm in (node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS), node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS_OFF), node.parm(f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS), node.parm(f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS_OFF)): flam3h_prm_utils.set(node, prm, str(len(data.keys())-1))
                            # Clearup the Palette name if any were given
                            prm = node.parm(f3h_tabs.CP.PRM_PALETTE_PRESET_NAME)
                            flam3h_prm_utils.set(node, prm, '')
                            
                            # Mark this as a valid file and as the currently loaded preset as it is the preset we just saved
                            flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_FILE, 1)
                            flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 1)
                            # Make sure to update the tmp ramp with the just saved one
                            self.palette_cp_to_tmp()
                            del data
                            
                            # Set the file path to the corrected one
                            flam3h_prm_utils.set(node, f3h_tabs.CP.PRM_PATH, out_path_checked)
                            
                            # Something odd in how the messages are running, need to investigate why
                            _MSG: str = f"Palette SAVED"
                            if _isNEW and flam3h_palette_utils.isJSON_F3H(node, out_path_checked):
                                flam3h_general_utils(self.kwargs).flam3h_init_presets_CP_PRESETS(1, True, json_file, f3h_json_file, out_path_checked)
                                # Mark this as a valid file and as the currently loaded preset as it is the first ever preset we just saved into this file
                                flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_FILE, 1)
                                flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 1)
                                if flam3h_general_utils.isLOCK(out_path_checked):
                                    flam3h_general_utils.flash_message(node, f"{_MSG} and LOCKED")
                                else:
                                    flam3h_general_utils.flash_message(node, _MSG)
                                    
                            else:
                                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'IMP')
                                flam3h_general_utils.flash_message(node, _MSG)
                            
                        else:
                            # Just in case lets set those
                            flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_FILE, 0)
                            flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
                            
                            if json_file:
                                # If it is a legitimate JSON file
                                _MSG: str = f"{node.name()}: Palette JSON SAVE: Although the JSON file you loaded is legitimate, it does not contain any valid FLAM3H™ JSON Palette data."
                                flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                                flam3h_general_utils.flash_message(node, f"CP SAVE: Not a valid palette file")
                                
                            else:
                                # If it is any other file
                                _MSG: str = f"{node.name()}: Palette JSON SAVE: CP file not a valid FLAM3H™ JSON PALETTE file."
                                flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                                flam3h_general_utils.flash_message(node, f"CP SAVE: Not a valid palette file")
                        
            else:
                
                if self.kwargs['shift']:
                    # If there is NOT a valid dir or filepath already, open a file chooser to pick or define one
                    _START_DIR: str | None = flam3h_general_utils.select_file_start_dir(node, f3h_tabs.CP.PRM_PATH)
                    # Open a floating file chooser
                    filepath: str = hou.ui.selectFile(start_directory=_START_DIR, title="FLAM3H™ Load/Save a palette *.json file", collapse_sequences=False, file_type=hou.fileType.Any, pattern="*.json", default_value=None, multiple_select=False, image_chooser=None, chooser_mode=hou.fileChooserMode.ReadAndWrite, width=0, height=0)  # type: ignore
                    filepath_expandvars: str = os.path.expandvars(filepath)
                    dir: str = os.path.dirname(filepath_expandvars)
                    if os.path.isdir(dir):
                        flam3h_prm_utils.set(node, f3h_tabs.OUT.PRM_PATH, filepath_expandvars)
                        # The following definition use the default arg's
                        flam3h_general_utils(self.kwargs).flam3h_init_presets_CP_PRESETS()
                    
                    else:
                        _MSG: str = f"{node.name()}: SAVE Palette: Select a valid output file or a valid filename to create first."
                        flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                        flam3h_general_utils.flash_message(node, f"CP: Select a valid output file")
                        
                else:
                    _MSG: str = f"{node.name()}: SAVE Palette: Select a valid output file or a valid filename to create first."
                    flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                    flam3h_general_utils.flash_message(node, f"CP: Select a valid output file")


    def json_to_flam3h_ramp_initialize(self, rgb_from_XML_PALETTE: list[list[float]]) -> tuple[hou.Ramp, int, bool]:
        """It will check the passed list of colors for validity and build a Houdini ramp parameter's values from it.</br>
        If not valid, or only one color is included, it will output one RED color and mark this palette as an Error.</br>

        Args:
            (self):
            rgb_from_XML_PALETTE(list[list[float]]): a list of colors collected from the palette json file preset (from file or from Clipboard)
            
        Returns:
            (tuple[hou.Ramp, int, bool]): Return a tuple containing: a houdini Ramp parameter, number of keys and True or False if the operation succeded or not. If False, it will build an error Ramp instead.
        """  
        _CHECK: bool = True
        if rgb_from_XML_PALETTE:
            _len: int = len(rgb_from_XML_PALETTE)
            POSs: list[int | float] = list(it_islice(it_count(0, 1.0/(_len-1)), _len))
            BASEs: list[hou.EnumValue] = [hou.rampBasis.Linear] * _len # type: ignore
            
        else:
            BASEs, POSs, rgb_from_XML_PALETTE = self.build_ramp_palette_error()
            _CHECK = False
            
        # Set lookup samples to the default value of: 256
        prm = self.node.parm(f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES)
        flam3h_prm_utils.set(self.node, prm, 256)

        return hou.Ramp(BASEs, POSs, rgb_from_XML_PALETTE), len(POSs), _CHECK


    def json_to_flam3h_ramp_set_HSV(self, node, hsv_check: bool, hsv_vals: list) -> None:
        """Set the HSV values to either the one comeing from the loaded palette preset or to default values.</br>

        Args:
            (self):
            node(hou.SopNode): The current FLAM3H™ node.
            hsv_check(bool): True if the loaded palette preset posses its own HSV values or False if not.
            hsv_vals(list): If hsv_check is True, this will hold the values to be used to set the HSV parameter's values.

        Returns:
            (None):
        """
        keep_hsv: int = node.parm(f3h_tabs.CP.PRM_RAMP_HSV_KEEP_ON_LOAD).eval()
        
        if not keep_hsv:
            prm = node.parmTuple(f3h_tabs.CP.PRM_RAMP_HSV_VAL_NAME)
            if hsv_check:
                flam3h_prm_utils.set(node, prm, hou.Vector3(hsv_vals))
            else:
                # This is for backward compatibility ( when the hsv data wasn't being exported yet )
                flam3h_prm_utils.set(node, prm, hou.Vector3((1, 1, 1)))


    def json_to_flam3h_ramp_SET_PRESET_DATA(self, node: hou.SopNode) -> None:
        """From the loaded palette preset data finally set the palette.</br>

        Args:
            (self):
            node(hou.SopNode): This FLAM3H™ node.
            
        Returns:
            (None):
        """
        
        iterators_num: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        if iterators_num:
            
            filepath: str = os.path.expandvars(node.parm(f3h_tabs.CP.PRM_PATH).eval())
            if self.isJSON_F3H_on_preset_load(node, filepath, False)[-1]:
                
                # get ramps parm
                rmp_src = node.parm(f3h_tabs.CP.PRM_RAMP_SRC_NAME)
                rmp_hsv = node.parm(f3h_tabs.CP.PRM_RAMP_HSV_NAME)

                # get current preset name and preset_id(index)
                preset, preset_id = self.json_to_flam3h_get_preset_name_and_id(node)
                
                # 'hsv_check' is for backward compatibility
                with open(filepath, 'r') as r:
                    data: dict = json.load(r)[preset]
                    
                try:
                    hsv_vals: list[float] = [float(x) for x in str(data[f3h_tabs.CP.DEFAULT_JSON_KEY_NAME_HSV]).split(' ')]
                    hsv_check: bool = True
                except (ValueError, KeyError):
                    hsv_vals: list[float] = []
                    hsv_check: bool = False
                
                # Get usable color values
                HEXs: list[str] = [hex for hex in wrap(data[f3h_tabs.CP.DEFAULT_JSON_KEY_NAME_HEX], 6)]
                
                try:
                    _hex_to_rgb: Callable[[str], tuple] = self.hex_to_rgb
                    RGBs: list[list[int]] = [list(map(abs, _hex_to_rgb(hex))) for hex in HEXs]
                    
                except ValueError as e:
                    F3H_Exception.F3H_traceback_print_infos(e, extra_info='Invalid hex values in the loaded palette.')
                    rgb_from_XML_PALETTE: list[list[float]] = []
                    
                else:
                    # Convert to NumPy array and normalize
                    RGBs_array: NDArray[np_float32] = np_array(RGBs[:len(HEXs)], dtype=np_float32)
                    rgb_from_XML_PALETTE: list[list[float]] = (RGBs_array / 255.0).tolist()
                
                del data
                
                # Initialize and SET new ramp first
                _RAMP, _COUNT, _CHECK = self.json_to_flam3h_ramp_initialize(rgb_from_XML_PALETTE)
                
                # Load the new palette colors
                flam3h_prm_utils.set(node, rmp_src, _RAMP)
                # Make sure we update the HSV palette
                flam3h_prm_utils.set(node, rmp_hsv, _RAMP)
                
                self.json_to_flam3h_ramp_set_HSV(node, hsv_check, hsv_vals) # Set HSV values
                self.palette_hsv() # Apply HSV values if any
                # Update palette tmp
                self.palette_cp_to_tmp()
                # Update/Set palette MSG
                flam3h_palette_utils.json_to_flam3h_palette_plus_MSG(node, HEXs)
                
                # Set palette lookup samples
                # Note we are setting the function type to: Flame(0) so we always clamp at the minimun of 256 lookup samples
                keys: str = out_flame_utils(self.kwargs).out_palette_keys_count(self.palette_plus_do, _COUNT, 0, False)
                # The following is unlocked and cleared already from the above: self.json_to_flam3h_ramp_initialize(rgb_from_XML_PALETTE)
                node.parm(f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES).set(int(keys))
                # Store selection into all preset menu just in case ;)
                for prm in (node.parm(f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS), node.parm(f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS_OFF), node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS), node.parm(f3h_tabs.CP.PRM_PALETTE_PRESETS_OFF)): flam3h_prm_utils.set(node, prm, str(preset_id))
                
                # Force this data to be rebuilt - This need to be reworked as it is slowing things down on H20.5
                # This is needed to help to updates the menus from time to time so to pick up sneaky changes to the loaded files
                # (ex. the user perform hand made modifications like renaming a Preset and such).
                flam3h_iterator_utils(self.kwargs).destroy_all_menus_data(node, False)
                # Check and Update this data
                flam3h_iterator_utils(self.kwargs).update_xml_last_loaded(False)
                
                if _CHECK:
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 1)
                    _MSG: str = f"{node.name()}: LOAD Palette preset: \"{preset}\" -> Completed"
                    flam3h_general_utils.set_status_msg(_MSG, 'IMP')
                    flam3h_general_utils.flash_message(node, f"CP LOADED")
                else:
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
                    _MSG: str = f"{node.name()}: CP: ERROR on preset: \"{preset}\". Invalid HEX values."
                    flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                    flam3h_general_utils.flash_message(node, f"CP ERROR")
            
            else:
                _MSG: str = f"{node.name()}: CP: Nothing to load"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                flam3h_general_utils.flash_message(node, f"CP: Nothing to load")


    def json_to_flam3h_ramp_sys(self, use_kwargs: bool = True) -> None:
        """Load the selected palette preset from the provided json file</br>
        using the SYS load palette button.</br>

        Args:
            (self):
            use_kwargs(bool): Default to: True</br>Use the houdini kwargs arguments or not.</br>This is being done as when this definition run from a menu parameter the kwargs arguments are not available. 
        
        Returns:
            (None):
        """
        
        if use_kwargs:
            self.json_to_flam3h_ramp(use_kwargs)
            
        else:
            node: hou.SopNode = self.node
            if node.parm(f3h_tabs.CP.PVT_PRM_ISVALID_PRESET).eval():
                preset_id: str = node.parm(f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS).eval()
                flam3h_prm_utils.set(node, f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS_OFF, preset_id)
            else:
                preset_id: str = node.parm(f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS_OFF).eval()
                flam3h_prm_utils.set(node, f3h_tabs.CP.PRM_SYS_PALETTE_PRESETS, preset_id)
                
            parms_dict: dict = {f3h_tabs.CP.PRM_PALETTE_PRESETS: preset_id, 
                                f3h_tabs.CP.PRM_PALETTE_PRESETS_OFF: preset_id}
            flam3h_prm_utils.setParms(node, parms_dict)
            
            self.json_to_flam3h_ramp(use_kwargs)


    def json_to_flam3h_ramp_SHIFT(self, node: hou.SopNode) -> None:
        """When kwargs['shift'] -> Open a file chooser to select palette json file to load.</br>

        Args:
            (self):
            node(hou.SopNode): This FLAM3H™ node.
        
        Returns:
            (None):
        """
        # Get start directory if one is already set in the CP file path (e.g. a Palette file is already being loaded)
        _START_DIR: str | None = flam3h_general_utils.select_file_start_dir(node, f3h_tabs.CP.PRM_PATH)
        # Open a floating file chooser
        filepath: str = hou.ui.selectFile(start_directory=_START_DIR, title="FLAM3H™ Load/Save a palette *.json file", collapse_sequences=False, file_type=hou.fileType.Any, pattern="*.json", default_value=None, multiple_select=False, image_chooser=None, chooser_mode=hou.fileChooserMode.ReadAndWrite, width=0, height=0)  # type: ignore
        filepath_expandvars: str = os.path.expandvars(filepath)
        dir: str = os.path.dirname(filepath_expandvars)
        if os.path.isdir(dir):
            flam3h_prm_utils.set(node, f3h_tabs.CP.PRM_PATH, filepath_expandvars)
            # The following definition use the default arg's value so it can set the proper ramp message if needed.
            flam3h_general_utils(self.kwargs).flam3h_init_presets_CP_PRESETS()

            
    def json_to_flam3h_ramp_CTRL(self, node: hou.SopNode) -> None:
        """When kwargs['ctrl'] -> Copy the preset name into the Palette name parameter.</br>

        Args:
            (self):
            node(hou.SopNode): This FLAM3H™ node.
        
        Returns:
            (None):
        """
        
        filepath: str = os.path.expandvars(node.parm(f3h_tabs.CP.PRM_PATH).eval())
        if self.isJSON_F3H_on_preset_load(node, filepath, False)[-1]:
            
            # get current preset name and preset_id(index)
            preset, preset_id = self.json_to_flam3h_get_preset_name_and_id(node)
            # SET the Palette name to the preset name
            if preset:
                prm = node.parm(f3h_tabs.CP.PRM_PALETTE_PRESET_NAME)
                flam3h_prm_utils.set(node, prm, preset)
                
                flam3h_general_utils.flash_message(node, preset)
        else:
            _MSG: str = f"{node.name()}: CP: Nothing to load"
            flam3h_general_utils.set_status_msg(_MSG, 'MSG')
            flam3h_general_utils.flash_message(node, f"CP: Nothing to load")
            
            
    def json_to_flam3h_ramp_ALT(self, node: hou.SopNode) -> None:
        """When kwargs['alt'] -> Load palette data from the clipboard.</br>

        Args:
            (self):
            node(hou.SopNode): This FLAM3H™ node.
        
        Returns:
            (None):
        """
        
        palette: str = hou.ui.getTextFromClipboard() # type: ignore
        try:
            _data: dict | None = json.loads(palette)
        except json.decoder.JSONDecodeError:
            _data: dict | None = None
        
        # If it is a valid json data
        if _data is not None:
            
            try:
                preset: str | None = list(_data.keys())[0]
                del _data
                
            except IndexError as e:
                F3H_Exception.F3H_traceback_print_infos(e)
                preset: str | None = None
                
            if preset is not None:
                
                data: dict | None = json.loads(palette)[preset]
                
                try:
                    assert data is not None
                    # Check if it is a valid FLAM3H™ JSON data. This is the moment of the truth ;)
                    data[f3h_tabs.CP.DEFAULT_JSON_KEY_NAME_HEX]
                    
                except (KeyError, TypeError):
                    isJSON_F3H: bool = False
                    _MSG: str = f"{node.name()}: PALETTE JSON load -> Although the JSON file you loaded is legitimate, it does not contain any valid FLAM3H™ Palette data."
                    flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                    
                else:
                    isJSON_F3H: bool = True
                    
                # If it is a valid FLAM3H™ Palette JSON data
                if isJSON_F3H:
                    assert data is not None
                    
                    # get ramps parm
                    rmp_src = node.parm(f3h_tabs.CP.PRM_RAMP_SRC_NAME)
                    rmp_hsv = node.parm(f3h_tabs.CP.PRM_RAMP_HSV_NAME)
                    
                    try:
                        hsv_vals: list[float] = [float(x) for x in data[f3h_tabs.CP.DEFAULT_JSON_KEY_NAME_HSV].split(' ')]
                        
                    except (KeyError, ValueError):
                        hsv_vals: list[float] = []
                        hsv_check: bool = False
                        
                    else:
                        hsv_check: bool = True
                    
                    # Get usable color values
                    HEXs: list[str] = [hex for hex in wrap(data[f3h_tabs.CP.DEFAULT_JSON_KEY_NAME_HEX], 6)]
                    
                    try:
                        _hex_to_rgb: Callable[[str], tuple] = self.hex_to_rgb
                        RGBs: list[list[int]] = [list(map(abs, _hex_to_rgb(hex))) for hex in HEXs]
                        
                    except ValueError as e:
                        F3H_Exception.F3H_traceback_print_infos(e, extra_info='Invalid hex values in the loaded palette from Clipboard.')
                        rgb_from_XML_PALETTE: list[list[float]] = []
                        
                    else:
                        # Convert to NumPy array and normalize
                        RGBs_array: NDArray[np_float32] = np_array(RGBs[:len(HEXs)], dtype=np_float32)
                        rgb_from_XML_PALETTE: list[list[float]] = (RGBs_array / 255.0).tolist()
                        
                    del data
                    
                    # Initialize and SET new ramp.
                    _RAMP, _COUNT, _CHECK = self.json_to_flam3h_ramp_initialize(rgb_from_XML_PALETTE)

                    # Load the new palette colors
                    flam3h_prm_utils.set(node, rmp_src, _RAMP)
                    # Make sure we update the HSV palette
                    flam3h_prm_utils.set(node, rmp_hsv, _RAMP)
                    
                    self.json_to_flam3h_ramp_set_HSV(node, hsv_check, hsv_vals) # Set HSV values
                    self.palette_hsv()# Apply HSV values if any
                    # Update palette tmp
                    self.reset_CP_TMP()
                    # Update/Set palette MSG
                    self.json_to_flam3h_palette_plus_MSG(node, HEXs)
                    
                    # Set palette lookup samples
                    # Note we are setting the function type to: Flame so we always clamp at the minimun of 256 lookup samples
                    keys: str = out_flame_utils(self.kwargs).out_palette_keys_count(self.palette_plus_do, _COUNT, 0, False)
                    # The following is unlocked and cleared already from the above: self.json_to_flam3h_ramp_initialize(rgb_from_XML_PALETTE)
                    node.parm(f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES).set(int(keys))
                    
                    # Mark this as not a loaded preset since it is coming from the Clipboard
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
                    
                    if _CHECK:
                        _MSG: str = f"{node.name()}: PALETTE Clipboard: LOAD Palette preset: \"{preset}\" -> Completed"
                        flam3h_general_utils.set_status_msg(_MSG, 'IMP')
                        flam3h_general_utils.flash_message(node, f"CP LOADED from the Clipboard")
                        
                    else:
                        _MSG: str = f"{node.name()}: PALETTE Clipboard: ERROR on preset: \"{preset}\". Invalid HEX values."
                        flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                        flam3h_general_utils.flash_message(node, f"CP ERROR from the Clipboard")
                    
            else:
                _MSG: str = f"{node.name()}: PALETTE Clipboard: The data from the clipboard is not a valid F3H Palette data (JSON or XML)."
                flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                flam3h_general_utils.flash_message(node, f"CP Clipboard: Nothing to load")
                
        else:
            # Check if a full Flame preset is stored into the clipboard instead
            # and if so load its palette in.
            _FLAM3H_INIT_DATA: TA_F3H_Init = in_flame_utils(self.kwargs).in_to_flam3h_init_data(node)
            xml, clipboard, preset_id, flame_name_clipboard, attempt_from_clipboard, chaos = _FLAM3H_INIT_DATA

            if xml is not None and clipboard:
                
                apo_data: in_flame_iter_data = in_flame_iter_data(node, xml, preset_id)
                if in_flame_utils(self.kwargs).in_to_flam3h_set_palette(node, apo_data, _FLAM3H_INIT_DATA, True):
                # If not an error (otherwise the ERROR messages are fired from the above definition)
                    _MSG: str = f"{node.name()}: PALETTE Clipboard: LOAD Palette data from Flame preset: \"{_FLAM3H_INIT_DATA[3]}\" -> Completed"
                    flam3h_general_utils.set_status_msg(_MSG, 'IMP')
                    flam3h_general_utils.flash_message(node, f"CP LOADED from the Clipboard")
                    
            else:
                _MSG: str = f"{node.name()}: Palette Clipboard: The data from the clipboard is not a valid F3H Palette data (JSON or XML)."
                flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                flam3h_general_utils.flash_message(node, f"CP Clipboard: Nothing to load")
                         

    def json_to_flam3h_ramp(self, use_kwargs: bool = True) -> None:
        """Load the selected palette preset from the provided json file.</br>
        
        Args:
            (self):
            use_kwargs(bool): Default to: True</br>Use the houdini kwargs arguments or not.</br>This is being done as when this definition run from a menu parameter the kwargs arguments are not available. 

        Returns:
            (None):
        """
        # Check and Update this data
        flam3h_iterator_utils(self.kwargs).update_xml_last_loaded()
        
        node: hou.SopNode = self.node
        
        # KWARGS
        if use_kwargs:
                
            # SHIFT - If we are selecting a palette json file to load
            if self.kwargs['shift']:
                self.json_to_flam3h_ramp_SHIFT(node)

            # CTRL - If we are just copying the preset name into the Palette name parameter
            elif self.kwargs['ctrl']:
                self.json_to_flam3h_ramp_CTRL(node)
                
            # ALT - If we are loading a palette from the clipboard
            elif self.kwargs['alt']:
                self.json_to_flam3h_ramp_ALT(node)

            # LMB - Load the currently selected palette preset
            else:
                self.json_to_flam3h_ramp_SET_PRESET_DATA(node)

        # NO KWARGS - LMB - Load the currently selected palette preset
        #
        # This is used from the preset menus parameter, since kwargs are not available from here.
        else:
            self.json_to_flam3h_ramp_SET_PRESET_DATA(node)


    def palette_cp(self, palette_plus_msg: bool = False) -> None:
        """Force the HSV palette colors/keys to match the source palette colors/keys.</br>
        
        Args:
            (self):
            palette_plus_msg(bool): Default to: False</br>Coordinate messages about palette 256+ when the preferences option: "palette 256+" is ON
            
        Returns:
            (None):
        """    
        node: hou.SopNode = self.node
        rmpsrc: hou.Ramp = node.parm(f3h_tabs.CP.PRM_RAMP_SRC_NAME).evalAsRamp()
        rmphsv = node.parm(f3h_tabs.CP.PRM_RAMP_HSV_NAME)
        # Clear and re-set
        # self.delete_ramp_all_keyframes(rmphsv) # this get a little expensive to run every time and since the *.flame format do not support animations we can avoid it.
        rmphsv.lock(False)
        rmphsv.set(rmpsrc)
        # Apply HSV if any
        #
        # self.palette_hsv is running also inside self.palette_lock()
        # becasue it used to get call also from other Houdini parameter's callback scripts.
        # Need to come back and make changes...
        self.palette_hsv()

        if node.parm(f3h_tabs.CP.PVT_PRM_ISVALID_FILE).eval():
            rmptmp: hou.Ramp = node.parm(f3h_tabs.CP.PRM_RAMP_TMP_NAME).evalAsRamp()
            if rmpsrc.keys() != rmptmp.keys() or rmpsrc.values() != rmptmp.values():
                # Mark this as not a loaded palette preset
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
            else:
                # Mark this as a loaded palette preset since they match
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 1)

        # Update/Set palette MSG
        flam3h_palette_utils.json_to_flam3h_palette_plus_MSG(node, rmpsrc.keys(), True, palette_plus_msg)    


    def palette_cp_to_tmp(self) -> None:
        """Make a copy of the source palette into the temp palette.</br>
        This is used when loading a palette preset to check if the user made modifications to the loaded palette.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """    
        node: hou.SopNode = self.node
        rmpsrc: hou.Ramp = node.parm(f3h_tabs.CP.PRM_RAMP_SRC_NAME).evalAsRamp()
        rmptmp = node.parm(f3h_tabs.CP.PRM_RAMP_TMP_NAME)
        rmptmp.lock(False)
        rmptmp.set(rmpsrc)


    def palette_hsv(self) -> None:
        """Apply a HSV to the paltte colors/keys.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """  
        node: hou.SopNode = self.node
        hsvprm_vals: tuple[float, float, float] = node.parmTuple(f3h_tabs.CP.PRM_RAMP_HSV_VAL_NAME).eval()
        if hsvprm_vals[0] != 1 or hsvprm_vals[1] != 1 or hsvprm_vals[2] != 1:
            
            # Apply color correction
            rmpsrc: hou.Ramp = node.parm(f3h_tabs.CP.PRM_RAMP_SRC_NAME).evalAsRamp()
            _hsv_to_rgb: Callable[[float, float, float], tuple[float, float, float]] = colorsys.hsv_to_rgb
            _rgb_to_hsv: Callable[[float, float, float], tuple[float, float, float]] = colorsys.rgb_to_hsv
            _RGBs: list[tuple[float, float, float]] = [_hsv_to_rgb(h + hsvprm_vals[0], s * hsvprm_vals[1], v * hsvprm_vals[2]) for h, s, v in (_rgb_to_hsv(r, g, b) for r, g, b in rmpsrc.values())]
            
            # Set the ramp
            rmphsv = node.parm(f3h_tabs.CP.PRM_RAMP_HSV_NAME)
            rmphsv.lock(False)
            rmphsv.set(hou.Ramp(rmpsrc.basis(), rmpsrc.keys(), _RGBs))


    def palette_lock(self) -> None:
        """Lock the HSV palette color/keys from being modified.</br>
        This is also used to updated the palette HSV to keep it up to date with the source palette.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """    
        self.palette_cp()
        # self.palette_hsv is running also inside self.palette_cp()
        # becasue it get call also from other Houdini parameter's callback scripts.
        # Need to come back and make changes...
        self.palette_hsv()


    def reset_CP_LOCK_MSG(self) -> None:
        """Clearup the palette lib LOCK message if there is a need to do so.</br>
        
        With the add of the palette [256+] feature,</br>
        this definition will probably need an updated. Will come back to investigate on this...</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        filepath: str = node.parm(f3h_tabs.CP.PRM_PATH).eval()
        if self.isJSON_F3H(node, filepath, False)[0]:
            if flam3h_general_utils.isLOCK(filepath) is False:
                flam3h_prm_utils.set(node, f3h_tabs.CP.MSG_PRM_PALETTE, '')
        else:
            flam3h_prm_utils.set(node, f3h_tabs.CP.MSG_PRM_PALETTE, '')


    def reset_CP_TMP(self) -> None:
        """Reset the TEMP palette to its defaults.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        # CP->tmp ramp RESET
        ramp_tmp_parm = self.node.parm(f3h_tabs.CP.PRM_RAMP_TMP_NAME)
        self.delete_ramp_all_keyframes(ramp_tmp_parm)
        # Build TMP ramp
        self.build_ramp_palette_temp(ramp_tmp_parm)
        
        
    def reset_CP_options(self) -> None:
        """Reset the CP tab options toggles to their defaults.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        options_dict: dict = {  f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES: 256, 
                                f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES_BASES: 0, 
                                f3h_tabs.CP.PRM_RAMP_SAVE_HSV: 0
                                }
        
        flam3h_prm_utils.setParms(node, options_dict)
        
        self.reset_CP_LOCK_MSG()


    def reset_CP_run_0(self) -> None:
        """Reset the CP tab to its defaults.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        # CP
        prm_hsv = node.parmTuple(f3h_tabs.CP.PRM_RAMP_HSV_VAL_NAME)
        flam3h_prm_utils.set(node, prm_hsv, hou.Vector3((1.0, 1.0, 1.0)))
        # CP->ramp
        rmp_src = node.parm(f3h_tabs.CP.PRM_RAMP_SRC_NAME)
        # Reset ramps
        #
        # SRC
        self.build_ramp_palette_default(rmp_src)
        self.delete_ramp_all_keyframes(rmp_src)
        # HSV
        self.palette_cp()
        rmp_hsv = node.parm(f3h_tabs.CP.PRM_RAMP_HSV_NAME)
        self.delete_ramp_all_keyframes(rmp_hsv)
        # Reset CP options tab
        self.reset_CP_options()
        # CP->tmp ramp RESET
        self.reset_CP_TMP()
        # Mark this as not a loaded preset
        flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
        
        
    def reset_CP_run_1(self) -> None:
        """Delete all ramps keyframes (Palette and HSV Palette)</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        # CP->ramp
        rmp_scr = node.parm(f3h_tabs.CP.PRM_RAMP_SRC_NAME)
        rmp_hsv = node.parm(f3h_tabs.CP.PRM_RAMP_HSV_NAME)
        # Reset ramps
        self.delete_ramp_all_keyframes(rmp_scr)
        self.delete_ramp_all_keyframes(rmp_hsv)
        # Messages
        _MSG: str = f"CP Keyframes: DELETED"
        flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
        flam3h_general_utils.flash_message(node, _MSG)

        
    def reset_CP_run_2(self) -> None:
        """Reset the CP tab HSV values to their defaults.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        hsv_prm = node.parmTuple(f3h_tabs.CP.PRM_RAMP_HSV_VAL_NAME)
        _hsv: tuple[float, float, float] = hsv_prm.eval()
        if _hsv[0] == _hsv[1] == _hsv[2] == 1:
            hsv_prm.lock(False)
            hsv_prm.deleteAllKeyframes()
            _MSG: str = f"CP HSV: already at its default values."
            flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
            flam3h_general_utils.flash_message(node, _MSG)
        else:
            flam3h_prm_utils.set(node, hsv_prm, hou.Vector3((1.0, 1.0, 1.0)))
            # Print out to Houdini's status bar
            _MSG: str = f"CP HSV: RESET"
            flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
            flam3h_general_utils.flash_message(node, _MSG)
            
        # CP->tmp ramp RESET
        self.reset_CP_TMP()
        # # Update palette py
        self.palette_cp()
        # Mark this as not a loaded preset
        flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)


    def reset_CP_run_3(self) -> None:
        """Reset the CP tab Palette ramp to its defaults ( and the HSV palette too ).</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        rmp_src = node.parm(f3h_tabs.CP.PRM_RAMP_SRC_NAME)
        # Build ramp
        #
        # SRC
        self.build_ramp_palette_default(rmp_src)
        self.delete_ramp_all_keyframes(rmp_src)
        # HSV
        self.palette_cp()
        rmp_hsv = node.parm(f3h_tabs.CP.PRM_RAMP_HSV_NAME)
        self.delete_ramp_all_keyframes(rmp_hsv)
        
        # CP->tmp ramp RESET
        self.reset_CP_TMP()
        # Mark this as not a loaded preset
        flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
        # Set lookup samples to the default value of: 256 and basis to: linear(0)        
        parms_dict: dict = {f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES: 256, 
                            f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES_BASES: 0}
        flam3h_prm_utils.setParms(node, parms_dict)
        
        # Print out to Houdini's status bar
        _MSG: str = f"CP: RESET"
        flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
        flam3h_general_utils.flash_message(node, _MSG)
        
    
    def reset_CP(self, mode: int=0) -> None:
        """Run the desired reset_CP(...) definition.</br>

        Args:
            (self):
            mode(int): Default to: 0</br>Definition idx to run

        Returns:
            (None):
        """
        func_list: dict[int, Callable[[], None]] = {0: self.reset_CP_run_0, 1: self.reset_CP_run_1, 2: self.reset_CP_run_2, 3: self.reset_CP_run_3}
        run: Callable[[], None] | None = func_list.get(mode)
        if run is not None: run()
        else: flam3h_general_utils.set_status_msg(f"{self.node.name()}: reset_CP(...) python definition have nothing to run with the passed \"mode\" value: {mode}", 'WARN')
        
        
    def reset_CP_palette_action(self) -> None:
        """Run the desired reset_CP(...) from the Palette action button.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        if self.kwargs['ctrl']: self.reset_CP(1)
        else: self.reset_CP(3)


# FLAM3H™ ABOUT start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class flam3h_about_utils():
    """
class flam3h_about_utils

@STATICMETHOD
* flam3h_about_show_info_panel() -> None:

@METHODS
* flam3h_about_msg(self) -> None:
* flam3h_about_plugins_msg(self) -> None:
* flam3h_about_web_msg(self) -> None:
* flam3h_about_web_homepage(self) -> None:
* flam3h_about_web_github(self) -> None:
* flam3h_about_web_instagram(self) -> None:
* flam3h_about_web_youtube(self) -> None:
* flam3h_about_web_flam3_paper(self) -> None:
* flam3h_about_web_flam3_github(self) -> None:
* flam3h_web_run(self, key: str) -> None:
    """
    
    __slots__ = ("_kwargs", "_node")
    
    def __init__(self, kwargs: dict) -> None:
        """
        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """ 
        self._kwargs: dict[str, Any] = kwargs
        self._node: hou.SopNode = kwargs['node']
        
        
    @staticmethod
    def flam3h_about_show_info_panel(node: hou.SopNode) -> None:
        """Display default pyside about message panel.</br>
        
        Args:
            node(hou.SopNode): This FLAM3H™ node. In this case will be set to: kwargs['node'] directly in the parameter callback script string.
            
        Returns:
            (None):
        """ 
        
        pyside_utils.pyside_panels_safe_launch(
                                                pyside_master.F3H_msg_panel, 
                                                app_name=pyside_master_app_names.PS_CLS_ABOUT,
                                                f3h_node=node,  
                                                links=True,
                                                auto_close_ms=4000, 
                                                fade_in_ms=400, 
                                                fade_out_ms=400
                                               )
        
        

    # CLASS: PROPERTIES
    ##########################################
    ##########################################
        
    @property
    def kwargs(self) ->  dict[str, Any]:
        return self._kwargs
    
    @property
    def node(self) -> hou.SopNode:
        return self._node
        

    def flam3h_about_msg(self) -> None:
        """Build and set the FLAM3H™ about message.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """    
        
        nl: str = "\n"
        nnl: str = "\n\n"
        
        # year = datetime.now().strftime("%Y")
        
        flam3h_author: str = f"AUTHOR: {__author__}"
        flam3h_cvex_version: str = f"CODE: cvex H{flam3h_scripts.flam3h_h_versions_build_data(nodetype.hdaModule().__h_versions__, True)}"
        flam3h_python_version: str = f"Python {__py_version__}"
        flam3h_houdini_version: str = f"VERSION: {__version__} - {__status__} :: ({__license__})"
        Implementation_build: str = f"{flam3h_author}\n{flam3h_houdini_version}\n{flam3h_cvex_version}, {flam3h_python_version}\n{__copyright__}"
        
        code_references: str = f"""CODE REFERENCES
Flam3 :: ({__license__})
Apophysis :: ({__license__})
Fractorium :: ({__license__})"""

        special_thanks: str = """SPECIAL THANKS
Praveen Brijwal"""

        example_flames: str = """EXAMPLE FLAMES
C-91, Gabor Timar, Golubaja, Pillemaster,
Plangkye, Tatasz, Triptychaos, TyrantWave,
Zy0rg, Seph, Lucy, b33rheart, Neonrauschen."""
        
        h_version: str = '.'.join(str(x) for x in hou.applicationVersion())
        Houdini_version: str = f"HOST\nSideFX Houdini {h_version}"
        Python_version: str = f"Python: {python_version()}"
        license_type: str = str(hou.licenseCategory()).split(".")[-1]
        Houdini_license: str = f"License: {license_type}"
        User: str = f"User: {hou.userName()}"
        PC_name: str = f"Machine name: {hou.machineName()}"
        Platform: str = f"Platform: {hou.applicationPlatformInfo()}"
        
        build: tuple[str, ...] = (Implementation_build, nnl,
                                code_references, nnl,
                                special_thanks, nnl,
                                example_flames, nnl,
                                Houdini_version, nl,
                                Houdini_license, nl,
                                Python_version, nl,
                                User, nl,
                                PC_name, nl,
                                Platform
                                )
        
        self.node.parm(f3h_tabs.ABOUT.MSG_PRM_F3H_ABOUT).set(''.join(build))


    def flam3h_about_plugins_msg(self) -> None:
        """Build and set the FLAM3H™ about plugins message.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """    
        _str_capitalize: Callable[[str], str] = str.capitalize
        vars_sorted: list[str] = [_str_capitalize(var) for var in sorted(VARS_FLAM3_DICT_IDX.keys()) if var not in ("linear3d",)]
        n: int = 5
        vars_sorted_grp: list[list[str]] = [vars_sorted[i:i + n] for i in range(0, len(vars_sorted), n)]
        _join: Callable[[Iterable[str]], str] = ', '.join
        _len: Callable[[list[Any]], int] = len
        vars_txt: str = ''.join( [_join(grp) + "." if idx == (_len(vars_sorted_grp)-1) else _join(grp) + ",\n" for idx, grp in enumerate(vars_sorted_grp)] )
        vars_txt_MSG: str = f"They are also available as PRE and POST.\n\nNumber of plugins/variations: {len(vars_sorted)}\n\n{vars_txt}"
        self.node.parm(f3h_tabs.ABOUT.MSG_PRM_F3H_PLUGINS).set(vars_txt_MSG)
        
        
    def flam3h_about_web_msg(self) -> None:
        """Build and set the FLAM3H™ about web heading's msgs.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """    
        
        node: hou.SopNode = self.node
        
        # values
        _FLAM3HWEB_MSG: str = 'FLAM3H™ web'
        _FLAM3HGIT_MSG: str = 'FLAM3H™ github'
        _FLAM3HINSTA_MSG: str = 'FLAM3H™ instagram'
        _FLAM3HYOUTUBE_MSG: str = 'FLAM3H™ youtube tutorials'
        _FLAM3PDF_MSG: str = 'The Fractal Flame Algorithm(FLAM3) pdf'
        _FLAM3GIT_MSG: str = 'The Fractal Flame Algorithm(FLAM3) github'
        _FRACTGIT_MSG: str = 'Fractorium github'
        _FRACTWEB_MSG: str = 'Fractorium web'
        
        # {prm_name: value, ...}
        parms_about_web: dict[str, str] = { f3h_tabs.ABOUT.MSG_PRM_F3H_WEB: _FLAM3HWEB_MSG,
                                            f3h_tabs.ABOUT.MSG_PRM_F3H_GIT: _FLAM3HGIT_MSG,
                                            f3h_tabs.ABOUT.MSG_PRM_F3H_INSTA: _FLAM3HINSTA_MSG,
                                            f3h_tabs.ABOUT.MSG_PRM_F3H_YOUTUBE: _FLAM3HYOUTUBE_MSG,
                                            f3h_tabs.ABOUT.MSG_PRM_FLAM3_PDF: _FLAM3PDF_MSG,
                                            f3h_tabs.ABOUT.MSG_PRM_FLAM3_GIT: _FLAM3GIT_MSG,
                                            f3h_tabs.ABOUT.MSG_PRM_FRACT_GITHUB: _FRACTGIT_MSG,
                                            f3h_tabs.ABOUT.MSG_PRM_FRACT_WEB: _FRACTWEB_MSG
                                            }
        flam3h_prm_utils.setParms(node, parms_about_web)
        

    def flam3h_about_web_homepage(self) -> None:
        """Open a web browser to the FLAM3H™ homepage.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        page: str = "https://www.alexnardini.net/"
        www_open(page)
        

    def flam3h_about_web_github(self) -> None:
        """Open a web browser to the FLAM3H™ github repository.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """  
        page: str = "https://github.com/alexnardini/FLAM3_for_SideFX_Houdini"
        www_open(page)
        

    def flam3h_about_web_instagram(self) -> None:
        """Open a web browser to the FLAM3H™ instagram account.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """  
        page: str = "https://www.instagram.com/alexnardini/"
        www_open(page)
    
    
    def flam3h_about_web_youtube(self) -> None:
        """Open a web browser to the FLAM3H™ youtube video tutorials.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """  
        page: str = "https://www.youtube.com/@alexnardiniITALY/videos"
        www_open(page)


    def flam3h_about_web_flam3_paper(self) -> None:
        """Open a web browser to the original "the fractal flame algorithm" publication/paper pdf.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """  
        page: str = "https://flam3.com/flame_draves.pdf"
        www_open(page)
        

    def flam3h_about_web_flam3_github(self) -> None:
        """Open a web browser to the original FLAM3 github repository.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """  
        page: str = "https://github.com/scottdraves/flam3"
        www_open(page)
        
        
    def flam3h_about_web_bitbucket(self) -> None:
        """Open a web browser to the Fractorium Bitbucket repository.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """  
        page: str = "https://bitbucket.org/mfeemster/fractorium/src/master/"
        www_open(page)
        
        
    def flam3h_about_web_fractorium_github(self) -> None:
        """Open a web browser to the Fractorium Bitbucket repository.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """  
        page: str = "https://github.com/mfeemster/fractorium/tree/master"
        www_open(page)
        
        
    def flam3h_about_web_fractorium(self) -> None:
        """Open a web browser to the Fractorium Bitbucket repository.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """  
        page: str = "http://fractorium.com/"
        www_open(page)
        
        
    def flam3h_web_run(self, key: str) -> None:
        """Select the appropriate web open definition to run.</br>

        Args:
            (self):
            key(str): The key value that define whitch web definition to run.

        Returns:
            (None):
        """
        
        web: dict[str, Callable[[], None]] = {'web': self.flam3h_about_web_homepage,
                                              'git': self.flam3h_about_web_github,
                                              'insta': self.flam3h_about_web_instagram,
                                              'youtube': self.flam3h_about_web_youtube,
                                              'paper': self.flam3h_about_web_flam3_paper,
                                              'flam3git': self.flam3h_about_web_flam3_github,
                                              'fractbitbucket': self.flam3h_about_web_bitbucket,
                                              'fractgithub': self.flam3h_about_web_fractorium_github,
                                              'fractweb': self.flam3h_about_web_fractorium,
                                            }
        
        run: Callable[[], None] | None = web.get(key)
        if run is not None: run()


# FLAM3H™ UI MESSAGES start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class flam3h_ui_msg_utils():
    """
class flam3h_ui_msg_utils

@METHODS
* ui_xaos_infos(self) -> None:
* ui_OUT_presets_name_infos(self) -> None:
    """
    
    __slots__ = ("_kwargs", "_node")
    
    def __init__(self, kwargs: dict) -> None:
        """
        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """ 
        self._kwargs: dict[str, Any] = kwargs
        self._node: hou.SopNode = kwargs['node']


    # CLASS: PROPERTIES
    ##########################################
    ##########################################
        
    @property
    def kwargs(self) ->  dict[str, Any]:
        return self._kwargs
    
    @property
    def node(self) -> hou.SopNode:
        return self._node
        

    def ui_xaos_infos(self) -> None:
        """Open a message window with informations/tips about setting Xaos.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        
        ALL_msg = """The default mode is \"xaos TO\".\nYou can change it to use \"xaos FROM\" mode instead in the preferences tab.

Xaos is fully automatic,
however below are some general rules on how it work:


XAOS USAGE:

To set Xaos for a flame with 4 iterators,
use the " xaos: " keyword followed by each iterator weights values separated by a colon:
\" xaos:1:2:3:4 \" ( xaos keyword can be uppercase too if you prefer. )

If no set,
FLAM3H™ will assume all Xaos values are 1.0, the equivalent of: \" xaos:1:1:1:1 \"

If you set only iterator 1 and iterator 2,
FLAM3H™ will always fill in the rest with a value of 1.0. \" xaos:0:0 \" will be interpreted as \" xaos:0:0:1:1 \"

When turning iterators ON and OFF and removing or adding them,
FLAM3H™ will internally remove and reformat Xaos values
to account for missing iterators. In short, it is fully automatic.


XAOS COMMAND OPTIONS:

If you type a non-numeric character in any of the xaos's weights,
FLAM3H™ will undo to what you had before.

If you dnt use the “ xaos: ” keywork at the beginning,
FLAM3H™ will undo to what you had before.

If you type a number,
the entire xaos string will be reset to all weights set to that number.

If you type a negative number, it will be reset to a value of: 1"""
        
        node: hou.SopNode = self.node
        # Check and Update this data
        flam3h_iterator_utils(self.kwargs).update_xml_last_loaded()

        if self.kwargs["ctrl"]:
            if hou.isUIAvailable():
                hou.ui.displayMessage(ALL_msg, buttons=("Got it, thank you",), severity = hou.severityType.Message, default_choice = 0, close_choice = -1, help = None, title = "FLAM3H™ Xaos usage infos", details = None, details_label = None, details_expanded = False) # type: ignore

        else:
            # current node
            autodiv = node.parm(f3h_tabs.PREFS.PVT_PRM_XAOS_AUTO_SPACE).eval()
            if autodiv:
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XAOS_AUTO_SPACE, 0)
                flam3h_iterator_utils(self.kwargs).auto_set_xaos()
                
                _MSG: str = f"{node.name()}: Xaos weights auto space: OFF"
                flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                
            else:
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XAOS_AUTO_SPACE, 1)
                flam3h_iterator_utils(self.kwargs).auto_set_xaos()
                
                _MSG: str = f"{node.name()}: Xaos weights auto space: ON"
                flam3h_general_utils.set_status_msg(_MSG, 'IMP')

            
    def ui_OUT_presets_name_infos(self) -> None:
        """Open a message window with informations/tips about setting Flame names in the OUT tab.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """

        
        ALL_msg = """ The iteration number you want your fractal flame to use when you load it back into FLAM3H™
can be baked into the preset name you choose for it. 

For instance,
the Flame preset “My_Awesome_GrandJulia” will be loaded with 64 iterations by default.
However, if the iteration number is added to the preset name after a double colon,
as in “My_Awesome_GrandJulia::16,” it will override all settings
and load the preset with 16 as the iteration numbers.

Therefore,
do some tests before saving it,
and choose the ideal iteration number to incorporate into the preset name.

If you like,
you can manually edit the created XML/Flame file
and change the flame → “name” key afterwards.
    
"""
        if hou.isUIAvailable():
            hou.ui.displayMessage(ALL_msg, buttons=("Got it, thank you",), severity = hou.severityType.Message, default_choice = 0, close_choice = -1, help = None, title = "FLAM3H™ Presets name infos", details = None, details_label = None, details_expanded = False) # type: ignore


# LOAD XML FLAME FILES start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class xml_keys:
    '''
    Xml standard keys for Xml flame files.</br>
    It also include Fractorium keys where applicable along with defaults.</br></br>
    
    Used when loading/saving flame Xml files.</br>
    
    Mainly for organizational purposes and namespace.</br></br>
    
    * Xml keys names always start with the prefix: <b>XML_</b>
    * Default values always start with the prefix: <b>DEFAULT_</b>
    * Regex always start with the prefix: <b>REGEX_</b>
    * Miscellaneous constants can be anything else.</b>
    '''
    # For now we force to assume a valid flame's XML file must have this tree.root name.
    XML_ROOT: Final = 'flames'
    # And this for a valid chaotica file ( not supported )
    XML_ROOT_CHAOS: Final = 'ifs'

    XML_APP_NAME_FLAM3H: Final = 'FLAM3H'
    XML_APP_NAME_FRACTORIUM: Final = 'EMBER'

    XML_NAME: Final = 'flame'
    XML_VERSION: Final = 'version'
    XML_SIZE: Final = 'size'
    XML_RESOLUTION: Final = 'resolution' # This is not used by the Flame format but only a one off for the IN Infos Flame stats UI
    XML_CENTER: Final = 'center'
    XML_ROTATE: Final = 'rotate'
    XML_SCALE: Final = 'scale'
    XML_BG: Final = 'background'
    XML_SUPERSAMPLE: Final = 'supersample'
    XML_FILTER: Final = 'filter'
    XML_QUALITY: Final = 'quality'
    XML_BRIGHTNESS: Final = 'brightness'
    XML_GAMMA: Final = 'gamma'
    XML_GAMMA_THRESHOLD: Final = 'gamma_threshold'
    XML_VIBRANCY: Final = 'vibrancy'
    XML_POWER: Final = 'highlight_power'
    XML_K2: Final = 'logscale_k2'
    XML_RADIUS: Final = 'estimator_radius'
    XML_ESTIMATOR_MINIMUM: Final = 'estimator_minimum'
    XML_ESTIMATOR_CURVE: Final = 'estimator_curve'
    XML_PALETTE_MODE: Final = 'palette_mode'
    XML_INTERPOLATION: Final = 'interpolation'
    XML_INTERPOLATION_TYPE: Final = 'interpolation_type'
    XML_PLUGINS: Final = 'plugins'
    XML_NEW_LINEAR: Final = 'new_linear'
    
    XML_CC_CURVES: Final = 'curves'    
    DEFAULT_CC_CURVES: Final = '0 0 1 0.25 0.25 1 0.5 0.5 1 0.75 0.75 1 0 0 1 0.25 0.25 1 0.5 0.5 1 0.75 0.75 1 0 0 1 0.25 0.25 1 0.5 0.5 1 0.75 0.75 1 0 0 1 0.25 0.25 1 0.5 0.5 1 0.75 0.75 1'
    DEFAULT_CC_CURVES_B: Final = '0 0 1 0.25 0.25 1 0.75 0.75 1 1 1 1 0 0 1 0.25 0.25 1 0.75 0.75 1 1 1 1 0 0 1 0.25 0.25 1 0.75 0.75 1 1 1 1 0 0 1 0.25 0.25 1 0.75 0.75 1 1 1 1'
    DEFAULT_CC_CURVES_C: Final = '0 0 1 0.25 0.25 1 1 1 1 0.75 0.75 1 0 0 1 0.25 0.25 1 1 1 1 0.75 0.75 1 0 0 1 0.25 0.25 1 1 1 1 0.75 0.75 1 0 0 1 0.25 0.25 1 1 1 1 0.75 0.75 1'
    DEFAULT_CC_CURVES_ALL: tuple[str, ...] = (DEFAULT_CC_CURVES.__str__(), DEFAULT_CC_CURVES_B.__str__(), DEFAULT_CC_CURVES_C.__str__()) # I'll do a better solution another day for this

    XML_CC_CURVE_OVERALL: Final = 'overall_curve'
    XML_CC_CURVE_RED: Final = 'red_curve'
    XML_CC_CURVE_GREEN: Final = 'green_curve'
    XML_CC_CURVE_BLUE: Final = 'blue_curve'
    DEFAULT_CC_CURVE: Final = '0 0 0.25 0.25 0.5 0.5 0.75 0.75 1 1'
    DEFAULT_CC_CURVE_B: Final = '0 0 0.25 0.25 0.75 0.75 1 1'
    DEFAULT_CC_CURVE_C: Final = '0 0 0.25 0.25 1 1 0.75 0.75' # This order is odd but I have some flames coming in with this so...
    DEFAULT_CC_CURVE_ALL: tuple[str, ...] = (DEFAULT_CC_CURVE.__str__(), DEFAULT_CC_CURVE_B.__str__(), DEFAULT_CC_CURVE_C.__str__()) # I'll do a better solution another day for this

    XML_PRE_AFFINE: Final = 'coefs'
    XML_POST_AFFINE: Final = 'post'

    XML_XF: Final = 'xform'
    XML_XF_NAME: Final = 'name'
    XML_XF_WEIGHT: Final = 'weight'
    XML_XF_COLOR: Final = 'color'
    XML_XF_VAR_COLOR: Final = 'var_color'
    XML_XF_SYMMETRY: Final = 'symmetry'
    XML_XF_COLOR_SPEED: Final = 'color_speed'
    XML_XF_OPACITY: Final = 'opacity'
    XML_XF_PB: Final = 'pre_blur'
    XML_XF_XAOS: Final = 'chaos'
    XML_XF_ANIMATE: Final = 'animate' # Fractorium only

    XML_FF: Final = 'finalxform'

    XML_PALETTE: Final = 'palette'
    XML_PALETTE_COUNT: Final = 'count'
    XML_PALETTE_FORMAT: Final = 'format'
    
    DEFAULT_VAR_PRE_PRX: Final = "pre_"
    DEFAULT_VAR_POST_PRX: Final = "post_"
    
    REGEX_PRE = "^(?:pre_)"
    REGEX_POST = "^(?:post_)"
    
    
    class f3h:
        '''
        FLAM3H™ custom XML keys and defaults.</br>
        Used when loading/saving flame XML files.</br>
        '''
        XML_RIP: Final = 'flam3h_rip'
        XML_F3C: Final = 'flam3h_f3c'
        XML_HSV: Final = 'flam3h_hsv'
        XML_MB_FPS: Final = 'flam3h_mb_fps'
        XML_MB_SAMPLES: Final = 'flam3h_mb_samples'
        XML_MB_SHUTTER: Final = 'flam3h_mb_shutter'
        XML_CP_SAMPLES: Final = 'flam3h_cp_samples'
        XML_CP_SAMPLES_BASIS: Final = 'flam3h_cp_basis'
        
        XML_PRE_AFFINE: Final = 'f3h_coefs'
        XML_PRE_AFFINE_ANGLE: Final = 'f3h_coefs_angle'
        XML_POST_AFFINE: Final = 'f3h_post'
        XML_POST_AFFINE_ANGLE: Final = 'f3h_post_angle'
        
        # It happen that Houdini sometime round value to many, many decimals.
        # I am limiting this to max 8 decimals on export so not to have the xml file explode with trailing floats...
        # Increase this if for some reason you need more precision.
        DEFAULT_ROUND_DECIMAL_COUNT: Final = 8
        
        # LIMITS for the number of variations FLAM3H™ allow based on their type.
        DEFAULT_MAX_ITER_VARS: Final = 4
        DEFAULT_MAX_ITER_VARS_PRE: Final = 2
        DEFAULT_MAX_ITER_VARS_POST: Final = 1
        DEFAULT_MAX_FF_VARS: Final = 2
        DEFAULT_MAX_FF_VARS_PRE: Final = 1
        DEFAULT_MAX_FF_VARS_POST: Final = 2


# XML OUT render key data prm names HOUDINI
# for now make sense to expose those, I may add more in the future if needed
# Note that those are the FLAM3H™ UI parameter's names for the OUT Render properties tab.
XML_RENDER_HOUDINI_DICT: dict[str, str] = { xml_keys.XML_XF_NAME: f3h_tabs.OUT.PRM_FLAME_PRESET_NAME,
                                            xml_keys.XML_SIZE: f3h_tabs.OUT.PRM_RENDER_SIZE,
                                            xml_keys.XML_CENTER: f3h_tabs.OUT.PRM_RENDER_CENTER,
                                            xml_keys.XML_ROTATE: f3h_tabs.OUT.PRM_RENDER_ROTATE,
                                            xml_keys.XML_SCALE: f3h_tabs.OUT.PRM_RENDER_SCALE,
                                            xml_keys.XML_QUALITY: f3h_tabs.OUT.PRM_RENDER_QUALITY,
                                            xml_keys.XML_BRIGHTNESS: f3h_tabs.OUT.PRM_RENDER_BRIGHTNESS,
                                            xml_keys.XML_GAMMA: f3h_tabs.OUT.PRM_RENDER_GAMMA,
                                            xml_keys.XML_POWER: f3h_tabs.OUT.PRM_RENDER_POWER,
                                            xml_keys.XML_K2: f3h_tabs.OUT.PRM_RENDER_K2,
                                            xml_keys.XML_VIBRANCY: f3h_tabs.OUT.PRM_RENDER_VIBRANCY,
                                            xml_keys.XML_CC_CURVES: f3h_tabs.PREFS.PVT_PRM_RENDER_CC_CURVES,
                                            xml_keys.XML_CC_CURVE_OVERALL: f3h_tabs.PREFS.PVT_PRM_RENDER_CC_CURVE_OVERALL,
                                            xml_keys.XML_CC_CURVE_RED: f3h_tabs.PREFS.PVT_PRM_RENDER_CC_CURVE_RED,
                                            xml_keys.XML_CC_CURVE_GREEN: f3h_tabs.PREFS.PVT_PRM_RENDER_CC_CURVE_GREEN,
                                            xml_keys.XML_CC_CURVE_BLUE: f3h_tabs.PREFS.PVT_PRM_RENDER_CC_CURVE_BLUE
                                            }


# This is used inside: __get_name_list_str(...)
# to set what default single value should be used in case something goes wrong during the processed string value cleanup/correction
XML_TO_F3H_DEFAULT_VALS: dict[str, str] = { xml_keys.XML_XF_WEIGHT: '0.5', 
                                            xml_keys.XML_XF_COLOR: '0', 
                                            xml_keys.XML_XF_COLOR_SPEED: '0', 
                                            xml_keys.XML_XF_SYMMETRY: '0', 
                                            xml_keys.XML_XF_OPACITY: '1', 
                                            xml_keys.f3h.XML_HSV: '1', 
                                            xml_keys.XML_SIZE: '1024'
                                            }


# This is used inside: def xf_list_cleanup(...) and def xf_list_cleanup_str(...)
# to gather a proper default list of values in case the one from the XML is empty.
XML_TO_F3H_LIST_DEFAULT_VALS: dict[str, str] = {xml_keys.XML_SIZE: '1024 1024', 
                                                xml_keys.XML_CENTER: '0 0', 
                                                xml_keys.f3h.XML_HSV: '1 1 1'
                                                }


# Since we get the folowing keys in a separate action, we exclude them for later variation's names searches to help speed up a little.
XML_XF_KEY_EXCLUDE: tuple[str, ...] = ( xml_keys.XML_XF_WEIGHT, 
                                        xml_keys.XML_XF_COLOR, 
                                        xml_keys.XML_XF_VAR_COLOR, 
                                        xml_keys.XML_XF_SYMMETRY, 
                                        xml_keys.XML_XF_COLOR_SPEED, 
                                        xml_keys.XML_XF_NAME, 
                                        xml_keys.XML_XF_ANIMATE, # this is being added as it is a Fractorium only XML key and we are not using it in FLAM3H™
                                        xml_keys.XML_XF_PB, 
                                        xml_keys.XML_PRE_AFFINE, 
                                        xml_keys.f3h.XML_PRE_AFFINE, 
                                        xml_keys.f3h.XML_PRE_AFFINE_ANGLE, 
                                        xml_keys.XML_POST_AFFINE, 
                                        xml_keys.f3h.XML_POST_AFFINE, 
                                        xml_keys.f3h.XML_POST_AFFINE_ANGLE, 
                                        xml_keys.XML_XF_XAOS, 
                                        xml_keys.XML_XF_OPACITY
                                        )


# This has been fixed and now radial_blur variation matches all the other apps
# but I leave it here just in case other variation will need it.
XML_XF_PRM_EXCEPTION: tuple[str, ...] = ("None",)


# This is used as a faster idx lookup table.
# From the XML's xforms, each variations look itself up inside here to get the corresponding FLAM3H™ var idx it is mapped to.
# The key names matter and must match the variation's names as known by other apps ( in my case: Apophysis and Fratorium )
#
# Note:
#       Variation name "linear3d" has been added to this dict as it is often used in old Flames and we are remapping it to "linear" on load.
VARS_FLAM3_DICT_IDX: dict[str, int] = { "linear": 0, 
                                        "linear3d": 0, 
                                        "sinusoidal": 1,
                                        "spherical": 2,
                                        "swirl": 3,
                                        "horseshoe": 4,
                                        "polar": 5,
                                        "handkerchief": 6,
                                        "heart": 7,
                                        "disc": 8,
                                        "spiral": 9,
                                        "hyperbolic": 10,
                                        "diamond": 11,
                                        "ex": 12,
                                        "julia": 13,
                                        "bent": 14,
                                        "waves": 15,
                                        "fisheye": 16,
                                        "popcorn": 17,
                                        "exponential": 18,
                                        "power": 19,
                                        "cosine": 20,
                                        "rings": 21,
                                        "fan": 22,
                                        "bubble": 23,
                                        "cylinder": 24,
                                        "eyefish": 25,
                                        "blur": 26,
                                        "curl": 27,
                                        "ngon": 28,
                                        "pdj": 29,
                                        "blob": 30,
                                        "julian": 31,
                                        "juliascope": 32,
                                        "gaussian_blur": 33,
                                        "fan2": 34,
                                        "rings2": 35,
                                        "rectangles": 36,
                                        "radial_blur": 37,
                                        "pie": 38,
                                        "arch": 39,
                                        "tangent": 40,
                                        "square": 41,
                                        "rays": 42,
                                        "blade": 43,
                                        "secant2": 44,
                                        "twintrian": 45,
                                        "cross": 46,
                                        "disc2": 47,
                                        "super_shape": 48,
                                        "flower": 49,
                                        "conic": 50,
                                        "parabola": 51,
                                        "bent2": 52,
                                        "bipolar": 53,
                                        "boarders": 54,
                                        "butterfly": 55,
                                        "cell": 56,
                                        "cpow": 57,
                                        "edisc": 58,
                                        "elliptic": 59,
                                        "noise": 60,
                                        "escher": 61,
                                        "foci": 62,
                                        "lazysusan": 63,
                                        "loonie": 64,
                                        "pre_blur": 65,
                                        "modulus": 66,
                                        "oscilloscope": 67,
                                        "polar2": 68,
                                        "popcorn2": 69,
                                        "scry": 70,
                                        "separation": 71,
                                        "split": 72,
                                        "splits": 73,
                                        "stripes": 74,
                                        "wedge": 75,
                                        "wedge_julia": 76,
                                        "wedge_sph": 77,
                                        "whorl": 78,
                                        "waves2": 79,
                                        "exp": 80,
                                        "log": 81,
                                        "sin": 82,
                                        "cos": 83,
                                        "tan": 84,
                                        "sec": 85,
                                        "csc": 86,
                                        "cot": 87,
                                        "sinh": 88,
                                        "cosh": 89,
                                        "tanh": 90,
                                        "sech": 91,
                                        "csch": 92,
                                        "coth": 93,
                                        "auger": 94,
                                        "flux": 95,
                                        "mobius": 96,
                                        "curve": 97,
                                        "perspective": 98,
                                        "bwraps": 99,
                                        "hemisphere": 100,
                                        "polynomial": 101,
                                        "crop": 102,
                                        "unpolar": 103,
                                        "glynnia": 104, 
                                        "point_symmetry": 105
                                        }

# This dictionary for a faster look up table, Fractorium has so many variations!
# We are using this to check for missing variations coming from the loaded flame file
# as Fractorium seem to have them all ;) and it is the app I am now comparing against for this data.
#
# All of the variations that Fractorium has but FLAM3H™ does not are known as: Missing variations.
# FLAM3H™ was designed to work in tandem with Fractorium,
# and it makes an effort to learn as much as it can about everything that Fractorium is capable of, in this case, about all the variations he posses.
# All of the variations that Fractorium lacks will be categorized as: Unknown variations.
#
# If you want an Unknown variation to be recognized by FLAM3H™, add it here inside the corresponding dictionary letter entrie based on its name.

VARS_FRACTORIUM_DICT: dict[str, set[str]] = {"a": {"arch", "arcsech", "arcsech2", "arcsinh", "arctanh", "asteria", "auger"},
                                            "b": {"barycentroid", "bcircle", "bcollide", "bent", "bent2", "bipolar", "bisplit", "blade", "blade3d", "blob", "blob2", "blob3d", "block", "blocky", "blur", "blur_circle", "blur_heart", "blur_linear", "blur_pixelize", "blur_square", "blur_zoom", "blur3d", "bmod", "boarders", "boarders2", "bswirl", "btransform", "bubble", "bubble2", "bubblet3d", "butterfly", "bwraps", "bwraps_rand"},
                                            "c": {"cardioid", "cell", "checks", "circleblur", "circlecrop", "circlecrop2", "circlelinear", "circlerand", "circlesplit", "circletrans1", "circlize", "circlize2", "circus", "collideoscope", "concentric", "conic", "cos", "cos_wrap", "cosh", "coshq", "cosine", "cosq", "cot", "coth", "coth_spiral", "cothq", "cotq", "cpow", "cpow2", "cpow3", "crackle", "crackle2", "crescents", "crob", "crop", "cropn", "cross", "csc", "csch", "cschq", "cscq", "cubic3d", "cubic_lattice3d", "curl", "curl3d", "curl_sp", "curvature", "curve", "cylinder", "cylinder2"},
                                            "d": {"delta_a", "depth", "depth_blur", "depth_blur2", "depth_gaussian", "depth_gaussian2", "depth_ngon", "depth_ngon2", "depth_sine", "depth_sine2", "diamond", "disc", "disc2", "disc3d", "dragonfire", "dust","d_spherical"},
                                            "e": {"eclipse", "ecollide", "edisc", "ejulia", "elliptic", "emod", "emotion", "ennepers", "epispiral", "epush", "erf", "erotate", "escale", "escher", "estiq", "eswirl", "ex", "excinis", "exp", "exp2", "expo", "exponential", "extrude", "eyefish"},
                                            "f": {"falloff", "falloff2", "falloff3", "fan", "fan2", "farblur", "fdisc", "fibonacci", "fibonacci2", "fisheye", "flatten", "flip_circle", "flip_x", "flip_y", "flower", "flower_db", "flux", "foci", "foci3d", "foci_p", "fourth", "funnel"},
                                            "g": {"gamma", "gaussian", "gaussian_blur", "gdoffs", "glynnia", "glynnia2", "glynnsim1", "glynnsim2", "glynnsim3", "glynnsim4", "glynnsim5", "gnarly", "gridout"},
                                            "h": {"handkerchief", "heart", "heat", "helicoid", "helix", "hemisphere", "henon", "hexaplay3d", "hexcrop", "hexes", "hexnix3d", "hex_modulus", "hex_rand", "hex_truchet", "ho", "hole", "horseshoe", "hyperbolic", "hypercrop", "hypershift", "hypershift2", "hypertile", "hypertile1", "hypertile2", "hypertile3d", "hypertile3d1", "hypertile3d2"},
                                            "i": {"idisc", "inkdrop", "interference2"},
                                            "j": {"jac_cn", "jac_dn", "jac_sn", "julia", "julia3d", "julia3dq", "julia3dz", "juliac", "julian", "julian2", "julian3dx", "julianab", "juliaq", "juliascope"}, 
                                            "k": {"kaleidoscope"},
                                            "l": {"lazyjess", "lazysusan", "lazy_travis", "lens", "line", "linear", "linear_t", "linear_t3d", "linear_xz", "linear_yz", "linear3d", "lissajous", "log", "log_db", "loq", "loonie", "loonie2", "loonie3", "loonie3d", "lozi"},
                                            "m": {"mask", "mcarpet", "mirror_x", "mirror_y", "mirror_z", "mobiq", "mobius", "mobius_strip", "mobiusn", "modulus", "modulusx", "modulusy", "murl", "murl2"},
                                            "n": {"nblur", "ngon", "noise", "npolar"},
                                            "o": {"octagon", "octapol", "ortho", "oscilloscope", "oscilloscope2", "ovoid", "ovoid3d"},
                                            "p": {"panorama1", "panorama2", "parabola", "pdj", "perspective", "petal", "phoenix_julia", "pie", "pie3d", "pixel_flow", "poincare", "poincare2", "poincare3d", "point_symmetry", "polar", "polar2", "polynomial", "popcorn", "popcorn2", "popcorn23d", "pow_block", "power", "pressure_wave", "projective", "prose3d", "psphere", "pulse"},
                                            "q": {"q_ode"},
                                            "r": {"radial_blur", "radial_gaussian", "rand_cubes", "rational3", "rays", "rays1", "rays2", "rays3", "rblur", "rectangles", "rings", "rings2", "ripple", "rippled", "rotate", "rotate_x", "rotate_y", "rotate_z", "roundspher", "roundspher3d"},
                                            "s": {"scry", "scry2", "scry3d", "sec", "secant2", "sech", "sechq", "secq", "separation", "shift", "shred_rad", "shred_lin", "sigmoid", "sin", "sineblur", "sinh", "sinhq", "sinq", "sintrange", "sinus_grid", "sinusoidal", "sinusoidal3d", "smartshape", "smartcrop", "spher", "sphereblur", "spherical", "spherical3d", "sphericaln", "spherivoid", "sphyp3d", "spiral", "spiral_wing", "spirograph", "split", "split_brdr", "splits", "splits3d", "square", "squares", "square3d", "squarize", "squirrel", "squish", "sschecks", "starblur", "starblur2", "stripes", "stwin", "super_shape", "super_shape3d","svf", "swirl", "swirl3", "swirl3r", "synth"},
                                            "t": {"tan", "tancos", "tangent", "tanh", "tanhq", "tanh_spiral", "tanq", "target", "target0", "target2", "taurus", "tile_hlp", "tile_log", "trade", "truchet", "truchet_fill", "truchet_hex_fill", "truchet_hex_crop", "truchet_glyph", "truchet_inv", "truchet_knot", "twintrian", "twoface"},
                                            "u": {"unicorngaloshen", "unpolar"},
                                            "v": {"vibration", "vibration2", "vignette", "voron"},
                                            "w": {"w", "waffle", "waves", "waves2", "waves22", "waves23", "waves23d", "waves2b", "waves2_radial", "waves3", "waves4", "waves42", "wavesn", "wdisc", "wedge", "wedge_julia", "wedge_sph", "whorl"},
                                            "x": {"x", "xerf", "xheart", "xtrb"},
                                            "y": {"y"},
                                            "z": {"z", "zblur", "zcone", "zscale","ztranslate"}
                                            }


class flam3h_varsPRM_APO:
    
    '''
    The following parameters matches the Apophysis/Fractorium parameter's names,
    so no need to regex for now as the strings names are matching already.
    
    There are a few exceptions so far witch I handled simply for now, but it work.
    
    They are grouped as follow and based on the FLAM3H™ node parametric parameters:
    
    for generic variation:
    ("variation name", bool: (parametric or not parametric)),
    
    for parametric variation:
    ("variation name", (prm_1, ..., prm_4), (prm_1, ..., prm_4), bool: (parametric or not parametric)),
    
    -> (prm_1, ..., prm_4) accept a max of 4 entries (hou.Vector4) and based on the number of parameters
    they are then automatically converted to the expeted v_type using the function: 
    in_flame_utils.in_util_typemaker(data: list) -> TA_TypeMaker:
    
    The (("variation_name") entrie, is not used here and only for reference.
    '''
    
    __slots__ = ("varsPRM", "varsPRM_FRACTORIUM_EXCEPTIONS")
    
    def __init__(self) -> None:
        
        self.varsPRM: tuple[tuple, ...] = ( ("linear", 0), 
                                            ("sinusoidal", 0), 
                                            ("spherical", 0), 
                                            ("swirl", 0), 
                                            ("horseshoe", 0), 
                                            ("polar", 0), 
                                            ("handkerchief", 0), 
                                            ("heart", 0), 
                                            ("disc", 0), 
                                            ("spiral", 0), 
                                            ("hyperbolic", 0), 
                                            ("diamond", 0), 
                                            ("ex", 0), 
                                            ("julia", 0), 
                                            ("bent", 0), 
                                            ("waves", 0), 
                                            ("fisheye", 0), 
                                            ("popcorn", 0), 
                                            ("exponential", 0), 
                                            ("power", 0), 
                                            ("cosine", 0), 
                                            ("rings", 0), 
                                            ("fan", 0), 
                                            ("bubble", 0), 
                                            ("cylinder", 0), 
                                            ("eyefish", 0), 
                                            ("blur", 0), 
                                            ("curl", ("curl_c1", "curl_c2"), 1), 
                                            ("ngon", ("ngon_power", "ngon_sides", "ngon_corners", "ngon_circle"), 1), 
                                            ("pdj", ("pdj_a", "pdj_b", "pdj_c", "pdj_d"), 1), 
                                            ("blob", ("blob_low", "blob_high", "blob_waves"), 1), 
                                            ("juliaN", ("julian_power", "julian_dist"), 1), 
                                            ("juliascope", ("juliascope_power", "juliascope_dist"), 1), 
                                            ("gaussian_blur", 0), 
                                            ("fan2", ("fan2_x", "fan2_y"), 1), 
                                            ("rings2", ("rings2_val",), 1), 
                                            ("rectangles", ("rectangles_x", "rectangles_y"), 1), 
                                            ("radial_blur", ("radial_blur_angle",), 1), 
                                            ("pie", ("pie_slices", "pie_thickness", "pie_rotation"), 1), 
                                            ("arch", 0), 
                                            ("tangent", 0), 
                                            ("square", 0), 
                                            ("rays", 0), 
                                            ("blade", 0), 
                                            ("secant2", 0), 
                                            ("twintrian", 0), 
                                            ("cross", 0), 
                                            ("disc2", ("disc2_rot", "disc2_twist"), 1), 
                                            ("supershape", ("super_shape_m", "super_shape_rnd", "super_shape_holes"), ("super_shape_n1", "super_shape_n2", "super_shape_n3"), 1), 
                                            ("flower", ("flower_petals", "flower_holes"), 1), 
                                            ("conic", ("conic_eccentricity", "conic_holes"), 1), 
                                            ("parabola", ("parabola_height", "parabola_width"), 1), 
                                            ("bent2", ("bent2_x", "bent2_y"), 1), 
                                            ("bipolar", ("bipolar_shift",), 1),
                                            ("boarders", 0),
                                            ("butterfly", 0), 
                                            ("cell", ("cell_size",), 1), 
                                            ("cpow", ("cpow_power", "cpow_r", "cpow_i"), 1), 
                                            ("edisc", 0), 
                                            ("elliptic", 0), 
                                            ("noise", 0), 
                                            ("escher", ("escher_beta",), 1), 
                                            ("foci", 0), 
                                            ("lazysusan", ("lazysusan_x", "lazysusan_y"), ("lazysusan_spin", "lazysusan_twist", "lazysusan_space"), 1), 
                                            ("loonie", 0), 
                                            ("pre blur", 0), 
                                            ("modulus", ("modulus_x", "modulus_y"), 1), 
                                            ("oscilloscope", ("oscope_frequency", "oscope_amplitude", "oscope_damping", "oscope_separation"), 1), 
                                            ("polar2", 0), 
                                            ("popcorn2", ("popcorn2_x", "popcorn2_y"), ("popcorn2_c",), 1), 
                                            ("scry", 0), 
                                            ("separation", ("separation_x", "separation_y"), ("separation_xinside", "separation_yinside"), 1), 
                                            ("split", ("split_xsize", "split_ysize"), 1), 
                                            ("splits", ("splits_x", "splits_y"), 1), 
                                            ("stripes", ("stripes_space", "stripes_warp"), 1), 
                                            ("wedge", ("wedge_swirl", "wedge_angle", "wedge_hole", "wedge_count",), 1), 
                                            ("wedge_julia", ("wedge_julia_power", "wedge_julia_angle", "wedge_julia_dist", "wedge_julia_count"), 1), 
                                            ("wedge_sph", ("wedge_sph_swirl", "wedge_sph_angle", "wedge_sph_hole", "wedge_sph_count"), 1), 
                                            ("whorl", ("whorl_inside", "whorl_outside"), 1), 
                                            ("waves2", ("waves2_scalex", "waves2_scaley"), ("waves2_freqx", "waves2_freqy"), 1), 
                                            ("exp", 0), 
                                            ("log", 0), 
                                            ("sin", 0), 
                                            ("cos", 0), 
                                            ("tan", 0), 
                                            ("sec", 0), 
                                            ("csc", 0), 
                                            ("cot", 0), 
                                            ("sinh", 0), 
                                            ("cosh", 0), 
                                            ("tanh", 0), 
                                            ("sech", 0), 
                                            ("csch", 0), 
                                            ("coth", 0), 
                                            ("auger", ("auger_freq", "auger_scale", "auger_sym", "auger_weight"), 1), 
                                            ("flux", ("flux_spread",), 1), 
                                            ("mobius", ("Re_A", "Re_B", "Re_C", "Re_D"), ("Im_A", "Im_B", "Im_C", "Im_D"), 1),
                                            ("curve", ("curve_xlength", "curve_ylength"), ("curve_xamp", "curve_yamp"), 1), 
                                            ("persp", ("perspective_angle", "perspective_dist"), 1), 
                                            ("bwraps", ("bwraps_cellsize", "bwraps_space", "bwraps_gain"), ("bwraps_inner_twist", "bwraps_outer_twist"), 1), 
                                            ("hemisphere", 0), 
                                            ("polynomial", ("polynomial_powx", "polynomial_powy"), ("polynomial_lcx", "polynomial_lcy"), ("polynomial_scx", "polynomial_scy"), 1),
                                            ("crop", ("crop_left", "crop_top", "crop_right", "crop_bottom"), ("crop_scatter_area", "crop_zero"), 1), 
                                            ("unpolar", 0), 
                                            ("glynnia", 0), 
                                            ("point_symmetry", ("point_symmetry_order", "point_symmetry_centre_x", "point_symmetry_centre_y"), 1)
                                        )


        # EXCEPTIONS: so I dnt go into regex...
        # Update this and def in_prm_name_exceptions() if you add/find more
        self.varsPRM_FRACTORIUM_EXCEPTIONS: dict[int, tuple] = {67: ("oscilloscope", ("oscilloscope_frequency", "oscilloscope_amplitude", "oscilloscope_damping", "oscilloscope_separation"), 1),
                                                                96: ("Mobius", ("Mobius_Re_A", "Mobius_Re_B", "Mobius_Re_C", "Mobius_Re_D"), ("Mobius_Im_A", "Mobius_Im_B", "Mobius_Im_C", "Mobius_Im_D"), 1)
                                                                }


# FLAM3H™ XML TREE start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class _xml:
    """
class _xml

@METHODS
* def get_name(self, key: str = xml_keys.XML_XF_NAME) -> tuple[str | list[Never], ...]:

    """    
    
    __slots__ = ("_xml", "_tree")
    
    def __init__(self, xmlfile: str) -> None:
        """This Class is only to try to speedup the python menu UI evaulation.</br>
        Here I assume that if the parameter IN_PVT_ISVALID_FILE is 1,</br>
        than we can proceed without worries about actually checking and iterate through the flame file for its validity.</br>
        It is a mere attempt to speedup but it should help a little bit ;)</br>
        as we are not evaluating the _xml_tree() class witch is more heavy and sophisticated, something we do not need for this purpose.</br>
        This is a very lightweight way to gather the Flames names.</br></br>
        
        A parameter to the IN Tab has been added: IN_PVT_ISVALID_PRESET</br>
        This parameter will tell us if a preset is currently loaded or not.</br></br>
        
        Before we only had: IN_PVT_ISVALID_FILE</br>
        so we were forced to read and evaluate the entire _xml_tree() class.</br>

        Args:
            xmlfile (str): The XML full file path name to evaluate
        """     
        self._xml: str = xmlfile
        self._tree: lxmlET._ElementTree = lxmlET.parse(xmlfile)


    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @property
    def xml(self) -> str:
        return self._xml
    
    @property
    def tree(self) -> lxmlET._ElementTree:
        return self._tree
        
        
    def get_name(self, key: str = xml_keys.XML_XF_NAME) -> tuple[str | list[Never], ...]:
        """Collect all Flame presets name from the XML Flame file.</br></br>
        
        This is being added as a quick and cheap way to do so making some assumption ahead of time.</br>
        Read this class __init__ doc string to know more.</br>

        Args:
            (self):
            key(str): Default to: xml_keys.XML_XF_NAME</br>The XML Flame's name key.

        Returns:
            (tuple[str | list[Never], ...]): Flame presets names packed into a tuple of strings</br>or an empty list instead if the XML key is not found in the XML preset. Or an empty tuple.
        """     
        if os.path.isfile(self.xml):
            _strip: Callable[[str], str] = str.strip 
            root: lxmlET._Element = self.tree.getroot()
            
            if xml_keys.XML_ROOT in root.tag.lower():
                return tuple(_strip(keyval) if (keyval := name.get(key)) is not None else [] for name in root)
            
            newroot: lxmlET._Element = lxmlET.Element(xml_keys.XML_ROOT)
            newroot.insert(0, root)
            return tuple(_strip(keyval) if (keyval := name.get(key)) is not None else [] for name in newroot)
        
        else:
            # inside a try/except block because it happened that when Houdini is busy like for example computing the flame while it is in camera sensor mode,
            # this failed on me once and it could not evaluate the hou.pwd() properly.

            try:
                # For safety, lets turn off those toggles
                flam3h_prm_utils.private_prm_set(hou.pwd(), f3h_tabs.IN.PVT_PRM_ISVALID_FILE, 0)
                flam3h_prm_utils.private_prm_set(hou.pwd(), f3h_tabs.IN.PVT_PRM_ISVALID_PRESET, 0)
            
            except (NameError, AttributeError):
                _MSG: str = ("\nFLAM3H -> warning: Could not evaluate the current hou.SopNode. Class _xml(...).get_name(...)\n")
                print(f"{_MSG}\n")
                flam3h_general_utils.set_status_msg(f"{_MSG}", 'WARN')
                
            return ()


class _xml_tree:
    """
class _xml_tree

@STATICMETHODS
* xmlfile_root_chk(xmlfile: str | None, clipboard: bool = False) -> str | None:
* xmlfile_isvalidtree_chk(xmlfile: str) -> bool:

@METHODS
* get_name(self, key: str = xml_keys.XML_XF_NAME) -> tuple[str | list[Never], ...]:
* __get_name_val_str(self, key: str, _DEFAULT: str = '0') -> tuple[str | list[Never], ...]:
* __get_name_curve_val_str(self, key: str, _DEFAULT: str = '0') -> tuple[str | list[Never], ...]:
* __get_name_list_str(self, key: str) -> tuple[str | list[Never], ...]:
* __get_flame(self, key: str = xml_keys.XML_NAME) -> tuple[lxmlET._Element, ...] | None:
* __get_flame_count(self, flames: list) -> int:

"""

    __slots__ = ("_cached_data", 
                 "_xmlfile", "_xmlfile_data", "_xmlfile_data_clipboard", "_isvalidtree", "_tree", "_root", 
                 "_name", "_plugins", "_sw_version")
    
    def __init__(self, xmlfile: str) -> None:
        """
        Args:
            (self):
            xmlfile (str): xmlfile (str): [xml *.flame file v_type to load]
        """
        self._xmlfile: str = xmlfile
        self._xmlfile_data: str | None = self.xmlfile_root_chk(self.xmlfile)
        self._xmlfile_data_clipboard: str | None = self.xmlfile_root_chk(self.xmlfile, True)
        self._isvalidtree: bool = self.xmlfile_isvalidtree_chk(self.xmlfile)
            
        if self.xmlfile_data_clipboard is not None:
            self._isvalidtree = True
            self._tree: lxmlET._ElementTree = lxmlET.ElementTree(lxmlET.fromstring(self.xmlfile_data_clipboard))
            self._root: lxmlET._Element = self.tree.getroot()
            
        elif self.xmlfile_data is not None:
            self._isvalidtree = True
            self._tree: lxmlET._ElementTree = lxmlET.ElementTree(lxmlET.fromstring(self.xmlfile_data))
            self._root: lxmlET._Element = self.tree.getroot()
            
        elif self._isvalidtree:
            self._tree: lxmlET._ElementTree = lxmlET.parse(self.xmlfile)
            self._root: lxmlET._Element = self.tree.getroot()
            
        # This not private as its cheaper to have it evaluate from this parent class.
        self._name: tuple[str | list[Never], ...] = self.get_name()
        self._plugins: tuple[str | list[Never], ...] = self.get_name(xml_keys.XML_PLUGINS)
        self._sw_version: tuple[str | list[Never], ...] = self.get_name(xml_keys.XML_VERSION)


    @staticmethod
    def xmlfile_root_chk(xmlfile: str | None, clipboard: bool = False) -> str | None:
        """When loading a Flame files, it can contain many flame presets in it.</br>
        When multiple flame presets are present into the file, they will all be grouped under a root with a name.</br>
        However, when you save a flame into the clipboard ( from FLAM3H™ but also from Apophysis, Fractorium and other)</br>
        the saved Flame wont be grouped under a root, but it will be rootless.</br></br>
        
        This definition will check if the loaded preset (from a file or from the Clipboard) lives under a root or not</br>
        and perform the necessary operation to be loaded inside FLAM3H™ either ways.</br></br>

        Args:
            xmlfile(str | None): The flame file full path string we are trying to load.</br>
            clipboard(bool): Default to: False</br>True if the flame preset is being loaded from the clipboard and False if not.</br>
            
        Returns:
            (str | None): A new flame preset data valid to be loaded in.
        """

        if clipboard:
            
            if xmlfile is not None:
                
                try:
                    tree: lxmlET._ElementTree = lxmlET.ElementTree(lxmlET.fromstring(xmlfile))
                    
                except ValueError:
                    return None
                
                except lxmlET.XMLSyntaxError:
                    return None
                
            else:
                
                try:
                    tree: lxmlET._ElementTree = lxmlET.parse(xmlfile)
                    
                except OSError:
                    return None
                
                except lxmlET.XMLSyntaxError:
                    return None
                
        else:
            
            if xmlfile is not None and os.path.isfile(xmlfile):
                
                try:
                    tree: lxmlET._ElementTree = lxmlET.parse(xmlfile)
                    
                except OSError:
                    return None
                
                except lxmlET.XMLSyntaxError:
                    return None
                
            else:
                return None
        
        root: lxmlET._Element = tree.getroot()
        root_tag: str = root.tag.lower()
        if xml_keys.XML_ROOT not in root_tag:
            newroot: lxmlET._Element = lxmlET.Element(xml_keys.XML_ROOT)
            newroot.insert(0, root)
            # If there are flames, proceed
            if any(True for _ in root.iter(xml_keys.XML_NAME)):
            
                out_flame_utils._out_pretty_print(newroot)
                return lxmlET.tostring(newroot, encoding="unicode")
            
            if xml_keys.XML_ROOT_CHAOS in root_tag:
                # let us know
                _MSG: str = "IN: Chaotica XML not supported"
                flam3h_general_utils.set_status_msg(f"{hou.pwd().name()}: {_MSG}", 'WARN')
                flam3h_general_utils.flash_message(hou.pwd(), _MSG)
                
            return None
        
        # If there are flames, proceed
        if any(True for _ in tree.getroot().iter(xml_keys.XML_NAME)):
        
            out_flame_utils._out_pretty_print(root)
            return lxmlET.tostring(root, encoding="unicode")
        
        return None


    @staticmethod
    def xmlfile_isvalidtree_chk(xmlfile: str) -> bool:
        """When loading a Flame files, this definition will check their data</br>
        and tell us if what we are trying to load is actually a valid flame data to be loaded.</br></br>

        Args:
            xmlfile(str): The flame file full path string we are trying to load.
            
        Returns:
            (bool): True if it is a valid flame preset data or False if Not
        """
        if os.path.isfile(xmlfile):
            
            try:
                tree: lxmlET._ElementTree = lxmlET.parse(xmlfile)
                
            except OSError:
                return False
            
            except lxmlET.XMLSyntaxError:
                return False
            
            else:
                
                if isinstance(tree, lxmlET._ElementTree):
                    
                    root: lxmlET._Element = tree.getroot()
                    if xml_keys.XML_ROOT in root.tag.lower():
                        
                        # If there are flames, proceed
                        if any(True for _ in root.iter(xml_keys.XML_NAME)):
                            return True
                        
                        return False
                    
                    return False
                
                return False
        else:
            return False


    # CLASS: PROPERTIES
    ##########################################
    ##########################################
    
    @cached_slot_property
    def xmlfile(self) -> str:
        return self._xmlfile
    
    @cached_slot_property
    def xmlfile_data(self) -> str | None:
        return self._xmlfile_data
    
    @cached_slot_property
    def xmlfile_data_clipboard(self) -> str | None:
        return self._xmlfile_data_clipboard
    
    @cached_slot_property
    def isvalidtree(self) -> bool:
        return self._isvalidtree
    
    @cached_slot_property
    def tree(self) -> lxmlET._ElementTree:
        return self._tree
    
    @cached_slot_property
    def root(self) -> lxmlET._Element:
        """Build the XML file root.<br/>
        
        Note:<br/>
        This will only be valid if: self._isvalidtree is True

        Args:
            (self):

        Returns:
            (lxmlET.etree._Element):
        """
        return self._root
    
    @cached_slot_property
    def name(self) -> tuple[str | list[Never], ...]:
        return self._name
    
    @cached_slot_property
    def plugins(self) -> tuple[str | list[Never], ...]:
        return self._plugins
    
    @cached_slot_property
    def sw_version(self) -> tuple[str | list[Never], ...]:
        return self._sw_version
    

    # This not private as its cheaper to have it evaluate from this parent class.
    def get_name(self, key: str = xml_keys.XML_XF_NAME) -> tuple[str | list[Never], ...]:
        """Collect all Flame presets name from the XML Flame file.</br>

        Args:
            (self):
            key(str): Default to: xml_keys.XML_XF_NAME</br>The XML Flame's name key.

        Returns:
            (tuple[str | list[Never], ...]): Flame presets names packed into a tuple of strings</br>or an empty list instead if the XML key is not found in the XML preset. Or an empty tuple.
        """
        if self.isvalidtree:
            
            root: lxmlET._Element = self.root
            _strip: Callable[[str], str] = str.strip
            _len: Callable[[str], int] = len
            if key == xml_keys.XML_XF_NAME:
                list_values_cleaned: tuple[str | list[Never], ...] = tuple(_strip(keyval) if (keyval := name.get(key)) is not None and _len(keyval) else '[]' for name in root)
            else:
                list_values_cleaned: tuple[str | list[Never], ...] = tuple(_strip(keyval) if (keyval := name.get(key)) is not None and _len(keyval) else [] for name in root)
            return list_values_cleaned
        
        return () 
        
        
    def __get_name_val_str(self, key: str, _DEFAULT: str = '0') -> tuple[str | list[Never], ...]:
        """Collect all Flame presets single value from the XML Flame file and return all of them packed into a tuple.</br>
        It will also scan each string value for invalid characters and try to remove them returning a cleaned up string value.</br>

        Args:
            (self):
            key(str): The XML Flame's name key.
            _DEFAULT(str): Default to: '0'</br>If something goes wrong, use this default value instead.

        Returns:
            (tuple[str | list[Never], ...]): Flame presets single string values packed into a tuple os strings</br>or an empty list instead if the XML key is not found in the XML preset. Or an empty tuple
        """      
        if self.isvalidtree:
            
            root: lxmlET._Element = self.root
            _strip: Callable[[str], str] = str.strip
            list_values_cleaned: tuple[str | list[Never], ...] = tuple(_strip(in_flame.xf_val_cleanup_str(keyval, _DEFAULT, key)) if (keyval := name.get(key)) is not None else [] for name in root)
            return list_values_cleaned
            
        return () 
        
        
    def __get_name_curve_val_str(self, key: str, _DEFAULT: str = '0') -> tuple[str | list[Never], ...]:
        """Collect all Flame presets multi color correction curve values from the XML Flame file and return all of them packed into a tuple.</br>
        It will also scan each string value for invalid characters and try to remove them returning a cleaned up string value.</br>

        Args:
            (self):
            key(str): The XML Flame's name key.
            _DEFAULT(str): Default to: '0'</br>If something goes wrong, use this default value instead.

        Returns:
            (tuple[str | list[Never], ...]): Flame presets multi color correction curve values packed into a tuple of strings</br>or an empty list instead if the XML key is not found in the XML preset. Or an empty tuple.
        """      
        if self.isvalidtree:
            
            root: lxmlET._Element = self.root
            _strip: Callable[[str], str] = str.strip
            _xf_val_cleanup_split_str: Callable[[str, str, str], str] = in_flame.xf_val_cleanup_split_str
            list_values_cleaned: tuple[str | list[Never], ...] = tuple(_strip(_xf_val_cleanup_split_str(keyval, _DEFAULT, key)) if (keyval := name.get(key)) is not None and keyval != '' else [] for name in root)
            return list_values_cleaned
            
        return () 
        
        
    def __get_name_list_str(self, key: str) -> tuple[str | list[Never], ...]:
        """Collect all Flame presets list values from the XML Flame file.</br>
        Some examples of values to use this definition with are: size, center...</br>
        (all key name that hold multiple string values in it)</br>

        Args:
            (self):
            key(str): The XML Flame's key name.

        Returns:
            (tuple[str | list[Never], ...]): Return all values packed into a tuple of strings</br>or an empty list instead if the XML key is not found in the XML preset. Or an empty tuple
        """
        if self.isvalidtree:
            
            _d: str | None = XML_TO_F3H_DEFAULT_VALS.get(key)
            if _d is not None: _default: str = _d
            else: _default: str = '0'
            
            root: lxmlET._Element = self.root
            _strip: Callable[[str], str] = str.strip
            _xf_list_cleanup_str: Callable[[list[str], str, str], str] = in_flame.xf_list_cleanup_str
            list_values_cleaned: tuple[str | list[Never], ...] = tuple(str(_xf_list_cleanup_str(_strip(keyval).split(), _default, key)) if (keyval := name.get(key)) is not None else [] for name in root)
            return list_values_cleaned
        
        return () 
        
        
    def __get_flame(self, key: str = xml_keys.XML_NAME) -> tuple[lxmlET._Element, ...] | None:
        """Collect the actual Flame presets object data from the XML file.</br>

        Args:
            (self):
            key (str): Default to: xml_keys.XML_NAME</br>The XML Flame's flame key.

        Returns:
            (tuple | None): Flames objects data or None if not found.
        """
        if self.isvalidtree:
            return tuple(f for f in self.root.iter(key))
        
        return None


    def __get_flame_count(self, flames: list) -> int:
        """Get the number of Flame presets inside the XML file.</br>

        Args:
            (self):
            flames(list): Flames objects data.

        Returns:
            (int): Number of Flames.
        """
        if self.isvalidtree:
            return len(flames)
        
        return 0


# FLAM3H™ IN FLAME start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class in_flame(_xml_tree):
    """
class in_flame

@STATICMETHODS
* xf_val_cleanup_split_str(val: str, default_val: str = '0', key_name: str | None = None) -> str:
* xf_val_cleanup_str(val: str, default_val: str = '0', key_name: str | None = None) -> str:
* xf_list_cleanup(vals: list[str], default_val: str = '0', key_name: str | None = None) -> list[str]:
* xf_list_cleanup_str(vals: list[str], default_val: str = '0', key_name: str | None = None) -> str:
* affine_coupling(affine: list[float], key: str = '', mp_idx: int | None = None, type: int = 0) -> list[hou.Vector2] | list[Never]:
* check_all_iterator_weights(node: hou.SopNode, keyvalues: list) -> None:

@METHODS
* __is_valid_idx(self, idx: int) -> int:
* __get_xforms(self, idx: int, key: str) -> tuple[dict, ...] | None:
* __get_xaos(self, xforms: tuple[dict, ...] | None, key: str = xml_keys.XML_XF_XAOS) -> tuple[list[str] | list[Never], ...] | None:
* __get_affine(self, xforms: tuple[dict, ...] | None, key: str, type: int = 0) -> tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None:
* __get_keyvalue(self, xforms: tuple[dict, ...] | None, key: str, msg: bool = True) -> tuple[float | str, ...] | None:
* __get_palette(self, idx: int, key: str = xml_keys.XML_PALETTE) -> tuple[hou.Ramp, int, str] | None:
* __get_palette_flam3h_hsv(self, idx: int) -> TA_TypeMaker | bool:
* __get_mb_flam3h_mb(self, idx: int, key: str = '') -> int | float | bool | None:
* __get_cp_flam3h_samples(self, idx: int, palette: tuple[hou.Ramp, int, str] | None = None) -> int | bool:
* __get_cp_flam3h_basis(self, idx: int) -> int | bool:
* __get_flam3h_toggle(self, toggle: str | list[Never]) -> int | None:

    Args:
        _xml_tree ([class]): [inherit properties methods from the _xml_tree class]
    """  

    __slots__ = ("_cached_data", 
                 "_node", "_flame", "_flame_count", 
                 "_out_size", "_out_center", "_out_rotate", "_out_scale", "_out_quality", "_out_brightness", "_out_gamma", "_out_highlight_power", "_out_logscale_k2", "_out_vibrancy", 
                 "_out_palette_mode", 
                 "_out_curves", "_out_curve_overall", "_out_curve_red", "_out_curve_green", "_out_curve_blue", 
                 "_flam3h_sys_rip", "_flam3h_hsv", 
                 "_flam3h_mb", "_flam3h_mb_samples", "_flam3h_mb_shutter", "_flam3h_cp_samples", "_flam3h_cp_basis", 
                 "_flam3h_prefs_f3c")

    def __init__(self, node: hou.SopNode, xmlfile: str) -> None:
        """
        Args:
            (self):
            node(hou.SopNode): This FLAM3H™ node
            xmlfile (str): xml *.flame v_type file to load
        """
        super().__init__(xmlfile)
        
        self._node: hou.SopNode = node
        self._flame: tuple[lxmlET._Element, ...] | None = self._xml_tree__get_flame() # type: ignore
        self._flame_count: int = self._xml_tree__get_flame_count(self.flame) # type: ignore
        
        # render properties
        self._out_size: tuple[str | list[Never], ...] = self._xml_tree__get_name_list_str(xml_keys.XML_SIZE) # type: ignore
        self._out_center: tuple[str | list[Never], ...] = self._xml_tree__get_name_list_str(xml_keys.XML_CENTER) # type: ignore
        self._out_rotate: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.XML_ROTATE, '0') # type: ignore
        self._out_scale: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.XML_SCALE, '0') # type: ignore
        self._out_quality: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.XML_QUALITY, '1000') # type: ignore
        self._out_brightness: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.XML_BRIGHTNESS, '3') # type: ignore
        self._out_gamma: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.XML_GAMMA, '2.5') # type: ignore
        self._out_highlight_power: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.XML_POWER, '5') # type: ignore
        self._out_logscale_k2: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.XML_K2, '0') # type: ignore
        self._out_vibrancy: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.XML_VIBRANCY, '0.3333') # type: ignore
        
        # palette lookup samples basis
        self._out_palette_mode: tuple[str | list[Never], ...] = self.get_name(xml_keys.XML_PALETTE_MODE)
        
        # render curves
        self._out_curves: tuple[str | list[Never], ...] = self._xml_tree__get_name_curve_val_str(xml_keys.XML_CC_CURVES, xml_keys.DEFAULT_CC_CURVES) # type: ignore
        self._out_curve_overall: tuple[str | list[Never], ...] = self._xml_tree__get_name_curve_val_str(xml_keys.XML_CC_CURVE_OVERALL, xml_keys.DEFAULT_CC_CURVE) # type: ignore
        self._out_curve_red: tuple[str | list[Never], ...] = self._xml_tree__get_name_curve_val_str(xml_keys.XML_CC_CURVE_RED, xml_keys.DEFAULT_CC_CURVE) # type: ignore
        self._out_curve_green: tuple[str | list[Never], ...] = self._xml_tree__get_name_curve_val_str(xml_keys.XML_CC_CURVE_GREEN, xml_keys.DEFAULT_CC_CURVE) # type: ignore
        self._out_curve_blue: tuple[str | list[Never], ...] = self._xml_tree__get_name_curve_val_str(xml_keys.XML_CC_CURVE_BLUE, xml_keys.DEFAULT_CC_CURVE) # type: ignore

        # custom to FLAM3H™ only
        self._flam3h_sys_rip: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.f3h.XML_RIP) # type: ignore # This xml key must be present to be set otherwise leave it untouched
        self._flam3h_hsv: tuple[str | list[Never], ...] = self._xml_tree__get_name_list_str(xml_keys.f3h.XML_HSV) # type: ignore
        
        # just check any of the MB val and if exist mean there is MB data to be set.
        # this will act as bool and if true, it will hold our xml_keys.f3h.XML_MB_FPS value ( as string )
        self._flam3h_mb: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.f3h.XML_MB_FPS) # type: ignore # This xml key must be present to be set otherwise leave it untouched
        self._flam3h_mb_samples: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.f3h.XML_MB_SAMPLES, '16') # type: ignore
        self._flam3h_mb_shutter: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.f3h.XML_MB_SHUTTER, '0.5') # type: ignore
        self._flam3h_cp_samples: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.f3h.XML_CP_SAMPLES, '256') # type: ignore
        self._flam3h_cp_basis: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.f3h.XML_CP_SAMPLES_BASIS, '0') # type: ignore

        self._flam3h_prefs_f3c: tuple[str | list[Never], ...] = self._xml_tree__get_name_val_str(xml_keys.f3h.XML_F3C) # type: ignore # This xml key must be present to be set otherwise leave it untouched
        

    @staticmethod
    def xf_val_cleanup_split_str(val: str, default_val: str = '0', key_name: str | None = None) -> str:
        """ Try to eliminate any invalid characters from the value that was given.</br>
        This is especially relevant to the XML curve data.</br>
        Each knot's value will be divided, and it will check to see if the result is a valid float and for invalid characters.</br>
        If not, it will automatically return a string of "0."</br></br>

        Ultimately, it will re-join all for the output.</br>
        
        Args:
            val(str): value from the xml
            default_val(str): Default to: '0'</br>If something goes wrong use this as the returned value.
            key_name(str | None): Default to: None</br>If not None, it will print out the key_name if not a value.

        Returns:
            (str): value cleaned up from invalid characters
        """  
        new: list[str] = []
        knots: list[str] = val.strip().split(' ')
        for idx, k in enumerate(knots):
            
            try:
                float(k)
                
            except ValueError:
                clean: list[str] = [letter for letter in k if letter in f3h_char.ALLOWED_XFORM_VAL]
                
                new_val: str = ''.join(clean)
                try:
                    float(new_val)
                    
                except ValueError:
                    new.append(default_val)
                    if key_name is not None: print(f"Warning:\nIN xml key: {key_name}[{idx}] -> NOT A VALUE\n")
                    
                else:
                    new.append(new_val)
                    if key_name is not None: print(f"Warning:\nIN xml key: {key_name}[{idx}] -> NOT A VALUE (Corrected)\n")
            else:
                new.append(k)
                
        return ' '.join(new)


    @staticmethod
    def xf_val_cleanup_str(val: str, default_val: str = '0', key_name: str | None = None) -> str:
        """ Try to eliminate characters that are not allowed in the passed value.</br>
        
        Args:
            val(str): value from the xml
            default_val(str): Default to: '0'</br>If something goes wrong use this as the returned value.
            key_name(str | None): Default to: None</br>If not None, it will print out the key_name if not a value.</br>Specifically added for:</br>in_flame_utils.in_v_parametric_var_collect(...) </br>but it ended up being used in other places as well.

        Returns:
            (str): value cleaned up from invalid characters
        """  
        try:
            float(val)
            
        except ValueError:
            clean: list[str] = [letter for letter in val if letter in f3h_char.ALLOWED_XFORM_VAL]
            new_val: str = ''.join(clean)
            
            try:
                float(new_val)
                
            except ValueError:
                if key_name is not None: print(f"Warning:\nIN xml key: {key_name} -> NOT A VALUE\n")
                
                return default_val
            
            else:
                if key_name is not None: print(f"Warning:\nIN xml key: {key_name} -> NOT A VALUE (Corrected)\n")
                
                return new_val
            
        else:
            return val


    @staticmethod
    def xf_list_cleanup(vals: list[str], default_val: str = '0', key_name: str | None = None) -> list[str]:
        """ Return a list after attempting to eliminate invalid characters from the provided list values.</br>
        
        Args:
            vals(list[str]): values from the xml
            default_val(str): Default to: '0'</br>If something goes wrong use this as the returned value.
            key_name(str | None): Default to: None</br>If not None</br>it will print out the key_name if not a value.

        Returns:
            (list[str]): a list of affine values cleaned up from invalid characters
        """  
        new: list[str] = []
        if not vals and key_name is not None:
            _d: str | None = XML_TO_F3H_LIST_DEFAULT_VALS.get(key_name)
            if _d is not None: vals = str(_d).split()
            
        _new_append: Callable[[str], None] = new.append
        for idx, val in enumerate(vals):
            
            try:
                float(val)
                
            except ValueError:
                clean: list = [letter for letter in val if letter in f3h_char.ALLOWED_XFORM_VAL]
                
                new_val: str = ''.join(clean)
                try:
                    float(new_val)
                    
                except ValueError:
                    _new_append(default_val)
                    if key_name is not None: print(f"Warning:\nIN xml key: {key_name}[{idx}] -> NOT A VALUE\n")
                    
                else:
                    _new_append(new_val)
                    if key_name is not None: print(f"Warning:\nIN xml key: {key_name}[{idx}] -> NOT A VALUE (Corrected)\n")
            else:
                _new_append(val)
                
        return new
    
    
    @staticmethod
    def xf_list_cleanup_str(vals: list[str], default_val: str = '0', key_name: str | None = None) -> str:
        """ Return a spaced joined string of the list after attempting to eliminate any incorrect characters from the list values.</br>
        
        Args:
            vals(list[str]): values from the xml
            default_val(str): Default to: '0'</br>If something goesw wrong use this as the returned value.
            key_name(str | None): Default to: None</br>If not None</br>it will print out the key_name if not a value.

        Returns:
            (str): a string of spaced joined affine values cleaned up from invalid characters
        """  
        new: list[str] = []
        if not vals and key_name is not None:
            new_vals: str | None = XML_TO_F3H_LIST_DEFAULT_VALS.get(key_name)
            if new_vals is not None: vals = str(new_vals).split(' ')
            
        _new_append: Callable[[str], None] = new.append
        for idx, val in enumerate(vals):
            
            try:
                float(val)
                
            except ValueError:
                clean: list = [letter for letter in val if letter in f3h_char.ALLOWED_XFORM_VAL]
                new_val = ''.join(clean)
                
                try:
                    float(new_val)
                    
                except ValueError:
                    _new_append(default_val)
                    if key_name is not None: print(f"Warning:\nIN xml key: {key_name}[{idx}] -> NOT A VALUE\n")
                    
                else:
                    _new_append(new_val)
                    if key_name is not None: print(f"Warning:\nIN xml key: {key_name}[{idx}] -> NOT A VALUE (Corrected)\n")
                    
            else:
                _new_append(val)
                    
        return ' '.join(new)


    @staticmethod
    def affine_coupling(affine: list[float], key: str = '', mp_idx: int | None = None, type: int = 0) -> list[hou.Vector2] | list[Never]:
        """ Build proper affine values composed of hou.Vector2 tuples.</br>
        It will also check the affine passed in and provide an alternative defaults affine values</br>
        if not correct and print out messages to inform the user about different cases.</br></br>
        
        Note:
            This will need some work at some point.</br>
        
        Args:
            affine(list[float]): values from the xml
            key(str): Default to: ''</br>The type of affine to build: xml_keys.XML_PRE_AFFINE, xml_keys.XML_POST_AFFINE, xml_keys.f3h.XML_PRE_AFFINE, xml_keys.f3h.XML_POST_AFFINE
            mp_idx(int | None): Default to: None</br>Multi parameter index, for messaging purpose only.
            type(int): Default to: 0(Zero)</br>It is either an iterator: 0 or an FF: 1

        Returns:
            (list[hou.Vector2]): a list of hou.Vector2: ((X.x, X.y), (Y.x, Y.y), (O.x, O.y)) / ((A, D), (B, E), (C, F)) ready to be used to set affine parms, or an empty list if something is wrong
        """      
        affine_count: int = len(affine)
        if affine_count == 6:
            return [hou.Vector2((tuple(affine[i:i + 2]))) for i in (0, 2, 4)]
        
        print(datetime.now().strftime('%b-%d-%Y %H:%M:%S'))
        
        sel: dict[str, str] = {xml_keys.XML_PRE_AFFINE: f"Pre affine", xml_keys.XML_POST_AFFINE: f"Post affine", xml_keys.f3h.XML_PRE_AFFINE: f"F3H Pre affine", xml_keys.f3h.XML_POST_AFFINE: f"F3H Post affine"}
        sel_key: str | None = sel.get(key)
        
        # Is it an iterator or an FF or None ?
        iter_type: int | str | None = None
        if mp_idx is not None:
            
            match type:
                
                case 0:
                    iter_type = mp_idx
                    
                case 1:
                    iter_type = 'FF'
                    
                case _:
                    iter_type = None
        
        if key in [xml_keys.XML_PRE_AFFINE, xml_keys.XML_POST_AFFINE]:
            if affine_count == 0:
                if iter_type is not None:
                    _MSG: str = f"\t{sel_key} on iterator.{iter_type}, have no affine values. Expeted are: 6\n\t:Reverted back to default affine values."
                
                else:
                    _MSG: str = f"\t{sel_key} have {affine_count} values. Expeted are: 6\n\t:Reverted back to default affine values."
                
                print(f"{_MSG}\n")
                
                return [hou.Vector2((tuple( f3h_affineDefaults.DEFAULT_IDENT[i:i + 2] ))) for i in (0, 2, 4)]
            
            if iter_type is not None:
                _MSG: str = f"\t{sel_key} on iterator.{iter_type}, have {affine_count} values. Expeted are: 6\n\t:Using 0.0(Zeros) for missing affine values."
            
            else:
                _MSG: str = f"\t{sel_key} have {affine_count} values. Expeted are: 6\n\t:Using 0.0(Zeros) for missing affine values."
            
            print(f"{_MSG}\n")
            
            return [hou.Vector2((tuple( np_pad(affine, (0, 6-min(6, affine_count)), 'constant', constant_values = 0).tolist()[i:i + 2] ))) for i in (0, 2, 4)]
        
        if sel_key is not None:
            if iter_type is not None:
                _MSG: str = f"\t{sel_key} on iterator.{iter_type}, have {affine_count} values. Expeted are: 6\n\t:Skipped"
                print(f"{_MSG}\n")
                
            else:
                _MSG: str = f"\t{sel_key} have {affine_count} values. Expeted are: 6\n\t:Skipped"
                print(f"{_MSG}\n")
                
        return []
    
    
    @staticmethod
    def check_all_iterator_weights(node: hou.SopNode, keyvalues: list) -> None:
        """ If all iterators have their weights set to: 0.0(ZERO), let the user know.</br>
        
        Args:
            node(hou.SopNode): Current FLAM3H™ node we are loading a Flame preset from.
            kevalues(list): list of all iterators key values, in this case all iterator's weights values.

        Returns:
           (None):
        """   
        if min(keyvalues) == max(keyvalues) == 0:
            # Since this case is now being addressed directly in the CVEX code,
            # it is not necessary anymore to revert the value to a non-zero value anymore, but I leave the message here for the user to know anyway.
            # min_weight = 0.00000001
            # keyvalues[0] = min_weight
            _MSG: str = f"Warning:\n{node.name()}:\nThe loaded Flame preset have all iterators Weight set to: 0.0(Zero).\n"
            print(f"{_MSG}")
    
    
    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @property
    def node(self) -> hou.SopNode:
        return self._node
    
    # @property # This is now stored from inside: class _xml_tree:
    # def name(self):
    #     return self._name

    @cached_slot_property
    def flame(self) -> tuple[lxmlET._Element, ...] | None:
        return self._flame

    @cached_slot_property
    def flame_count(self) -> int:
        return self._flame_count
    
    @cached_slot_property
    def out_size(self) -> tuple[str | list[Never], ...]:
        return self._out_size
    
    @cached_slot_property
    def out_center(self) -> tuple[str | list[Never], ...]:
        return self._out_center
    
    @cached_slot_property
    def out_rotate(self) -> tuple[str | list[Never], ...]:
        return self._out_rotate
    
    @cached_slot_property
    def out_scale(self) -> tuple[str | list[Never], ...]:
        return self._out_scale
    
    @cached_slot_property
    def out_quality(self) -> tuple[str | list[Never], ...]:
        return self._out_quality

    @cached_slot_property
    def out_brightness(self) -> tuple[str | list[Never], ...]:
        return self._out_brightness
    
    @cached_slot_property
    def out_gamma(self) -> tuple[str | list[Never], ...]:
        return self._out_gamma
    
    @cached_slot_property
    def out_highlight_power(self) -> tuple[str | list[Never], ...]:
        return self._out_highlight_power
    
    @cached_slot_property
    def out_logscale_k2(self) -> tuple[str | list[Never], ...]:
        return self._out_logscale_k2
    
    @cached_slot_property
    def out_vibrancy(self) -> tuple[str | list[Never], ...]:
        return self._out_vibrancy
    
    @cached_slot_property
    def out_palette_mode(self) -> tuple[str | list[Never], ...]:
        return self._out_palette_mode
    
    # render curves
    
    @cached_slot_property
    def out_curves(self) -> tuple[str | list[Never], ...]:
        return self._out_curves
    
    @cached_slot_property
    def out_curve_overall(self) -> tuple[str | list[Never], ...]:
        return self._out_curve_overall
    
    @cached_slot_property
    def out_curve_red(self) -> tuple[str | list[Never], ...]:
        return self._out_curve_red
    
    @cached_slot_property
    def out_curve_green(self) -> tuple[str | list[Never], ...]:
        return self._out_curve_green
    
    @cached_slot_property
    def out_curve_blue(self) -> tuple[str | list[Never], ...]:
        return self._out_curve_blue
    
    # custom to FLAM3H™ only
    
    @cached_slot_property
    def flame3h_sys_rip(self) -> tuple[str | list[Never], ...]:
        return self._flam3h_sys_rip

    @cached_slot_property
    def flam3h_hsv(self) -> tuple[str | list[Never], ...]:
        return self._flam3h_hsv
    
    @cached_slot_property
    def flam3h_mb(self) -> tuple[str | list[Never], ...]: # motion blur fps ( frames per second )
        return self._flam3h_mb
    
    @cached_slot_property
    def flam3h_mb_samples(self) -> tuple[str | list[Never], ...]:
        return self._flam3h_mb_samples
    
    @cached_slot_property
    def flam3h_mb_shutter(self) -> tuple[str | list[Never], ...]:
        return self._flam3h_mb_shutter
    
    @cached_slot_property
    def flam3h_cp_samples(self) -> tuple[str | list[Never], ...]:
        return self._flam3h_cp_samples
    
    @cached_slot_property
    def flam3h_cp_basis(self) -> tuple[str | list[Never], ...]:
        return self._flam3h_cp_basis
    
    @cached_slot_property
    def flam3h_prefs_f3c(self) -> tuple[str | list[Never], ...]: # flam3 compatibility preferences option
        return self._flam3h_prefs_f3c
    

    def __is_valid_idx(self, idx: int) -> int:
        """ Make sure the fractal flame's idx passed in will always be valid and never out of range.</br>

        Args:
            (self):
            idx(int): flame idx out of all flames included in the loaded flame file

        Returns:
            (int): clamped idx value just in case the user pass an invalid idx to this function
        """     
        return 0 if idx < 0 else 0 if {fc := self.flame_count} == 1 else fc-1 if idx > fc-1 else idx


    def __get_xforms(self, idx: int, key: str) -> tuple[dict, ...] | None:
        """ Get choosen fractal flame's xforms collected inside a dict each.</br>
        Every xform in xforms is a dict coming directly from the parsed XML file.</br>

        Args:
            (self):
            idx(int): flame idx out of all flames included in the loaded flame file
            key(str): use "xform" for transforms and "finalxform" for final flame transform

        Returns:
            (tuple[dict, ...] | None): a tuple of all xforms inside the selected flame or None
        """
        if  self.isvalidtree:
            assert self.flame is not None
            xforms: list = [xf.attrib for xf in self.flame[idx].iter(key)]
            if xforms:
                _lower: Callable[[str], str] = str.lower
                return tuple(dict(zip([_lower(x) for x in xf.keys()], xf.values())) for xf in xforms)
                
                # xforms_lower = []
                # for xf in xforms:
                #     k = [str(x).lower() for x in xf.keys()]
                #     kv = zip(k, xf.values())
                #     xforms_lower.append(dict(kv))
                
            return None
            
        return None
    
    
    def __get_xaos(self, xforms: tuple[dict, ...] | None, key: str = xml_keys.XML_XF_XAOS) -> tuple[list[str] | list[Never], ...] | None:
        """
        Args:
            (self):
            xforms(tuple[dict, ...] | None): list of all xforms contained inside this flame
            key(str): Default to: xml_keys.XML_XF_XAOS</br>Rhe flame XML xaos tag name.

        Returns:
            (tuple[list[str] | list[Never], ...] | None): either a list of xaos strings</br>or an empty list instead if the XML key is not found in the XML preset. Or None
        """
        if  self.isvalidtree and xforms is not None:
            _join: Callable[[Iterable[str]], str] = ':'.join
            _xf_list_cleanup: Callable[[list[str], str, str | None], list[str]] = self.xf_list_cleanup
            xaos: list = [f"xaos:{_join(_xf_list_cleanup(str(keyval).split(), '1', key))}" if (keyval := xf.get(key)) is not None else [] for xf in xforms]

            _len: Callable[[list[Any]], int] = len
            if not max(list(map(lambda x: _len(x), xaos))):
                return None
            
            return tuple(xaos)
        
        return None


    def __get_affine(self, xforms: tuple[dict, ...] | None, key: str, type: int = 0) -> tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None:
        """
        Args:
            (self):
            xforms(tuple[dict, ...] | None): list of all xforms contained inside this flame
            key(str): affine xml tag name. Either 'coefs' for pre affine or 'post' for post affine
            type(int): Default to: 0(Zero)</br>Only used by the self.affine_coupling(...) definition.</br>It is either an iterator: 0 or an FF: 1

        Returns:
            (tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None): Either a list of list of tuples of hou.Vector2 ((X.x, X.y), (Y.x, Y.y), (O.x, O.y)) / ((A, D), (B, E), (C, F))</br>or an empty list instead if the XML key is not found in the XML preset. Or None
        """   
        if  self.isvalidtree and xforms is not None:
            _affine_coupling: Callable[[list[float], str, int | None, int], list[hou.Vector2] | list[Never]] = self.affine_coupling
            _xf_list_cleanup: Callable[[list[str], str, str | None], list[str]] = self.xf_list_cleanup
            coefs: list = [tuple(_affine_coupling([float(x) for x in _xf_list_cleanup(str(keyval).split(), '0', key)], key, int(idx + 1), type)) if (keyval := xf.get(key)) is not None else [] for idx, xf in enumerate(xforms)]
            
            _len: Callable[[list[Any]], int] = len
            if max(list(map(lambda x: _len(x), coefs))):
                return tuple(coefs)
            
            return None
            
        return None


    def __get_keyvalue(self, xforms: tuple[dict, ...] | None, key: str, msg: bool = True) -> tuple[str | float | list[Never], ...] | None:
        """
        Args:
            (self):
            xforms(tuple[dict, ...] | None): list of all xforms contained inside this Flame or None if something went wrong.
            key(str): xml tag names. For shader: 'color', 'symmetry'->(color_speed), 'opacity'
            msg(bool): Default to True</br> Set it to False to not print a message.

        Returns:
            (tuple[str | float | list[Never], ...] | None): description
        """
        if self.isvalidtree and xforms is not None:
            
            vars_keys_pre: list | None = None
            if key == xml_keys.XML_XF_PB: vars_keys_pre = in_flame_utils.in_get_xforms_var_keys(xforms, in_flame_utils.in_util_make_PRE(VARS_FLAM3_DICT_IDX.keys()), XML_XF_KEY_EXCLUDE)
            
            keyvalues: list[str | float | list[Never]] = []
            for idx, xform in enumerate(xforms):
                
                if xform.get(key) is not None:

                    if key in xml_keys.XML_XF_NAME:
                        keyvalues.append(str(xform.get(key)).strip())
                        continue
                    
                    else:
                        if key in xml_keys.XML_XF_OPACITY:
                            default_val: str | None = XML_TO_F3H_DEFAULT_VALS.get(xml_keys.XML_XF_OPACITY) # This way I keep this dict for all default values purposes
                            if default_val is None: default_val = '0'
                        
                        else:
                            default_val: str | None = '0'
                        
                        assert default_val is not None
                        keyvalues.append(float(self.xf_val_cleanup_str(xform.get(key, '0'), default_val, key)))
                        continue
                    
                else:
                    # Fractorium used to remap "pre_blur" to "pre_gaussian_blur" when you loaded a Flame in and it seem to be fixed in the latest version.
                    # However, if a Flame xform uses a "pre_gaussian_blur" as the first in the list 
                    # mean that every time you save the Flame from Fractorium and load it back in FLAM3H™ you loose a PRE variation's slot.
                    #
                    # Lets remap "pre_gaussian_blur" back to "pre_blur" when we load a flame back in FLAM3H™ if it is the first one in the list.
                    
                    # I could hard-code the name into the function: def in_vars_keys_remove_pgb(...), but this way I keep this dict global for all purposes.
                    pgb_name: str | list[str] | None = in_flame_utils.in_util_make_PRE(in_flame_utils.in_get_dict_key_from_value(VARS_FLAM3_DICT_IDX, 33))
                    pgb_val: str | None = xform.get(pgb_name)
                    if pgb_val is not None and vars_keys_pre is not None: # This double check because also other keys not related to "pre_blur" can fall into this block otherwise
                        if vars_keys_pre[idx] and pgb_name in vars_keys_pre[idx][0]:
                            keyvalues.append(float(self.xf_val_cleanup_str(pgb_val, '0', str(pgb_name))))
                            
                        else:
                            keyvalues.append([])

                        continue
                    
                    else:
                        default_val: str | None = XML_TO_F3H_DEFAULT_VALS.get(key)
                        if default_val is not None:
                            keyvalues.append(float(default_val))
                            if msg: print(f"Warning: iterator.{idx+1}\nIN xml key: {key} -> NOT FOUND, default value used.\n")
                            
                        else:
                            keyvalues.append([])
                            
                        continue
            
            # CHECKS
            if key in xml_keys.XML_XF_WEIGHT:
                # Let the user know
                in_flame.check_all_iterator_weights(self.node, keyvalues)
                
            return tuple(keyvalues)
        
        
        return None

        
    def __get_palette(self, idx: int, key: str = xml_keys.XML_PALETTE) -> tuple[hou.Ramp, int, str] | None:
        """
        Args:
            (self):
            idx(int): flame idx out of all flames included in the loaded flame file
            key(str): Default to: xml_keys.XML_PALETTE</br>The flame XML palette tag name

        Returns:
            (tuple[hou.Ramp, int, str] | None): return a tu-ple with an already made hou.Ramp, number of keys, format or None if something went wrong.
        """     
        
        if self.isvalidtree:
            assert self.flame is not None
            palette_attrib: dict | None = self.flame[idx].find(key).attrib
            
            if palette_attrib is not None:
                
                # _HEX = []
                # for line in palette_hex.splitlines():
                #     cleandoc = i_cleandoc(line)
                #     if(len(cleandoc) > 1):
                #         [_HEX.append(hex) for hex in wrap(cleandoc, 6)]
                
                palette_hex: str = self.flame[idx].find(key).text
                all_lines: list[str] = [line.replace(" ", "") for line in palette_hex.splitlines()]
                _len: Callable[[str], int] = len
                HEXs: list[str] = [h for line in all_lines if (clean := i_cleandoc(line)) and _len(clean) > 1 for h in wrap(clean, 6)]
                
                try:
                    _hex_to_rgb: Callable[[str], tuple] = flam3h_palette_utils.hex_to_rgb
                    RGBs: list[list[int]] = [list(map(abs, _hex_to_rgb(hex))) for hex in HEXs]
                    
                except ValueError as e:
                    F3H_Exception.F3H_traceback_print_infos(e, extra_info='Invalid hex values in the loaded Flame palette.')
                    return None
                
                else:
                    
                    if RGBs:
                        
                        # Convert to NumPy array and normalize
                        RGBs_array: NDArray[np_float32] = np_array(RGBs[:len(HEXs)], dtype=np_float32)
                        rgb_from_XML_PALETTE: list[list[float]] = (RGBs_array / 255.0).tolist()
                        format: str | None = dict(palette_attrib).get(xml_keys.XML_PALETTE_FORMAT)
                        ramp_keys_count: int = len(rgb_from_XML_PALETTE)
                        POSs: list[int | float] = list(it_islice(it_count(0, 1.0/(ramp_keys_count-1)), (ramp_keys_count)))
                        BASESs: list = [hou.rampBasis.Linear] * (ramp_keys_count) # type: ignore
                        
                        return hou.Ramp(BASESs, POSs, rgb_from_XML_PALETTE), ramp_keys_count, str(format)
                    
                    else:
                        return None

            return None
        
        return None
    
    
    # custom to FLAM3H™ only
    def __get_palette_flam3h_hsv(self, idx: int) -> TA_TypeMaker | bool:
        """
        Args:
            (self):
            idx(int): flame idx out of all flames included in the loaded flame file

        Returns:
            (TA_TypeMaker | bool): [a hou.Vector type of HSV vals or False] Since we know the HSV is made out of 3 floats, it will always rreturn a: hou.Vector3
        """   
        if self.isvalidtree:
            palette_hsv_xml_list: str | list[Never] = self.flam3h_hsv[idx]
            if isinstance(palette_hsv_xml_list, str):
                palette_hsv_xml_s: list[str] = palette_hsv_xml_list.split()
                if len(palette_hsv_xml_s) != 3:
                    palette_hsv_xml_s: list[str] = np_pad(palette_hsv_xml_s, (0, 3-min(3, len(palette_hsv_xml_s))), 'constant', constant_values = 1).tolist()
                
                return in_flame_utils.in_util_typemaker(list(map(lambda x: float(x), palette_hsv_xml_s )))
            
            return False
        
        return False
    
    
    # custom to FLAM3H™ only
    def __get_mb_flam3h_mb(self, idx: int, key: str = '') -> int | float | bool:
        """
        Args:
            (self):
            idx(int): flame idx out of all flames included in the loaded flame file
            key(str): Default to: ''</br>The flame XML motion blur tag name you are interested to get:
            * xml_keys.f3h.XML_MB_FPS -> flam3h_mb_fps
            * xml_keys.f3h.XML_MB_SAMPLES -> flam3h_mb_samples
            * xml_keys.f3h.XML_MB_SHUTTER -> flam3h_mb_shutter

        Returns:
            (int | float | bool | None): FLAM3H™ motion blur parameter's values.
        """   
        if self.isvalidtree:
            mb_do: str | list = self.flam3h_mb[idx]
            if isinstance(mb_do, str):
                if key == xml_keys.f3h.XML_MB_FPS:
                    
                    try:
                        return int(mb_do)
                    
                    except ValueError:
                        return False

                elif key == xml_keys.f3h.XML_MB_SAMPLES:
                    mp_samples: str | list = self.flam3h_mb_samples[idx]
                    if isinstance(mp_samples, list):
                        print(f"Warning:\nIN xml key: {xml_keys.f3h.XML_MB_SAMPLES} -> NOT FOUND, default value used.\n")
                        return int(16) # default
                    
                    return int(mp_samples)
                    
                elif key == xml_keys.f3h.XML_MB_SHUTTER:
                    mb_shutter: str | list = self.flam3h_mb_shutter[idx]
                    if isinstance(mb_shutter, list):
                        print(f"Warning:\nIN xml key: {xml_keys.f3h.XML_MB_SHUTTER} -> NOT FOUND, default value used.\n")
                        return float(0.5) # default
                    
                    return float(mb_shutter)
                
                return False
            
            return False
        
        return False
        
        
    # custom to FLAM3H™ only
    def __get_cp_flam3h_samples(self, idx: int, palette: tuple[hou.Ramp, int, str] | None = None) -> int | bool:
        """
        Args:
            self:
            idx(int): flame idx out of all flames included in the loaded flame file
            palette(tuple[hou.Ramp, int, str]): Default to None</br>The loaded Flame palette data if any[palette hou ramp parm, colors count, format]</br>otherwise: None

        Returns:
            (int | bool): FLAM3H™ palette lookup samples parameter values.
        """   
        if self.isvalidtree:
            cp_samples_key: str | list[Never] = self.flam3h_cp_samples[idx]
            if isinstance(cp_samples_key, str):
                
                samples: int = int(cp_samples_key)
                if samples in f3h_tabs.CP.DEFAULT_MENU_OPTIONS_PLUS: # just make sure the lookup samples count is one of the valid options.
                    return samples
                
                # else return the default value
                return 256
            
            if palette is not None:
                
                count: int = palette[1]
                if count > 0:
                    return int(flam3h_palette_utils.find_nearest_idx(f3h_tabs.CP.DEFAULT_MENU_OPTIONS_PLUS, count))
                # else return the default value
                return 256
            
            # else return the default value
            return 256
        
        return False
        
        
    # custom to FLAM3H™ only
    def __get_cp_flam3h_basis(self, idx: int) -> int | bool:
        """Get FLAM3H™ palette lookup samples interpolation basis ( from 0 to 5)</br>
        Check the XML key: palette_mode first on Flame Load, and decide the one to use based on each other value.</br>
        
        Args:
            self:
            idx(int): flame idx out of all flames included in the loaded flame file

        Returns:
            (int): FLAM3H™ palette basis parameter values.
        """  
        if self.isvalidtree:
            
            # Fractorium palette_mode
            palette_mode_key = self.out_palette_mode[idx]
            mode: int | bool = False
            if palette_mode_key and isinstance(palette_mode_key, str):
                
                match palette_mode_key.lower():
                    
                    case 'linear':
                        mode = 0
                        
                    case 'step':
                        mode = 1
                        
                    case _:
                        pass # Currently, Fractorium has 2(two) modes: 'linear' and 'step', anything else will be ignored
                    
            # FLAM3H™ cp_basis
            cp_basis_key: str | list[Never] = self.flam3h_cp_basis[idx]
            if cp_basis_key and isinstance(cp_basis_key, str):
                
                basis: int = int(cp_basis_key)
                if basis > 5:
                    return 0 # there are 6(six) different bases, anything above (for whatever reasons) will fallback to linear(0)
                
                return basis
                
            else:
                if mode is not False:
                    return mode
                
                return 0 # if key is missing, always return linear(0)
            
        return False
            
    
    # custom to FLAM3H™ only
    def __get_flam3h_toggle(self, toggle: str | list[Never]) -> int | None:
        """Get FLAM3H™ toggle parameter value: ON or OFF ( 1 or 0 )</br>

        Args:
            toggle(str | list[Never]): Get value from a toggle (Either ON or OFF - '1' or '0')

        Returns:
            (int | None): This flame toggle or None if not found
        """

        if self.isvalidtree:
            # f3c = self._flam3h_prefs_f3c[idx]
            # self._flam3h_prefs_f3c[idx] can also be an empty list
            if isinstance(toggle, str):
                
                try:
                    return int(toggle)
                
                except ValueError:
                    return None

            return None
        
        return None


# FLAM3H™ IN FLAME ITER DATA start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class in_flame_iter_data(in_flame):
    """
    Args:
        in_flame ([class]): [inherit properties methods from the in_flame class]
    """  
    
    __slots__ = ("_cached_data", 
                 "_idx", "_xforms", "_xf_name", "_weight", "_pre_blur", "_xaos", 
                 "_coefs", "_f3h_coefs", "_f3h_coefs_angle", "_post", "_f3h_post", "_f3h_post_angle", 
                 "_finalxform", "_finalxform_coefs", "_finalxform_f3h_coefs", "_finalxform_f3h_coefs_angle", "_finalxform_post", "_finalxform_f3h_post", "_finalxform_f3h_post_angle", "_finalxform_name", 
                 "_palette", "_color", "_color_speed", "_symmetry", "_opacity", 
                 "_sys_flam3h_rip", "_cp_flam3h_hsv", "_mb_flam3h_mb_fps", "_mb_flam3h_mb_samples", "_mb_flam3h_mb_shutter", "_cp_flam3h_cp_samples", "_cp_flam3h_cp_basis", "_prefs_flam3h_f3c")
    
    def __init__(self, node: hou.SopNode, xmlfile: str, idx: int=0) -> None:
        """
        Args:
            (self):
            node(hou.SopNode): This FLAM3H™ node.
            xmlfile (str): xmlfile (str): xml flame v_type file to load
            idx (int, optional): Default to: 0(Zero)</br>Flame idx out of all flames included in the loaded flame file.
        """
        super().__init__(node, xmlfile)
        
        self._idx: int = self._in_flame__is_valid_idx(idx) # type: ignore
        self._xforms: tuple[dict, ...] | None = self._in_flame__get_xforms(self.idx, xml_keys.XML_XF) # type: ignore
        self._xf_name: tuple[str, ...] | None = self._in_flame__get_keyvalue(self.xforms, xml_keys.XML_XF_NAME) # type: ignore
        self._weight: tuple[float, ...] | None = self._in_flame__get_keyvalue(self.xforms, xml_keys.XML_XF_WEIGHT) # type: ignore
        self._pre_blur: tuple[float, ...] | None = self._in_flame__get_keyvalue(self.xforms, xml_keys.XML_XF_PB) # type: ignore
        self._xaos: tuple[list[str] | list[Never], ...] | None  = self._in_flame__get_xaos(self.xforms) # type: ignore
        
        self._coefs: tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None = self._in_flame__get_affine(self.xforms, xml_keys.XML_PRE_AFFINE) # type: ignore
        self._f3h_coefs: tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None = self._in_flame__get_affine(self.xforms, xml_keys.f3h.XML_PRE_AFFINE) # type: ignore
        self._f3h_coefs_angle: tuple[float, ...] | None = self._in_flame__get_keyvalue(self.xforms, xml_keys.f3h.XML_PRE_AFFINE_ANGLE) # type: ignore
        self._post: tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None  = self._in_flame__get_affine(self.xforms, xml_keys.XML_POST_AFFINE) # type: ignore
        self._f3h_post: tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None  = self._in_flame__get_affine(self.xforms, xml_keys.f3h.XML_POST_AFFINE) # type: ignore
        self._f3h_post_angle: tuple[float, ...] | None = self._in_flame__get_keyvalue(self.xforms, xml_keys.f3h.XML_POST_AFFINE_ANGLE) # type: ignore
        
        self._finalxform: tuple[dict, ...] | None = self._in_flame__get_xforms(self.idx, xml_keys.XML_FF) # type: ignore
        self._finalxform_coefs: tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None = self._in_flame__get_affine(self.finalxform, xml_keys.XML_PRE_AFFINE, 1) # type: ignore
        self._finalxform_f3h_coefs: tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None = self._in_flame__get_affine(self.finalxform, xml_keys.f3h.XML_PRE_AFFINE, 1) # type: ignore
        self._finalxform_f3h_coefs_angle: tuple[float, ...] | None = self._in_flame__get_keyvalue(self.finalxform, xml_keys.f3h.XML_PRE_AFFINE_ANGLE) # type: ignore
        self._finalxform_post: tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None  = self._in_flame__get_affine(self.finalxform, xml_keys.XML_POST_AFFINE, 1) # type: ignore
        self._finalxform_f3h_post: tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None = self._in_flame__get_affine(self.finalxform, xml_keys.f3h.XML_POST_AFFINE, 1) # type: ignore
        self._finalxform_f3h_post_angle: tuple[float, ...] | None = self._in_flame__get_keyvalue(self.finalxform, xml_keys.f3h.XML_POST_AFFINE_ANGLE) # type: ignore
        self._finalxform_name: tuple[str, ...] | None = self._in_flame__get_keyvalue(self.finalxform, xml_keys.XML_XF_NAME) # type: ignore
        
        self._palette: tuple[hou.Ramp, int, str] | None = self._in_flame__get_palette(self.idx) # type: ignore
        self._color: tuple[float, ...] | None = self._in_flame__get_keyvalue(self.xforms, xml_keys.XML_XF_COLOR) # type: ignore
        self._color_speed: tuple[float, ...] | None = self._in_flame__get_keyvalue(self.xforms, xml_keys.XML_XF_COLOR_SPEED, False) # type: ignore # Color speed is only used by Fractorium so we silent its warning message when missing
        self._symmetry: tuple[float, ...] | None = self._in_flame__get_keyvalue(self.xforms, xml_keys.XML_XF_SYMMETRY) # type: ignore
        self._opacity: tuple[float, ...] | None = self._in_flame__get_keyvalue(self.xforms, xml_keys.XML_XF_OPACITY) # type: ignore
        
        # custom to FLAM3H™ only
        self._sys_flam3h_rip: int | None = self._in_flame__get_flam3h_toggle(self.flame3h_sys_rip[self.idx]) # type: ignore
        self._cp_flam3h_hsv: TA_TypeMaker | bool = self._in_flame__get_palette_flam3h_hsv(self.idx) # type: ignore
        self._mb_flam3h_mb_fps: int | float | bool = self._in_flame__get_mb_flam3h_mb(self.idx, xml_keys.f3h.XML_MB_FPS) # type: ignore
        self._mb_flam3h_mb_samples: int | float | bool = self._in_flame__get_mb_flam3h_mb(self.idx, xml_keys.f3h.XML_MB_SAMPLES) # type: ignore
        self._mb_flam3h_mb_shutter: int | float | bool = self._in_flame__get_mb_flam3h_mb(self.idx, xml_keys.f3h.XML_MB_SHUTTER) # type: ignore
        self._cp_flam3h_cp_samples: int | bool = self._in_flame__get_cp_flam3h_samples(self.idx, self.palette) # type: ignore
        self._cp_flam3h_cp_basis: int | bool = self._in_flame__get_cp_flam3h_basis(self.idx) # type: ignore
        self._prefs_flam3h_f3c: int | None = self._in_flame__get_flam3h_toggle(self.flam3h_prefs_f3c[self.idx]) # type: ignore


    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @cached_slot_property
    def idx(self) -> int:
        return self._idx

    @cached_slot_property
    def xforms(self) -> tuple[dict, ...] | None:
        return self._xforms
    
    @cached_slot_property
    def xf_name(self) -> tuple[str, ...] | None:
        return self._xf_name
    
    @cached_slot_property
    def weight(self) -> tuple[float, ...] | None:
        return self._weight
    
    @cached_slot_property
    def pre_blur(self) -> tuple[float, ...] | None:
        return self._pre_blur
    
    @cached_slot_property
    def xaos(self) -> tuple[list[str] | list[Never], ...] | None:
        return self._xaos
 
    @cached_slot_property
    def coefs(self) -> tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None:
        return self._coefs
    
    @cached_slot_property
    def f3h_coefs(self) -> tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None:
        return self._f3h_coefs
    
    @cached_slot_property
    def f3h_coefs_angle(self) -> tuple[float, ...] | None:
        return self._f3h_coefs_angle
        
    @cached_slot_property
    def post(self) -> tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None:
        return self._post
    
    @cached_slot_property
    def f3h_post(self) -> tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None:
        return self._f3h_post
    
    @cached_slot_property
    def f3h_post_angle(self) -> tuple[float, ...] | None:
        return self._f3h_post_angle
    
    @cached_slot_property
    def finalxform(self) -> tuple[dict, ...] | None:
        return self._finalxform
    
    @cached_slot_property
    def finalxform_coefs(self) -> tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None:
        return self._finalxform_coefs
    
    @cached_slot_property
    def finalxform_f3h_coefs(self) -> tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None:
        return self._finalxform_f3h_coefs
    
    @cached_slot_property
    def finalxform_f3h_coefs_angle(self) -> tuple[float, ...] | None:
        return self._finalxform_f3h_coefs_angle
        
    @cached_slot_property
    def finalxform_post(self) -> tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None:
        return self._finalxform_post
    
    @cached_slot_property
    def finalxform_f3h_post(self) -> tuple[tuple[hou.Vector2, ...] | list[Never], ...] | None:
        return self._finalxform_f3h_post
    
    @cached_slot_property
    def finalxform_f3h_post_angle(self) -> tuple[float, ...] | None:
        return self._finalxform_f3h_post_angle
    
    @cached_slot_property
    def finalxform_name(self) -> tuple[str, ...] | None:
        return self._finalxform_name
    
    @cached_slot_property
    def palette(self) -> tuple[hou.Ramp, int, str] | None:
        return self._palette
    
    @cached_slot_property
    def color(self) -> tuple[float, ...] | None:
        return self._color
    
    @cached_slot_property
    def color_speed(self) -> tuple[float, ...] | None:
        return self._color_speed
    
    @cached_slot_property
    def symmetry(self) -> tuple[float, ...] | None:
        return self._symmetry
    
    @cached_slot_property
    def opacity(self) -> tuple[float, ...] | None:
        return self._opacity
    
    # custom to FLAM3H™ only
    
    @cached_slot_property
    def sys_flam3h_rip(self) -> int | None:
        return self._sys_flam3h_rip
    
    @cached_slot_property
    def cp_flam3h_hsv(self) -> TA_TypeMaker | bool:
        return self._cp_flam3h_hsv
    
    @cached_slot_property
    def mb_flam3h_fps(self) -> int | float | bool:
        return self._mb_flam3h_mb_fps
    
    @cached_slot_property
    def mb_flam3h_samples(self) -> int | float | bool:
        return self._mb_flam3h_mb_samples
    
    @cached_slot_property
    def mb_flam3h_shutter(self) -> int | float | bool:
        return self._mb_flam3h_mb_shutter
    
    @cached_slot_property
    def cp_flam3h_samples(self) -> int | bool:
        return self._cp_flam3h_cp_samples
    
    @cached_slot_property
    def cp_flam3h_basis(self) -> int | bool:
        return self._cp_flam3h_cp_basis
    
    @cached_slot_property
    def prefs_flam3h_f3c(self) -> int | None:
        return self._prefs_flam3h_f3c
    
    
# FLAM3H™ IN FLAME CHECKS start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class in_flame_checks():
    """
@STATICMETHODS

@METHODS
* __in_flame_pb_chk(self) -> bool:
* __in_flame_opacity_chk(self) -> bool:
* __in_flame_post_chk(self) -> bool:
* __in_flame_xaos_chk(self) -> bool:
* __in_flame_palette_chk(self) -> bool:
* __in_flame_ff_chk(self) -> bool:
* __in_flame_ff_post_chk(self) -> bool:
* __in_flame_f3h_mb_chk(self) -> bool:
        
    """  
    
    __slots__ = ("apo_data", 
                 "_pb_bool", "_opacity_bool", "_post_bool", "_xaos_bool", "_palette_bool", "_ff_bool", "_ff_post_bool", "_f3h_mb_bool")
    
    def __init__(self, apo_data: in_flame_iter_data) -> None:
        """
        Args:
            (self):
            apo_data(in_flame_iter_data): The XML Flame preset data we are loading in FLAM3H™.
        """
        
        self.apo_data = apo_data
        
        self._pb_bool: bool = self.__in_flame_pb_chk()
        self._opacity_bool: bool = self.__in_flame_opacity_chk()
        self._post_bool: bool = self.__in_flame_post_chk()
        self._xaos_bool: bool = self.__in_flame_xaos_chk()
        self._palette_bool: bool = self.__in_flame_palette_chk()
        self._ff_bool: bool = self.__in_flame_ff_chk()
        self._ff_post_bool: bool = self.__in_flame_ff_post_chk()
        self._f3h_mb_bool: bool = self.__in_flame_f3h_mb_chk()
        
        
    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @property
    def pb_bool(self) -> bool:
        return self._pb_bool
    
    @property
    def opacity_bool(self) -> bool:
        return self._opacity_bool
    
    @property
    def post_bool(self) -> bool:
        return self._post_bool
    
    @property
    def xaos_bool(self) -> bool:
        return self._xaos_bool
    
    @property
    def palette_bool(self) -> bool:
        return self._palette_bool
    
    @property
    def ff_bool(self) -> bool:
        return self._ff_bool
    
    @property
    def ff_post_bool(self) -> bool:
        return self._ff_post_bool
    
    @property
    def f3h_mb_bool(self) -> bool:
        return self._f3h_mb_bool
    
    
    def __in_flame_pb_chk(self) -> bool:
        """Check if the loaded Flame preset uses pre_blur.</br>

        Args:
            (self):
            
        Returns:
            (bool): is pre_blur being used in the loaded Flame preset ? True or False
        """  
        pb_bool: bool = False
        if self.apo_data.pre_blur is not None:
            for item in self.apo_data.pre_blur:
                if item:
                    pb_bool = True
                    break
        return pb_bool
    
    
    def __in_flame_opacity_chk(self) -> bool:
        """Check if the loaded Flame preset have any iterator's opacity set to 0(Zero).</br>

        Args:
            (self):
            
        Returns:
            (bool): are there any iterator with 0(Zero) opacity in the loaded Flame preset ? True or False
        """  
        opacity_bool: bool = False
        if self.apo_data.opacity is not None:
            if min(self.apo_data.opacity) == 0.0: opacity_bool = True
        return opacity_bool
    
    
    def __in_flame_post_chk(self) -> bool:
        """Check if the loaded Flame preset have any iterator's post affine On.</br>

        Args:
            (self):
            
        Returns:
            (bool): are there any iterator that use post affine in the loaded Flame preset ? True or False
        """  
        post_bool: bool = False
        if self.apo_data.post is not None: post_bool = True
        return post_bool
    
    
    def __in_flame_xaos_chk(self) -> bool:
        """Check if the loaded Flame preset uses xaos.</br>

        Args:
            (self):
            
        Returns:
            (bool): is xaos being used in the loaded Flame preset ? True or False
        """  
        xaos_bool: bool = False
        if self.apo_data.xaos is not None: xaos_bool = True
        return xaos_bool
    
    
    def __in_flame_palette_chk(self) -> bool:
        """Check if the loaded Flame preset posses a valid palette, or a palette at all.</br>

        Args:
            (self):
            
        Returns:
            (bool): is a valid palette present in the loaded Flame preset ? True or False
        """  
        palette_bool: bool = False
        if self.apo_data.palette is not None: palette_bool = True
        return palette_bool
    
    
    def __in_flame_ff_chk(self) -> bool:
        """Check if the loaded Flame preset uses FF(finalXform).</br>

        Args:
            (self):
            
        Returns:
            (bool): is the FF(finalXform) being used in the loaded Flame preset ? True or False
        """  
        ff_bool: bool = False
        if self.apo_data.finalxform is not None: ff_bool = True
        return ff_bool
    
    
    def __in_flame_ff_post_chk(self) -> bool:
        """Check if the loaded Flame preset FF uses post affine.</br>

        Args:
            (self):
            
        Returns:
            (bool): is the FF(finalXform) if present using its post affine in the loaded Flame preset ? True or False
        """ 
        ff_post_bool: bool = False
        if self.apo_data.finalxform_post is not None: ff_post_bool = True
        return ff_post_bool
    
    
    def __in_flame_f3h_mb_chk(self) -> bool:
        """Check if the loaded Flame preset uses Motion Blur.</br>

        Args:
            (self):
            
        Returns:
            (bool): is the loaded Flame preset using Motion Blur ? True or False
        """  
        f3h_mb_bool: bool = False
        if self.apo_data.mb_flam3h_fps is not False: f3h_mb_bool = True
        return f3h_mb_bool
        
    
# FLAM3H™ IN FLAME UTILS start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class in_flame_utils:
    """
class in_flame_utils

@STATICMETHODS
* in_util_key_name_isalnum(key_name: str) -> str:
* in_util_make_NULL(name: T) -> T:
* in_util_make_VAR(name: TA_TypeVarCollection) -> str | list[str] | None:
* in_util_make_PRE(name: TA_TypeVarCollection) -> str | list[str] | None:
* in_util_make_POST(name: TA_TypeVarCollection) -> str | list[str] | None:
* in_load_stats_unknown_vars(preset_id: int, apo_data: in_flame_iter_data) -> list[str]:
* in_to_flam3h_is_CHAOS(xml: str) -> bool:
* in_to_flam3h_clipboard_is_CHAOS() -> bool:
* in_get_xforms_var_keys( xforms: tuple[dict, ...] | None, 
                        vars: TA_XformVarKeys, 
                        exclude_keys: tuple
                        ) -> TA_STR_ListUnflattened | None:
* in_vars_keys_remove_pgb(vars: list | None, pgb_name: str) -> TA_STR_ListUnflattened | None:             
* in_util_removeprefix(var_name: str, prefix: str) -> str:
* in_get_xforms_var_keys_PP(  xforms: tuple[dict, ...] | None, 
                          vars: dict, 
                          prx: str, 
                          exclude_keys: tuple
                          ) -> TA_STR_ListUnflattened | None:
* in_util_typemaker(data: list[float]) -> TA_TypeMaker:
* in_get_idx_by_key(key: str) -> int | None:
* in_util_flam3h_prx_mode(mode: int) -> tuple[str, str]:
* in_set_affine(mode: int, 
              node: hou.SopNode, 
              prx: str, 
              apo_data: in_flame_iter_data, 
              flam3h_prm_names: flam3h_iterator_prm_names, 
              mp_idx: int
              ) -> None:
* in_set_data(mode: int, 
              node: hou.SopNode, 
              prx: str, 
              apo_data: tuple | list | None, 
              prm_name: str, 
              mp_idx: int
              ) -> None:
* in_prm_name_exceptions(v_type: int, app: str | list[Never], apo_prm: tuple) -> tuple:
* in_get_dict_key_from_value(mydict: dict, idx: int) -> str:
* in_v_parametric_var_collect(node: hou.SopNode, 
                            mode: int, 
                            apo_prm: tuple, 
                            xform: dict, 
                            mp_idx: int, 
                            v_type: int, 
                            func: Callable) -> list[TA_TypeMaker]:
* in_v_parametric(app: str | list[Never], 
                mode: int, 
                node: hou.SopNode, 
                mp_idx: int, 
                t_idx: int, 
                xform: dict, 
                v_type: int, 
                v_weight: float, 
                var_prm: tuple, 
                apo_prm: tuple
                ) -> None:
* in_v_parametric_PRE(app: str | list[Never], 
                    mode: int, 
                    node: hou.SopNode, 
                    mp_idx: int, 
                    t_idx: int, 
                    xform: dict, 
                    v_type: int, 
                    v_weight: float, 
                    var_prm: tuple, 
                    apo_prm: tuple
                    ) -> None:
* in_v_parametric_POST(app: str, 
                     mode: int, 
                     node: hou.SopNode, 
                     mp_idx: int, 
                     t_idx: int, 
                     xform: dict, 
                     v_type: int, 
                     v_weight: float, 
                     var_prm: tuple, 
                     apo_prm: tuple
                     ) -> None:
* in_v_parametric_PRE_FF(app: str | list[Never], 
                       node: hou.SopNode, 
                       t_idx: int, 
                       xform: dict, 
                       v_type: int, 
                       v_weight: float, 
                       var_prm: tuple, 
                       apo_prm: tuple
                       ) -> None:
* in_v_parametric_POST_FF(app: str | list[Never], 
                        node: hou.SopNode, 
                        t_idx: int, 
                        xform: dict, 
                        v_type: int, 
                        v_weight: float, 
                        var_prm: tuple, 
                        apo_prm: tuple
                        ) -> None:
* in_v_generic(mode: int, 
             node: hou.SopNode, 
             mp_idx: int, 
             t_idx: int, 
             v_type: int, 
             v_weight: float
             ) -> None:
* in_v_generic_PRE(mode: int, 
                 node: hou.SopNode, 
                 mp_idx: int, 
                 t_idx: int, 
                 v_type: int, 
                 v_weight: float
                 ) -> None:
* in_v_generic_POST(mode: int, 
                  node: hou.SopNode, 
                  mp_idx: int, 
                  t_idx: int, 
                  v_type: int, 
                  v_weight: float
                  ) -> None:
* in_v_generic_PRE_FF(node: hou.SopNode, 
                    t_idx: int, 
                    v_type: int, 
                    v_weight: float
                    ) -> None:
* in_v_generic_POST_FF(node: hou.SopNode, 
                     t_idx: int, 
                     v_type: int, 
                     v_weight: float
                     ) -> None:
* in_v_pre_blur(mode: int, 
              node: hou.SopNode, 
              mp_idx: int, 
              pb_weights: tuple
              ) -> None:
* in_util_check_negative_weight(node: hou.SopNode, w: float, v_type: int, mode: int, mp_idx: int, func: Callable) -> float:
* in_get_xforms_data_and_flam3h_vars_limit(mode: int, apo_data: in_flame_iter_data) -> tuple[tuple, int]:
* in_get_preset_name_iternum(menu_label: str) -> int | None:
* in_util_join_vars_grp(groups: TA_STR_ListUnflattened) -> str:
* in_util_vars_flatten_unique_sorted(VARS_list: TA_STR_ListUnflattened, func: Callable, capitalize: bool = False) -> list[str]:
* in_presets_in_isvalid_file_menu_label(node: hou.SopNode, preset_id: int) -> str:
* in_set_iter_on_load(node: hou.SopNode, preset_id: int, clipboard: bool, flame_name_clipboard: str) -> int:
* in_load_sensor_stats_msg(preset_id: int, apo_data: in_flame_iter_data, XML_last_update: bool = False) -> str:
* in_load_render_stats_msg(preset_id: int, apo_data: in_flame_iter_data, XML_last_update: bool = False) -> str:
* in_copy_sensor(node: hou.SopNode, f3r: in_flame_iter_data, preset_id: int) -> None:
* in_copy_render(node: hou.SopNode, f3r: in_flame_iter_data, preset_id: int) -> None:
* in_copy_render_cc_curves(node: hou.SopNode, f3r: in_flame_iter_data, preset_id: int) -> None:
* in_copy_render_all_stats_msg(kwargs: dict,  apo_data: in_flame_iter_data | None = None, clipboard: bool = False, flash_message: bool = False) -> None:
* in_copy_sensor_stats_msg(kwargs: dict) -> None:
* in_copy_render_stats_msg(kwargs: dict) -> None:
* in_copy_cc_curves_stats_msg(kwargs: dict) -> None:
* in_util_vars_dict_type_maker(vars_dict: dict, func: Callable) -> dict:
* in_xml_key_val(xform: dict, key_name: str, default_val: float = 0) -> float:
* menu_in_presets_loop(node: hou.SopNode, menu: TA_Menu, i: int, item: str | list[Never], in_idx: int, is_clipboard: int) -> None:
* menu_in_presets_loop_enum(node: hou.SopNode, menu: TA_Menu, i: int, item: str | list[Never], in_idx: int, is_clipboard: int) -> None:
* menu_in_presets_empty_loop(node: hou.SopNode, menu: TA_Menu, i: int, item: str | list[Never]) -> None:
* menu_in_presets_empty_loop_enum(node: hou.SopNode, menu: TA_Menu, i: int, item: str | list[Never]) -> None:

@METHODS
* in_flam3h_set_iterators(self, 
                          mode: int, 
                          node: hou.SopNode, 
                          apo_data: in_flame_iter_data, 
                          preset_id: int, 
                          ) -> None:
* in_load_collect_vars(self, apo_data: in_flame_iter_data, data_checks: in_flame_checks, pgb_name: str = 'pre_gaussian_blur') -> list[str]:
* in_load_collect_vars_missing(self, apo_data: in_flame_iter_data, data_checks: in_flame_checks, vars_used: list[str], pgb_name: str = 'pre_gaussian_blur') -> list[str]:
* in_load_vars_used_msg(self, vars_used: list[str], grp_num: int = 5) -> str:
* in_load_vars_missing_msg(self, vars_missing: list[str], grp_num: int = 5) -> str:
* in_load_vars_unknown_msg(self, apo_data: in_flame_iter_data, preset_id: int, grp_num: int = 5) -> str:
* in_load_stats_msg(self, preset_id: int, apo_data: in_flame_iter_data, clipboard: bool, XML_last_update: bool = False) -> str:
* menu_in_presets_data(self, node: hou.SopNode, xml_file_path: str, xml_is_file: bool) -> TA_Menu:
* menu_in_presets(self) -> TA_Menu:
* menu_in_presets_empty_data(self, node: hou.SopNode, xml_file_path: str, xml_is_valid: bool) -> TA_Menu:
* menu_in_presets_empty(self) -> TA_Menu:
* set_iter_on_load_callback(self) -> None:
* use_iter_on_load_callback(self) -> None:
* in_to_flam3h_toggle(self, prm: str) -> None:
* in_to_flam3h_toggle_f3h_affine(self) -> None:
* in_to_flam3h_reset_user_data(self) -> None:
* in_to_flam3h_reset_iterators_parms(self, node: hou.SopNode, in_flame_iter_count: int) -> None:
* in_to_flam3h_resets(self, node: hou.SopNode, _FLAM3H_INIT_DATA: TA_F3H_Init) -> None:
* in_to_flam3h_set_iterators(self, node: hou.SopNode, apo_data: in_flame_iter_data, _FLAM3H_INIT_DATA: TA_F3H_Init) -> None:
* in_to_flam3h_set_motion_blur(self, node: hou.SopNode, apo_data: in_flame_iter_data) -> None:
* in_to_flam3h_set_palette(self, node: hou.SopNode, apo_data: in_flame_iter_data, _FLAM3H_INIT_DATA: TA_F3H_Init, flashmessage: bool = False) -> bool:
* in_to_flam3h_stats_and_properties(self, node: hou.SopNode, apo_data: in_flame_iter_data, _FLAM3H_INIT_DATA: TA_F3H_Init, copy_only: bool = False) -> None:
* in_to_flam3h_toggles_and_msg(self, node: hou.SopNode, apo_data: in_flame_iter_data, _FLAM3H_INIT_DATA: TA_F3H_Init) -> None:
* in_to_flam3h_init_data_ALT(self) -> TA_F3H_Init:
* in_to_flam3h_init_data_SHIFT(self, node: hou.SopNode) -> TA_F3H_Init:
* in_to_flam3h_init_data(self, node: hou.SopNode) -> TA_F3H_Init:
* in_to_flam3h_sys(self) -> None:
* in_to_flam3h(self) -> None:
* in_to_flam3h_render_properties_only(self) -> None:
* reset_IN(self, mode: int = 0) -> None:

    """
    
    __slots__ = ("_kwargs", "_node")
    
    def __init__(self, kwargs: dict) -> None:
        """
        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """ 
        self._kwargs: dict[str, Any] = kwargs
        self._node: hou.SopNode = kwargs['node']
        
        
    @staticmethod
    def in_util_key_name_isalnum(key_name: str) -> str:
        """Check and correct the passed in string for invalid characters.</br>

        Args:
            name(str): The string to check and correct.

        Returns:
            (str): the corrected string.
        """  
        return ''.join(letter for letter in key_name.strip() if letter.isalnum())
    
    
    @staticmethod
    def in_util_make_NULL(name: T) -> T:
        """This definition is used as a place holder.</br>

        Args:
            name(T): name or names to convert.

        Returns:
            (T): The untouched name's value passed in as argument.
        """       
        return name


    @staticmethod
    def in_util_make_VAR(name: TA_TypeVarCollection) -> str | list[str] | None:
        """Convert a PRE or POST variation name into a variation name.</br>

        Args:
            name(TA_TypeVarCollection): name or names to convert.

        Returns:
            (str | list[str] | None): A converted str, list[str] of variation's names.
        """
        if isinstance(name, str):
            
            if name.startswith(xml_keys.DEFAULT_VAR_PRE_PRX):
                return re_sub(xml_keys.REGEX_PRE, '', name)
            
            elif name.startswith(xml_keys.DEFAULT_VAR_POST_PRX):
                return re_sub(xml_keys.REGEX_POST, '', name)
            
            else:
                return name
            
        # Should I use: Iterable instead ? Perhaps this way I can catch if something else is being used.
        elif isinstance(name, (list, tuple, KeysView, set)):
            
            _names: list[str] = [re_sub(xml_keys.REGEX_PRE, '', x) for x in name if str(x).startswith(xml_keys.DEFAULT_VAR_PRE_PRX) is True]
            if not _names:
                _names = [re_sub(xml_keys.REGEX_POST, '', x) for x in name if str(x).startswith(xml_keys.DEFAULT_VAR_POST_PRX) is True]
                
            if not _names:
                return None
            
            return _names
        
        else:
            return None


    @staticmethod
    def in_util_make_PRE(name: TA_TypeVarCollection) -> str | list[str] | None:
        """Convert a variation name into a variation PRE variation name.</br>

        Args:
            name(TA_TypeVarCollection): name or names to convert.

        Returns:
            (str | list | None): A converted str, list[str] of variation's names.
        """  
        if isinstance(name, str):
            if not (name.startswith(xml_keys.DEFAULT_VAR_PRE_PRX) and name.startswith(xml_keys.DEFAULT_VAR_POST_PRX)):
                return xml_keys.DEFAULT_VAR_PRE_PRX + name
            
        # Should I use: Iterable instead ? Perhaps this way I can catch if something else is being used.
        elif isinstance(name, (list, tuple, KeysView, set)):
            return [xml_keys.DEFAULT_VAR_PRE_PRX + x for x in name if str(x).startswith(xml_keys.DEFAULT_VAR_PRE_PRX) is False and str(x).startswith(xml_keys.DEFAULT_VAR_POST_PRX) is False]
        
        else:
            return None


    @staticmethod
    def in_util_make_POST(name: TA_TypeVarCollection) -> str | list[str] | None:
        """Convert a variation name into a variation POST variation name.</br>

        Args:
            name(TA_TypeVarCollection): name or names to convert.

        Returns:
            (str | list[str] | None): A converted str, list[str] of variation's names.
        """  
        if isinstance(name, str):
            if not (name.startswith(xml_keys.DEFAULT_VAR_PRE_PRX) and name.startswith(xml_keys.DEFAULT_VAR_POST_PRX)):
                return xml_keys.DEFAULT_VAR_POST_PRX + name
            
        # Should I use: Iterable instead ? Perhaps this way I can catch if something else is being used.
        elif isinstance(name, (list, tuple, KeysView, set)):
            return [xml_keys.DEFAULT_VAR_POST_PRX + x for x in name if str(x).startswith(xml_keys.DEFAULT_VAR_PRE_PRX) is False and str(x).startswith(xml_keys.DEFAULT_VAR_POST_PRX) is False]
        
        else:
            return None


    @staticmethod
    def in_load_stats_unknown_vars(preset_id: int, apo_data: in_flame_iter_data) -> list[str]:
        """Find all the variations that Fractorium lacks if any.</br>
        Those variations will be classified as: Unknown</br>

        Args:
            preset_id(int): The loaded flame preset idx
            apo_data(in_flame_iter_data): The loaded flame preset data from the xml

        Returns:
            (list[str]): List of sorted uinknown variations if any
        """
        if apo_data.plugins[preset_id]:
            plugins: list[str] = [p.strip() for p in str(apo_data.plugins[preset_id]).split() if p]
        else:
            plugins: list[str] = []
        
        unknown: list[str] = []
        if plugins:
            for var in plugins:
                if str(var).startswith(xml_keys.DEFAULT_VAR_PRE_PRX):
                    name: str = str(in_flame_utils.in_util_make_VAR(var)).lower()
                    if name not in VARS_FRACTORIUM_DICT[name[0]]:
                        unknown.append(var.capitalize())
                        
                elif str(var).startswith(xml_keys.DEFAULT_VAR_POST_PRX):
                    name: str = str(in_flame_utils.in_util_make_VAR(var)).lower()
                    if name not in VARS_FRACTORIUM_DICT[name[0]]:
                        unknown.append(var.capitalize())
                        
                else:
                    if str(var).lower() not in VARS_FRACTORIUM_DICT[str(var)[0].lower()]:
                        unknown.append(var.capitalize())

        return sorted(unknown, key=lambda var: var)


    @staticmethod
    def in_to_flam3h_is_CHAOS(xml: str) -> bool:
        """Load a flame preset from a file and tell us if it is a Chaotica flame preset or not.</br>

        Args:
            xml(str): the xml file to load from.

        Returns:
            (bool): attempt_to_load_from_clipboard ( bool ): Is it a Chaotica's flame preset ? True or False.
        """ 
        try:
            tree: lxmlET._ElementTree = lxmlET.parse(xml)
        except OSError:
            return False
        except lxmlET.XMLSyntaxError:
            return False
            
        else:
            if xml_keys.XML_ROOT_CHAOS in tree.getroot().tag.lower():
                return True
            
            return False


    @staticmethod
    def in_to_flam3h_clipboard_is_CHAOS() -> bool:
        """Load a flame preset from the clipboard and tell us if it is a Chaotica flame preset or not.</br>

        Args:
            (None):
            
        Returns:
            (bool): attempt_to_load_from_clipboard ( bool ): Is it a Chaotica's flame preset ? True or False.
        """     
        xml: str = hou.ui.getTextFromClipboard() # type: ignore
        
        try:
            tree: lxmlET._ElementTree = lxmlET.ElementTree(lxmlET.fromstring(xml))
            
        except ValueError:
            return False
        
        except lxmlET.XMLSyntaxError:
            return False
        
        else:
            if xml_keys.XML_ROOT_CHAOS in tree.getroot().tag.lower():
                return True
            
            return False


    @staticmethod
    def in_get_xforms_var_keys( xforms: tuple[dict, ...] | None, 
                                vars: TA_XformVarKeys, 
                                exclude_keys: tuple
                                ) -> TA_STR_ListUnflattened | None:
        """Return a list of all the variation names included in all xforms compared against the available FLAM3H™ variations.</br>
        This is used to find variation names and PRE and POST variation names based on the provided vars argument.</br></br>
        
        Use this with everything but not PRE and POST dictionary lookup, use the following instead:
        * def in_get_xforms_var_keys_PP()
        
        Args:
            xforms(tuple[dict, ...] | None): list of all xforms contained inside this flame. This can be iterator's xforms or FF xform
            vars(TA_XformVarKeys): list of variations to look for inside each xfomrs, usually: VARS_FLAM3_DICT_IDX.keys()
            exclude_keys(tuple): keys to exclude from teh search to speedup a little

        Returns:
            (TA_STR_ListUnflattened | None): return a list of variation's names in each xform,  or None
        """    
        if xforms is not None:
            if isinstance(vars, dict):
                return [list(map(lambda x: x, filter(lambda x: x in vars.get(x[0]), filter(lambda x: x not in exclude_keys, xf.keys())))) for xf in xforms] # type: ignore
            
            return [list(map(lambda x: x, filter(lambda x: x in vars, filter(lambda x: x not in exclude_keys, xf.keys())))) for xf in xforms]
        
        return None
        
        
    @staticmethod
    def in_vars_keys_remove_pgb(vars: list | None, pgb_name: str) -> TA_STR_ListUnflattened | None:
        """Remove "pre_gaussian_blur" variation if it is the first one in the list as we are remapping it to "pre_blur" on load.</br>
        Args:
            vars(list | None): per iterator list of variations used, ideally always the PRE variations are passed here
            pgb_name(str): The name of the "pre_gaussian_blur" variation to check against.

        Returns:
            (TA_STR_ListUnflattened | None): A new list containing all iterator list of used variations without the "pre_gaussian_blur" if it was the first one in the list. 
        """
        if vars is not None:
            [vars[idx].pop(0) for idx, iter in enumerate(vars) if iter and iter[0] == pgb_name]
            return vars
        
        return None
    
        
    @staticmethod
    def in_util_removeprefix(var_name: str, prefix: str) -> str:
        """Remove any prefix, if a prefix is present, from a variation name.
        * ex: from: pre_linear to: linear
        * ex: from post_mobius to: mobius
    
        Args:
            var_name(str): the variation name to remove the prefix from
            prefix(str): the prefix to check

        Returns:
            (str): a variation name without the prefix, or the original variation name if it did not have any prefix. 
        """
        if var_name.startswith(prefix):
            return var_name[len(prefix):]
        
        return var_name[:]
        
        
    @staticmethod 
    def in_get_xforms_var_keys_PP(  xforms: tuple[dict, ...] | None, 
                                    vars: dict, 
                                    prx: str, 
                                    exclude_keys: tuple
                                    ) -> TA_STR_ListUnflattened | None:
        """find a PRE or POST variation inside the currently processed xform/iterator. All xforms are passed in.</br>

        Args:
            xforms(tuple[dict, ...] | None): All the xforms of this flame. This can be iterator's xforms or FF xform.
            vars(dict): the variations we are searching for
            prx(str): the current type of the variation expressed as a prefix: xml_keys.DEFAULT_VAR_PRE_PRX("pre_") or xml_keys.DEFAULT_VAR_POST_PRX("post_")
            exclude_keys(tuple): exclude those keys inside the current xform/iterator from the search to speed up a little

        Returns:
            (TA_STR_ListUnflattened | None): return a list of variations found using the prefix criteria
        """  
        if xforms is not None:
            _in_util_removeprefix: Callable[[str, str], str] = in_flame_utils.in_util_removeprefix
            return [list(map(lambda x: x, filter(lambda x: x in vars.get(_in_util_removeprefix(x, prx)[0]), filter(lambda x: x.startswith(prx), filter(lambda x: x not in exclude_keys, xf.keys()))))) for xf in xforms]
        
        return None
        
        
    @staticmethod
    def in_util_typemaker(data: list[float]) -> TA_TypeMaker:
        """Based on how many element in the passed list return the proper type of data.</br>
        
        Args:
            data(list[float]): A list of floats containinig the current parameter values to be converted into hou types.

        Returns:
            (TA_TypeMaker): Based on how many element in the passed list return the proper type of data
        """
        len_data: int = len(data)
        
        match len_data:
            
            case 1:
                return float(data[0])
            
            case 2:
                return hou.Vector2((data))
            
            case 3:
                return hou.Vector3((data))
            
            case 4:
                return hou.Vector4((data))
            
            case _:
                return data
        
        
    @staticmethod  
    def in_get_idx_by_key(key: str) -> int | None:
        """Return the variation idx based on its name from the variation's dictionary.</br>
        
        Args:
            key(str): variation name we are processing

        Returns:
            (int | None): return variation idx from the tuple look up table or None if not found
        """

        return VARS_FLAM3_DICT_IDX.get(key)
        
        
    @staticmethod
    def in_util_flam3h_prx_mode(mode: int) -> tuple[str, str]:
        """Set a prefix based on modes ( iterator, FF, FF PRE/POST )</br>
        Args:
            mode(int): 0 for iterator and 1 for FF

        Returns:
            (tuple[str, str]): return parameter prefixes based on mode: Iterator, FF, FF POST
        """
        
        match mode:
            
            case 1: # FF
                prx = f3h_ffPrmPrx.PRM
                prx_prm = f"{f3h_ffPrmPrx.PRM}_"
                
            case 2: # FF PRE/POST
                prx = f3h_ffPrmPrx.PRM
                prx_prm = f"{f3h_ffPrmPrx.PRM_PP}_"
                
            case _: # Iterator
                prx: str = ""
                prx_prm: str = ""
                
        return prx, prx_prm
    
    
    @staticmethod
    def in_set_affine(mode: int, 
                      node: hou.SopNode, 
                      prx: str, 
                      apo_data: in_flame_iter_data, 
                      flam3h_prm_names: flam3h_iterator_prm_names, 
                      mp_idx: int
                      ) -> None:
        """Set the affine values based on the loaded flame preset affine values for an iterator or the FF.</br>
        Added the ability to set parameters based also on the F3H affine style format if included in the loaded Flame preset.</br>
        
        Args:
            mode(int): 0 for iterator. 1 for FF
            node(hou.SopNode): Current FLAM3H™ node
            prx(str): parameter name prefix
            apo_data(in_flame_iter_data): Apophysis XML data collection from: class in_flame_iter_data(in_flame)
            flam3h_prm_names(flam3h_iterator_prm_names): Class of FLAM3H™ iterator parameter's names
            mp_idx(int): Multiparameter index -> the xform count from the outer loop: (mp_idx + 1)
        """
        idx: str = str(mp_idx + 1)
        zero_vectors: list[hou.Vector2] = [hou.Vector2(tuple([0, 0, 0, 0, 0, 0][i:i + 2])) for i in (0, 2, 4)]
        pre_affine: tuple[str, ...] = (flam3h_prm_names.preaffine_x, flam3h_prm_names.preaffine_y, flam3h_prm_names.preaffine_o)
        post_affine: tuple[str, ...] = (flam3h_prm_names.postaffine_x, flam3h_prm_names.postaffine_y, flam3h_prm_names.postaffine_o)
        f3h_affine: int = node.parm(f3h_tabs.IN.PRM_FLAM3H_AFFINE_STYLE).eval()
        
        if mode:
            
            if f3h_affine and apo_data.finalxform_f3h_coefs is not None and apo_data.finalxform_f3h_coefs[mp_idx]:
                for id in range(3): node.parmTuple(f"{prx}{pre_affine[id]}").set(apo_data.finalxform_f3h_coefs[mp_idx][id])
                node.parm(f"{prx}{flam3h_prm_names.preaffine_ang}").set(apo_data.finalxform_f3h_coefs_angle[mp_idx])
                
            else:
                if apo_data.finalxform_coefs is not None:
                    # The affine XML key: "coefs" must always be present in the XML file.
                    for id in range(3): node.parmTuple(f"{prx}{pre_affine[id]}").set(apo_data.finalxform_coefs[mp_idx][id])
                    
                else:
                    # If not present, we set all the pre affine values for this iterator to a value of: 0(Zero)
                    # Doing so it wont error out on load and it will act as a warning sign.
                    print(f"Warning: iterator.FF\nIN xml key: {xml_keys.XML_PRE_AFFINE} -> NOT FOUND, zero values used.\n")
                    
                    for id in range(3): node.parm(f"{prx}{pre_affine[id]}").set(zero_vectors[id])

            if apo_data.finalxform_post is not None:
                node.parm(f"{prx}{flam3h_prm_names.postaffine_do}").set(1)
                if f3h_affine and apo_data.finalxform_f3h_post is not None and apo_data.finalxform_f3h_post[mp_idx]:
                    for id in range(3): node.parmTuple(f"{prx}{post_affine[id]}").set(apo_data.finalxform_f3h_post[mp_idx][id])
                    node.parm(f"{prx}{flam3h_prm_names.postaffine_ang}").set(apo_data.finalxform_f3h_post_angle[mp_idx])
                    
                else:
                    for id in range(3): node.parmTuple(f"{prx}{post_affine[id]}").set(apo_data.finalxform_post[mp_idx][id])
                
        else:
            
            if f3h_affine and apo_data.f3h_coefs is not None and apo_data.f3h_coefs[mp_idx]:
                for id in range(3): node.parmTuple(f"{prx}{pre_affine[id]}_{idx}").set(apo_data.f3h_coefs[mp_idx][id])
                node.parm(f"{prx}{flam3h_prm_names.preaffine_ang}_{idx}").set(apo_data.f3h_coefs_angle[mp_idx])
                
            else:
                if apo_data.coefs is not None and apo_data.coefs[mp_idx]:
                    # The affine XML key: "coefs" must always be present in the XML file.
                    for id in range(3): node.parmTuple(f"{prx}{pre_affine[id]}_{idx}").set(apo_data.coefs[mp_idx][id])
                    
                else:
                    # If not present, we set all the pre affine values for this iterator to a value of: 0(Zero)
                    # Doing so it wont error out on load and it will act as a warning sign.
                    print(f"Warning: iterator.{mp_idx+1}\nIN xml key: {xml_keys.XML_PRE_AFFINE} -> NOT FOUND, zero values used.\n")
                    
                    for id in range(3): node.parmTuple(f"{prx}{pre_affine[id]}_{idx}").set(zero_vectors[id])

            if apo_data.post is not None and apo_data.post[mp_idx]:
                node.parm(f"{prx}{flam3h_prm_names.postaffine_do}_{idx}").set(1)
                if f3h_affine and apo_data.f3h_post is not None and apo_data.f3h_post[mp_idx]:
                    for id in range(3): node.parmTuple(f"{prx}{post_affine[id]}_{idx}").set(apo_data.f3h_post[mp_idx][id])
                    node.parm(f"{prx}{flam3h_prm_names.postaffine_ang}_{idx}").set(apo_data.f3h_post_angle[mp_idx])
                    
                else:
                    for id in range(3): node.parmTuple(f"{prx}{post_affine[id]}_{idx}").set(apo_data.post[mp_idx][id])


    @staticmethod
    def in_set_data(mode: int, 
                    node: hou.SopNode, 
                    prx: str, 
                    apo_data: tuple | list | None, 
                    prm_name: str, 
                    mp_idx: int
                    ) -> None:
        """Set single parameter data value from the loaded flame preset.</br>
        An example of the parameter you will set using this function are:
        
        * main_note
        * main_weight
        * shader_speed
        * shader_color
        * shader_alpha
        * xaos
        
        Args:
            mode(int): 0 for iterator. 1 for FF
            node(hou.SopNode): Current FLAM3H™ node
            prx(str): parameter name prefix
            apo_data(in_flame_iter_data): Apophysis XML data collection from: class in_flame_iter_data(in_flame)
            prm_name(str): parameter name for the current data we want to set
            mp_idx(int): Multiparameter index -> the xform count from the outer loop: (mp_idx + 1)
        
        Returns:
            (None):
        """
        if mode: pass
        else:
            if apo_data is not None:
                n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
                if prm_name not in [n.shader_alpha, n.main_weight]:
                    if apo_data[mp_idx]:
                        node.parm(f"{prx}{prm_name}_{mp_idx + 1}").set(apo_data[mp_idx])
                        
                else:
                    node.parm(f"{prx}{prm_name}_{mp_idx + 1}").set(apo_data[mp_idx])
           
           
    @staticmethod  
    def in_prm_name_exceptions(v_type: int, app: str | list[Never], apo_prm: tuple) -> tuple:
        """Some software have variation names and parameters names different from FLAM3H™ and Apophysis.</br>
        This will take care of those special cases.</br>
        It will swap the current variation dictionary item with the one the posses the corret names.</br>

        Args:
            v_type(int): The current variation we are processing
            app(str | list[Never]): The software used to generate the loaded flame preset.</br>It can also be an empty list if the app XML key is missing from the Flame preset we are trying to load.
            apo_prm(tuple): If no exception is found, return the original variation and parameter's names.

        Returns:
            (tuple): If an exception is confirmed, return the parameter expected parameter's name.
        """
        # if the app XML key is missing, set it to start with the Fractorium prefix always
        # otherwise use the found one.
        if isinstance(app, list): app = f"{xml_keys.XML_APP_NAME_FRACTORIUM}-NOT-FOUND"
        else: app = app.upper()
        
        # Lets check which one is coming in so to grab the proper parameteric parameters names
        if app.startswith(xml_keys.XML_APP_NAME_FRACTORIUM):
            check: tuple | None = flam3h_varsPRM_APO().varsPRM_FRACTORIUM_EXCEPTIONS.get(v_type)
            if check is not None:
                return check
            
            return apo_prm
        
        return apo_prm
        
        
    @staticmethod
    def in_get_dict_key_from_value(mydict: dict[str, int], idx: int) -> str:
        """Get the dictionary key from the dictionary value.</br>
        Used to get the current variation string name from its index from the global dict: VARS_FLAM3_DICT_IDX</br>

        Args:
            mydict(dict[str, int]): The dictionary for lookup
            idx(int): The variation index to retrieve its string name from.

        Returns:
            (str): The variation string name.
        """       
        var_name: str = list(mydict.keys())[list(mydict.values()).index(idx)] 
        return var_name
    
    
    @staticmethod
    def in_v_parametric_var_collect(node: hou.SopNode, 
                                    mode: int, 
                                    apo_prm: tuple, 
                                    xform: dict, 
                                    mp_idx: int, 
                                    v_type: int, 
                                    func: Callable) -> list[TA_TypeMaker]:
        """Each parametric variation has a specific number of parameters that govern its behavior.</br>
        These attributes have been combined into a single data type in FLAM3H™.</br>
        The Curl variation, for instance, has two parametric parameters: c1 and c2</br>
        Those two parameters have been packed into a vector2 data type: vector2[c1, c2].</br>
        This was done to improve speed since it was expensive to query a large number of distinct parameters,</br>
        especially when there were several iterators with simultaneous parametric parameters.</br>
        
        Args:
            node(hou.SopNode): Current FLAM3H™ node
            mode(int): 0 for iterator. 1 for FF
            apo_prm(tuple): tuple of APO variation parametric parameters names: flam3h_varsPRM_APO().varsPRM[v_type]
            xform(dict): current xform we are processing to the relative key names and values for the iterator
            mp_idx(int): for multiparameter index -> the xform count from the outer loop: (mp_idx + 1)
            v_type(int): the current variation type index
            func(Callable): function to change variation name between var, pre_var and post_var
        
        Returns:
            (list[TA_TypeMaker]): List of the expected data type of the collected parametric variation's parameters values.
        """   
        
        iter_type: str = f"{mp_idx + 1}"
        if mode: iter_type = 'FF'

        VAR: list[TA_TypeMaker] = []
        for names in apo_prm[1:-1]:
            var_prm_vals: list[float] = []
            _var_prm_vals_append: Callable[[float], None] = var_prm_vals.append
            for n in [x.lower() for x in names]:
                # If one of the FLAM3H™ parameter is not in the xform, skip it and set it to ZERO for now.
                n: str = func(n)
                if xform.get(n) is not None:
                    _var_prm_vals_append(float(in_flame.xf_val_cleanup_str(str(xform.get(n)), '0', n)))
                    
                else:
                    # If a variation parameter FLAM3H™ has is not found, set it to ZERO. Print its name to let us know if not inside XML_XF_PRM_EXCEPTION
                    if n not in XML_XF_PRM_EXCEPTION:
                        var_prm_vals.append(float(0))
                        print(f"Warning: iterator.{iter_type}\n{node.name()}: PARAMETER NOT FOUND\n-> Variation: {func(in_flame_utils.in_get_dict_key_from_value(VARS_FLAM3_DICT_IDX, v_type))}\n-> Missing parameter: {n}\n")
                        
            VAR.append(in_flame_utils.in_util_typemaker(var_prm_vals))
        
        return VAR


    @staticmethod
    def in_v_parametric(app: str | list[Never], 
                        mode: int, 
                        node: hou.SopNode, 
                        mp_idx: int, 
                        t_idx: int, 
                        xform: dict, 
                        v_type: int, 
                        v_weight: float, 
                        var_prm: tuple, 
                        apo_prm: tuple
                        ) -> None:
        """Set a FLAM3H™ parametric variation parameter data from the corresponding data found in the loaded XML Flame preset xform.</br>
        This include setting the variation type, its weight and its parametric parameters for an iterator or the FF.</br>
        
        Args:
            app(str | list[Never]): What software were used to generate this flame preset.</br>It can also be an empty list if the app XML key is missing from the Flame preset we are trying to load.
            mode(int): 0 for iterator. 1 for FF
            node(hou.SopNode): Current FLAM3H™ node
            mp_idx(int): for multiparameter index -> the xform count from the outer loop: (mp_idx + 1)
            t_idx(int): current variation number idx to use with: flam3h_iterator().sec_varsT, flam3h_iterator().sec_varsW
            xform(dict): current xform we are processing to the relative key names and values for the iterator
            v_type(int): the current variation type index
            v_weight(float): the current variation weight
            var_prm(tuple): tuple of FLAM3H™ node parameteric parameters names: flam3h_varsPRM().varsPRM[v_type]
            apo_prm(tuple): tuple of APO variation parametric parameters names: flam3h_varsPRM_APO().varsPRM[v_type]
            
        Returns:
            (None):
        """
        prx, prx_prm = in_flame_utils.in_util_flam3h_prx_mode(mode)
        
        # Exceptions: check if this flame need different parameters names based on detected exception
        apo_prm = in_flame_utils.in_prm_name_exceptions(v_type, app, apo_prm)

        _VAR: list[TA_TypeMaker] = in_flame_utils.in_v_parametric_var_collect(node, 
                                                                        mode, 
                                                                        apo_prm, 
                                                                        xform, 
                                                                        mp_idx, 
                                                                        v_type, 
                                                                        in_flame_utils.in_util_make_NULL)

        mpidx: str = str(mp_idx + 1)
        
        for idx, prm in enumerate(var_prm[1:-1]):
            # We are not using: def flam3h_prm_utils.setParms()
            # because those parameters have been already unlocked and cleared of their keyframes if any already
            if mode: node.setParms( # type: ignore
                                    {f"{prx_prm}{prm[0][:-1]}": _VAR[idx]}
                                    ) 
            else: node.setParms(    # type: ignore
                                    {f"{prx_prm}{prm[0]}{mpidx}": _VAR[idx]}
                                    ) 

        f3h_iter: flam3h_iterator = flam3h_iterator()
        if mode:
            node.parm(f"{prx}{f3h_iter.sec_varsT[t_idx][:-1]}").set(v_type)
            node.parm(f"{prx}{f3h_iter.sec_varsW[t_idx][0][:-1]}").set(v_weight)
            
        else:
            node.parm(f"{prx}{f3h_iter.sec_varsT[t_idx]}{mpidx}").set(v_type)
            node.parm(f"{prx}{f3h_iter.sec_varsW[t_idx][0]}{mpidx}").set(v_weight)
            
            
    @staticmethod
    def in_v_parametric_PRE(app: str | list[Never], 
                            mode: int, 
                            node: hou.SopNode, 
                            mp_idx: int, 
                            t_idx: int, 
                            xform: dict, 
                            v_type: int, 
                            v_weight: float, 
                            var_prm: tuple, 
                            apo_prm: tuple
                            ) -> None:
        """Set a FLAM3H™ parametric PRE variation parameter data from the corresponding data found in the loaded XML Flame preset xform.</br>
        This include setting the variation type, its weight and its parametric parameters.</br>
        
        Args:
            app(str | list[Never]): What software were used to generate this flame preset.</br>It can also be an empty list if the app XML key is missing from the Flame preset we are trying to load.
            mode(int): 0 for iterator. 1 for FF
            node(hou.SopNode): Current FLAM3H™ node
            mp_idx(int): for multiparameter index -> the xform count from the outer loop: (mp_idx + 1)
            t_idx(int): current variation number idx to use with: flam3h_iterator().sec_prevarsT, flam3h_iterator().sec_prevarsW
            xform(dict): current xform we are processing to the relative key names and values for the iterator
            v_type(int): the current variation type index
            v_weight(float): the current variation weight
            var_prm(tuple): tuple of FLAM3H™ node parameteric parameters names: flam3h_varsPRM().varsPRM[v_type]
            apo_prm(tuple): tuple of APO variation parametric parameters names: flam3h_varsPRM_APO().varsPRM[v_type]
            
        Returns:
            (None):
        """
        prx, prx_prm = in_flame_utils.in_util_flam3h_prx_mode(mode)
        
        # Exceptions: check if this flame need different parameters names based on detected exception
        apo_prm = in_flame_utils.in_prm_name_exceptions(v_type, app, apo_prm)
        
        _VAR: list[TA_TypeMaker] = in_flame_utils.in_v_parametric_var_collect(node, 
                                                                              mode, 
                                                                              apo_prm, 
                                                                              xform, 
                                                                              mp_idx, 
                                                                              v_type, 
                                                                              in_flame_utils.in_util_make_PRE)
        
        mpidx: str = str(mp_idx + 1)

        for idx, prm in enumerate(var_prm[1:-1]):
            # We are not using: def flam3h_prm_utils.setParms()
            # because those parameters have been already unlocked and cleared of their keyframes if any already
            node.setParms(# type: ignore
                        {f"{prx_prm}{prm[0]}{mpidx}": _VAR[idx]}
                        ) 

        # Only on pre variations with parametric so:
        node.parm(f"{prx}{flam3h_iterator().sec_prevarsT[t_idx]}{mpidx}").set(v_type)
        node.parm(f"{prx}{flam3h_iterator().sec_prevarsW[1:][t_idx][0]}{mpidx}").set(v_weight)


    @staticmethod
    def in_v_parametric_POST(app: str | list[Never], 
                             mode: int, 
                             node: hou.SopNode, 
                             mp_idx: int, 
                             t_idx: int, 
                             xform: dict, 
                             v_type: int, 
                             v_weight: float, 
                             var_prm: tuple, 
                             apo_prm: tuple
                             ) -> None:
        """Set a FLAM3H™ parametric POST variation parameter data from the corresponding data found in the loaded XML Flame preset xform.</br>
        This include setting the variation type, its weight and its parametric parameters.</br>
        
        Args:
            app(str | list[Never]): What software were used to generate this flame preset.</br>It can also be an empty list if the app XML key is missing from the Flame preset we are trying to load.
            mode(int): 0 for iterator. 1 for FF
            node(hou.SopNode): Current FLAM3H™ node
            mp_idx(int): for multiparameter index -> the xform count from the outer loop: (mp_idx + 1)
            t_idx(int): current variation number idx to use with: flam3h_iterator().sec_postvarsT, flam3h_iterator().sec_postvarsW
            xform(dict): current xform we are processing to the relative key names and values for the iterator
            v_type(int): the current variation type index
            v_weight(float): the current variation weight
            var_prm(tuple): tuple of FLAM3H™ node parameteric parameters names: flam3h_varsPRM().varsPRM[v_type]
            apo_prm(tuple): tuple of APO variation parametric parameters names: flam3h_varsPRM_APO().varsPRM[v_type]
            
        Returns:
            (None):
        """
        prx, prx_prm = in_flame_utils.in_util_flam3h_prx_mode(mode)
        
        # Exceptions: check if this flame need different parameters names based on detected exception
        apo_prm = in_flame_utils.in_prm_name_exceptions(v_type, app, apo_prm)

        _VAR: list[TA_TypeMaker] = in_flame_utils.in_v_parametric_var_collect(node, 
                                                                              mode, 
                                                                              apo_prm, 
                                                                              xform, 
                                                                              mp_idx, 
                                                                              v_type, 
                                                                              in_flame_utils.in_util_make_POST)
        
        mpidx: str = str(mp_idx + 1)
        for idx, prm in enumerate(var_prm[1:-1]):
            # We are not using: def flam3h_prm_utils.setParms()
            # because those parameters have been already unlocked and cleared of their keyframes if any already
            node.setParms(# type: ignore
                        {f"{prx_prm}{prm[0]}{mpidx}": _VAR[idx]}
                        ) 

        # Only on post variation with parametric so:
        node.parm(f"{prx}{flam3h_iterator().sec_postvarsT[t_idx]}{mpidx}").set(v_type)
        node.parm(f"{prx}{flam3h_iterator().sec_postvarsW[t_idx][0]}{mpidx}").set(v_weight)
    
    
    @staticmethod    
    def in_v_parametric_PRE_FF(app: str | list[Never], 
                               node: hou.SopNode, 
                               t_idx: int, 
                               xform: dict, 
                               v_type: int, 
                               v_weight: float, 
                               var_prm: tuple, 
                               apo_prm: tuple
                               ) -> None:
        """Set a FLAM3H™ parametric FF PRE variation parameter data from the corresponding data found in the loaded XML Flame preset xform.</br>
        This include setting the variation type, its weight and its parametric parameters.</br>
        
        Args:
            app(str | list[Never]): What software were used to generate this flame preset.</br>It can also be an empty list if the app XML key is missing from the Flame preset we are trying to load.
            node(hou.SopNode): Current FLAM3H™ houdini node
            t_idx(int): current variation number idx to use with: flam3h_iterator().sec_prevarsT_FF, flam3h_iterator().sec_prevarsW_FF
            xform(dict): current xform we are processing to the relative key names and values for the iterator
            v_type(int): the current variation type index
            v_weight(float): the current variation weight
            var_prm(tuple): tuple of FLAM3H™ node parameteric parameters names: flam3h_varsPRM().varsPRM[v_type]
            apo_prm(tuple): tuple of APO variation parametric parameters names: flam3h_varsPRM_APO().varsPRM[v_type]
            
        Returns:
            (None):
        """
        # Exceptions: check if this flame need different parameters names based on detected exception
        apo_prm = in_flame_utils.in_prm_name_exceptions(v_type, app, apo_prm)

        _VAR: list[TA_TypeMaker] = in_flame_utils.in_v_parametric_var_collect(node, 
                                                                              1, 
                                                                              apo_prm, 
                                                                              xform, 
                                                                              0, 
                                                                              v_type, 
                                                                              in_flame_utils.in_util_make_PRE)
            
        for idx, prm in enumerate(var_prm[1:-1]):
            # We are not using: def flam3h_prm_utils.setParms()
            # because those parameters have been already unlocked and cleared of their keyframes if any already
            node.setParms(# type: ignore
                        {f"{f3h_ffPrmPrx.PRM_PP}_{prm[0][0:-1]}": _VAR[idx]}
                        ) 

        # Only on post variation with parametric so:
        node.parm(f"{flam3h_iterator_FF().sec_prevarsT_FF[t_idx]}").set(v_type)
        node.parm(f"{flam3h_iterator_FF().sec_prevarsW_FF[t_idx][0]}").set(v_weight)


    @staticmethod
    def in_v_parametric_POST_FF(app: str | list[Never], 
                                node: hou.SopNode, 
                                t_idx: int, 
                                xform: dict, 
                                v_type: int, 
                                v_weight: float, 
                                var_prm: tuple, 
                                apo_prm: tuple
                                ) -> None:
        """Set a FLAM3H™ parametric FF POST variation parameter data from the corresponding data found in the loaded XML Flame preset xform.</br>
        This include setting the variation type, its weight and its parametric parameters.</br>
        
        Args:
            app(str | list[Never]): What software were used to generate this flame preset.</br>It can also be an empty list if the app XML key is missing from the Flame preset we are trying to load.
            node(hou.SopNode): Current FLAM3H™ node
            t_idx(int): current variation number idx to use with: flam3h_iterator().sec_postvarsT_FF, flam3h_iterator().sec_postvarsW_FF
            xform(dict): current xform we are processing to the relative key names and values for the iterator
            v_type(int): the current variation type index
            v_weight(float): the current variation weight
            var_prm(tuple): tuple of FLAM3H™ node parameteric parameters names: flam3h_varsPRM().varsPRM[v_type]
            apo_prm(tuple): tuple of APO variation parametric parameters names: flam3h_varsPRM_APO().varsPRM[v_type]
            
        Returns:
            (None):
        """
        # Exceptions: check if this flame need different parameters names based on detected exception
        apo_prm = in_flame_utils.in_prm_name_exceptions(v_type, app, apo_prm)

        _VAR: list[TA_TypeMaker] = in_flame_utils.in_v_parametric_var_collect(node, 
                                                                              1, 
                                                                              apo_prm, 
                                                                              xform, 
                                                                              0, 
                                                                              v_type, 
                                                                              in_flame_utils.in_util_make_POST)
            
        for idx, prm in enumerate(var_prm[1:-1]):
            # We are not using: def flam3h_prm_utils.setParms()
            # because those parameters have been already unlocked and cleared of their keyframes if any already
            node.setParms(# type: ignore
                        {f"{f3h_ffPrmPrx.PRM_PP}_{prm[0][0:-1]}": _VAR[idx]}
                        ) 

        # Only on post variation with parametric so:
        node.parm(f"{flam3h_iterator_FF().sec_postvarsT_FF[t_idx]}").set(v_type)
        node.parm(f"{flam3h_iterator_FF().sec_postvarsW_FF[t_idx][0]}").set(v_weight)


    @staticmethod
    def in_v_generic(mode: int, 
                     node: hou.SopNode, 
                     mp_idx: int, 
                     t_idx: int, 
                     v_type: int, 
                     v_weight: float
                     ) -> None:
        """Set a FLAM3H™ variation parameter data from the corresponding data found in the loaded XML Flame preset xform.</br>
        
        Args:
            mode(int): 0 for iterator. 1 for FF
            node(hou.SopNode): Current FLAM3H™ node
            mp_idx(int): Multiparameter index -> the xform count from the outer loop: (mp_idx + 1)
            t_idx(int): Current variation number idx to use with: flam3h_iterator().sec_prevarsT, flam3h_iterator().sec_prevarsW
            v_type(int): Current variation type index
            v_weight(float): Current variation weight
            
        Returns:
            (None):
        """
        prx, prx_prm = in_flame_utils.in_util_flam3h_prx_mode(mode)
        f3h_iter: flam3h_iterator = flam3h_iterator()
        if mode:
            node.parm(f"{prx}{f3h_iter.sec_varsT[t_idx][:-1]}").set(v_type)
            node.parm(f"{prx}{f3h_iter.sec_varsW[t_idx][0][:-1]}").set(v_weight)
            
        else:
            idx = str(mp_idx + 1)
            node.parm(f"{prx}{f3h_iter.sec_varsT[t_idx]}{idx}").set(v_type)
            node.parm(f"{prx}{f3h_iter.sec_varsW[t_idx][0]}{idx}").set(v_weight)


    @staticmethod
    def in_v_generic_PRE(mode: int, 
                         node: hou.SopNode, 
                         mp_idx: int, 
                         t_idx: int, 
                         v_type: int, 
                         v_weight: float
                         ) -> None:
        """Set a FLAM3H™ PRE variation parameter data from the corresponding data found in the loaded XML Flame preset xform.</br>
        
        Args:
            mode(int): 0 for iterator. 1 for FF
            node(hou.SopNode): Current FLAM3H™ node
            mp_idx(int): Multiparameter index -> the xform count from the outer loop: (mp_idx + 1)
            t_idx(int): Current variation number idx to use with: flam3h_iterator().sec_prevarsT, flam3h_iterator().sec_prevarsW
            v_type(int): Current variation type index
            v_weight(float): Current variation weight
            
        Returns:
            (None):
        """
        idx: str = str(mp_idx + 1)
        prx, prx_prm = in_flame_utils.in_util_flam3h_prx_mode(mode)
        node.parm(f"{prx}{flam3h_iterator().sec_prevarsT[t_idx]}{idx}").set(v_type)
        node.parm(f"{prx}{flam3h_iterator().sec_prevarsW[1:][t_idx][0]}{idx}").set(v_weight)


    @staticmethod
    def in_v_generic_POST(mode: int, 
                          node: hou.SopNode, 
                          mp_idx: int, 
                          t_idx: int, 
                          v_type: int, 
                          v_weight: float
                          ) -> None:
        """Set a FLAM3H™ POST variation parameter data from the corresponding data found in the loaded XML Flame preset xform.</br>
        
        Args:
            mode(int): [0 for iterator. 1 for FF
            node(hou.SopNode): Current FLAM3H™ node
            mp_idx(int): Multiparameter index -> the xform count from the outer loop: (mp_idx + 1)
            t_idx(int): Current variation number idx to use with: flam3h_iterator().sec_prevarsT, flam3h_iterator().sec_prevarsW
            v_type(int): Current variation type index
            v_weight(float): Current variation weight
            
        Returns:
            (None):
        """
        idx: str = str(mp_idx + 1)
        prx, prx_prm = in_flame_utils.in_util_flam3h_prx_mode(mode)
        node.parm(f"{prx}{flam3h_iterator().sec_postvarsT[t_idx]}{idx}").set(v_type)
        node.parm(f"{prx}{flam3h_iterator().sec_postvarsW[t_idx][0]}{idx}").set(v_weight)


    @staticmethod
    def in_v_generic_PRE_FF(node: hou.SopNode, 
                            t_idx: int, 
                            v_type: int, 
                            v_weight: float
                            ) -> None:
        """Set a FLAM3H™ FF PRE variation parameter data from the corresponding data found in the loaded XML Flame preset xform.</br>
        
        Args:
            node(hou.SopNode): Current FLAM3H™ node
            t_idx(int): Current variation number idx to use with: flam3h_iterator().sec_prevarsT, flam3h_iterator().sec_prevarsW
            v_type(int): Current variation type index
            v_weight(float): Current variation weight
            
        Returns:
            (None):
        """
        node.parm(f"{flam3h_iterator_FF().sec_prevarsT_FF[t_idx]}").set(v_type)
        node.parm(f"{flam3h_iterator_FF().sec_prevarsW_FF[t_idx][0]}").set(v_weight)


    @staticmethod
    def in_v_generic_POST_FF(node: hou.SopNode, 
                             t_idx: int, 
                             v_type: int, 
                             v_weight: float
                             ) -> None:
        """Set a FLAM3H™ FF POST variation parameter data from the corresponding data found in the loaded XML Flame preset xform.</br>
        
        Args:
            node(hou.SopNode): Current FLAM3H™ node
            t_idx(int): Current variation number idx to use with: flam3h_iterator().sec_prevarsT, flam3h_iterator().sec_prevarsW
            v_type(int): Current variation type index
            v_weight(float): Current variation weight
            
        Returns:
            (None):
        """
        node.parm(f"{flam3h_iterator_FF().sec_postvarsT_FF[t_idx]}").set(v_type)
        node.parm(f"{flam3h_iterator_FF().sec_postvarsW_FF[t_idx][0]}").set(v_weight)


    @staticmethod
    def in_v_pre_blur(mode: int, 
                      node: hou.SopNode, 
                      mp_idx: int, 
                      pb_weights: tuple
                      ) -> None:
        """Set a FLAM3H™ pre_blur variation parameter data from the corresponding data found in the loaded XML Flame preset xform.</br>
        
        Args:
            mode(int): 0 for iterator. 1 for FF
            node(hou.SopNode): Current FLAM3H™ node
            mp_idx(int): Multiparameter index -> the xform count from the outer loop: (mp_idx + 1)
            pb_weights(tuple): all iterators pre_blur weight values
        
        Returns:
            (None):
        """
        prx, prx_prm = in_flame_utils.in_util_flam3h_prx_mode(mode)
        if mode:
            pass
        
        else:
            if pb_weights[mp_idx]:
                node.parm(f"{prx}{flam3h_iterator_prm_names().prevar_weight_blur}_{mp_idx + 1}").set(pb_weights[mp_idx])


    @staticmethod
    def in_util_check_negative_weight(node: hou.SopNode, w: float, v_type: int, mode: int, mp_idx: int, func: Callable) -> float:
        """FLAM3H™ do not allow negative variation's weights for the PRE and POST variations.</br>
        This function will turn a negative weight into its absoulute value instead.</br>

        Args:
            node(hou.SopNode): FLAM3H™ node
            w(float): The variation weight to check.
            v_type_name(str): The name of the variation to print out if it turn out to have its weight with a negative value.
            mode(int): 0 for iterator. 1 for FF
            mp_idx(int): for multiparameter index -> the xform count from the outer loop: (mp_idx + 1)
            func(Callable): function to change variation name between var, pre_var and post_var
            
        Returns:
            (float): If the passed in weight value is negative, return its absolute value. Only for PRE and POST variations.
        """
        if w < 0:
            iter_type: str = f"{mp_idx + 1}"
            if mode:
                iter_type = 'FF'
            
            print(f"Warning: iterator.{iter_type}\n{node.name()}: NEGATIVE VALUE not allowed in PRE or POST\n-> Variation: {func(in_flame_utils.in_get_dict_key_from_value(VARS_FLAM3_DICT_IDX, v_type))}: {w}\n-> Using its absolute value instead: {abs(w)}\n")
            
            return abs(w)
        
        return w


    @staticmethod
    def in_get_xforms_data_and_flam3h_vars_limit(mode: int, apo_data: in_flame_iter_data) -> tuple[tuple, int]:
        """Get all the xforms data based on mode ( iterator or FF ),</br>
        and get all the allowed variations to be used based on mode ( iterator or FF ).</br>

        Args:
            mode(int): iterator or FF
            apo_data(in_flame_iter_data): Flames data from the flame file loaded in: class in_flame_iter_data(in_flame)

        Returns:
            (tuple[tuple, int]): Return a tuple containing either the iterator's xforms or the FF xform and max variation limit allowed.
        """
        xf: tuple | None = None
        _MAX_VARS: int = 0
        if mode:
            _MAX_VARS = xml_keys.f3h.DEFAULT_MAX_FF_VARS
            xf = apo_data.finalxform
            
        else:
            _MAX_VARS = xml_keys.f3h.DEFAULT_MAX_ITER_VARS
            xf = apo_data.xforms
            
        assert xf is not None
        return xf, _MAX_VARS


    @staticmethod
    def in_get_preset_name_iternum(menu_label: str) -> int | None:
        """Get the iteration number from the loaded Flame preset if any.</br>

        Args:
            preset_name(str): The Flame preset name.

        Returns:
            (int | None): The iteration number or none.
        """
        splt: tuple[str, str, str] = menu_label.rpartition(f3h_tabs.IN.DEFAULT_ITERATIONS_FLAME_NAME_DIV)
        if len([item for item in splt if item]) > 1:
            
            try:
                return int(splt[-1])
            
            except ValueError:
                return None
            
        return None


    @staticmethod
    def in_util_join_vars_grp(groups: TA_STR_ListUnflattened) -> str:
        """When formatting a message to print out we use groups as if they were each line of the meesage and join them.</br>
        This function will avoid to have an extra empty line at the very end.</br>

        Args:
            groups(TA_STR_ListUnflattened): The groups to join

        Returns:
            (str): The final message without the extra empty line at the end.
        """     
        _join: Callable[[Iterable[str]], str] = ', '.join
        _len: Callable[[list[Any]], int] = len
        vars: list[str] = [_join(grp) + (",\n" if i < _len(groups) - 1 else ".") for i, grp in enumerate(groups)]
        
        return ''.join(vars)


    @staticmethod
    def in_util_vars_flatten_unique_sorted(VARS_list: TA_STR_ListUnflattened, func: Callable, capitalize: bool = False) -> list[str]:
        """Return a flattened list of unique and sorted items without duplicates.

        Args:
            VARS_list(TA_STR_ListUnflattened): The data to flatten, remove duplicates and sort.
            func(Callable): Function to turn variation names from VAR to PRE or POST or none based on the function provided.
            capitalize(bool): Default to: False</br>capitalize the variation's names if any are found.

        Returns:
            (list[str]): Return a flattened list of unique and sorted items without duplicates.
        """
        
        _str_capitalize: Callable[[str], str] = str.capitalize
        return [_str_capitalize(func(x)) if capitalize else str(func(x)) for x in sorted(set(item for sublist in VARS_list for item in sublist)) if x]
    
    
    @staticmethod
    def in_presets_in_isvalid_file_menu_label(node: hou.SopNode, preset_id: int) -> str:
        """The IN presets menu parameters are 2, one for when a flame preset is loaded and one when not</br>
        plus when it can also happen that a preset from the clipboard has been loaded, introducing a new bookmark icon.</br>
        Those need to be queried separately, this definition will query the currently visible one and account for the clipboard case as well.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node
            preset_id(int): the menu preset selction index to use to retrive its menu label string

        Returns:
            (str): The selected menu preset menu label string
        """

        toggle_PREFS_ENUMERATE_MENU: int = node.parm(f3h_tabs.PREFS.PRM_ENUMERATE_MENU).eval()
        
        if node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval():
            
            if node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval():
                menu_label: str = str(node.parm(f3h_tabs.IN.PRM_PRESETS).menuLabels()[preset_id]).split(f3h_icons.STAR_FLAME_LOAD_CB)[-1].strip()
                # We are using "str.lstrip()" because the preset name has been "str.strip()" already in the above line.
                # and there are only the leading white spaces left from the menu enumaration index number string to remove.
                if toggle_PREFS_ENUMERATE_MENU:
                    return ':'.join(str(menu_label).split(':')[1:]).lstrip()
                
                return menu_label
            
            menu_label: str = str(node.parm(f3h_tabs.IN.PRM_PRESETS).menuLabels()[preset_id]).split(f3h_icons.STAR_FLAME_LOAD)[-1].strip()
            # We are using "str.lstrip()" because the preset name has been "str.strip()" already in the above line.
            # and there are only the leading white spaces left from the menu enumaration index number string to remove.
            if toggle_PREFS_ENUMERATE_MENU:
                return ':'.join(str(menu_label).split(':')[1:]).lstrip()
            
            return menu_label
            
        menu_label: str = str(node.parm(f3h_tabs.IN.PRM_PRESETS_OFF).menuLabels()[preset_id]).split(f3h_icons.STAR_FLAME_LOAD_EMPTY)[-1].strip()
        # We are using "str.lstrip()" because the preset name has been "str.strip()" already in the above line.
        # and there are only the leading white spaces left from the menu enumaration index number string to remove.
        if toggle_PREFS_ENUMERATE_MENU:
            return ':'.join(str(menu_label).split(':')[1:]).lstrip()
        
        return menu_label
    
    
    @staticmethod
    def in_set_iter_on_load(node: hou.SopNode, preset_id: int, clipboard: bool, flame_name_clipboard: str) -> int:
        """When loading a FLame preset, set the FLAM3H™ iteration number</br>
        to the value backed into the Flame preset name we just loaded.</br>

        Args:
            node(hou.SopNode): FLAM3H™ houdini node
            preset_id(int): The Flame preset we loaded
            clipboard(bool): Are we loading from a file or from the clipboard ?</br>This data is computed inside:</br>def in_flame_utils.in_to_flam3h_init_data(self, node: hou.SopNode)
            flame_name_clipboard(str): If we are laoding from the clipboard, use this preset name instead

        Returns:
            (int): The iteration number to set. If none is found, use the default value of 64 to load this Flame preset.
        """
        iter_on_load: int = node.parm(f3h_tabs.IN.PRM_ITER_NUM_ON_LOAD).eval()
        use_iter_on_load: int = node.parm(f3h_tabs.IN.PRM_USE_ITER_ON_LOAD).eval()
        
        if clipboard: preset_name = flame_name_clipboard
        else:
            # Get the correct menu parameter's preset menu label
            preset_name: str = in_flame_utils.in_presets_in_isvalid_file_menu_label(node, preset_id)
        
        iter_on_load_preset: int | None = in_flame_utils.in_get_preset_name_iternum(preset_name)
        if iter_on_load_preset is not None:
            # override iterations from the Flame preset name
            if use_iter_on_load and node.parm(f3h_tabs.IN.PRM_OVERRIDE_ITER_FLAME_NAME).eval():
                return node.parm(f3h_tabs.IN.PRM_ITER_NUM_ON_LOAD).eval()
            
            parms_dict: dict = {f3h_tabs.IN.PRM_ITER_NUM_ON_LOAD: iter_on_load_preset, 
                                f3h_tabs.IN.PRM_USE_ITER_ON_LOAD: 0}
            flam3h_prm_utils.setParms(node, parms_dict)
            
            return iter_on_load_preset
        
        if not use_iter_on_load:
            flam3h_prm_utils.set(node, f3h_tabs.IN.PRM_ITER_NUM_ON_LOAD, f3h_tabs.IN.DEFAULT_ITERATIONS_ON_LOAD)
            return f3h_tabs.IN.DEFAULT_ITERATIONS_ON_LOAD
            
        return iter_on_load 


    @staticmethod
    def in_load_sensor_stats_msg(preset_id: int, apo_data: in_flame_iter_data, XML_last_update: bool = False) -> str:
        """Collect and write a summuary of the loaded IN Flame file preset render properties.</br>

        Args:
            preset_id(int): The loaded XML Flame preset id to gather the data from.
            apo_data(in_flame_iter_data): The XML Flame file data
            XML_last_update(bool): Default to: False</br>If True and when a Flame preset is modified on disk while it is loaded into FLAM3H™</br>will add an asterisk(*) to the infos lines as an indicator we need to reload the Flame preset to fully update.

        Returns:
            (str): A string to be used to set the IN Render properties data parameter message.
        """
        # spacers
        nl: str = "\n"
        na: str = 'n/a'
        
        # If the XML Flame preset is modified on disk while it is currently loaded inside FLAM3H™ an asterisk(*) will be added to each IN infos line as an indicator.
        XML_updated: str = ''
        if XML_last_update: XML_updated = '*'
        
        size: str = f"{xml_keys.XML_RESOLUTION.capitalize()}: {na}"
        size_val: str | list[Never] = apo_data.out_size[preset_id]
        if size_val:
            size = f"{xml_keys.XML_RESOLUTION.capitalize()}: {size_val}"
            
        center: str = f"{xml_keys.XML_CENTER.capitalize()}: {na}"
        center_val: str | list[Never] = apo_data.out_center[preset_id]
        if center_val:
            center = f"{xml_keys.XML_CENTER.capitalize()}: {center_val}"
            
        rotate: str = f"{xml_keys.XML_ROTATE.capitalize()}: {na}"
        rotate_val: str | list[Never] = apo_data.out_rotate[preset_id]
        if rotate_val:
            rotate = f"{xml_keys.XML_ROTATE.capitalize()}: {rotate_val}"

        scale: str = f"{xml_keys.XML_SCALE.capitalize()}: {na}"
        scale_val: str | list[Never] = apo_data.out_scale[preset_id]
        if scale_val:
            scale = f"{xml_keys.XML_SCALE.capitalize()}: {scale_val}"
        
        build: tuple[str, ...] = (XML_updated, size, nl,
                                XML_updated, center, nl,
                                XML_updated, rotate, nl,
                                XML_updated, scale, nl,
                                )
        
        return ''.join(build)

    
    @staticmethod
    def in_load_render_stats_msg(preset_id: int, apo_data: in_flame_iter_data, XML_last_update: bool = False) -> str:
        """Collect and write a summuary of the loaded IN Flame file preset render properties.</br>

        Args:
            preset_id(int): The loaded XML Flame preset id to gather the data from.
            apo_data(in_flame_iter_data): The XML Flame file data
            XML_last_update(bool): Default to: False</br>If True and when a Flame preset is modified on disk while it is loaded into FLAM3H™</br>will add an asterisk(*) to the infos lines as an indicator we need to reload the Flame preset to fully update.

        Returns:
            (str): A string to be used to set the IN Render properties data parameter message.
        """
        # spacers
        nl: str = "\n"
        nnl: str = "\n\n"
        na: str = 'n/a'
        
        # If the XML Flame preset is modified on disk while it is currently loaded inside FLAM3H™ an asterisk(*) will be added to each IN infos line as an indicator.
        XML_updated: str = ''
        if XML_last_update: XML_updated = '*'
        
        quality: str = f"{xml_keys.XML_QUALITY.capitalize()}: {na}"
        quality_val: str | list[Never] = apo_data.out_quality[preset_id]
        if quality_val:
            quality = f"{xml_keys.XML_QUALITY.capitalize()}: {quality_val}"

        brightness: str = f"{xml_keys.XML_BRIGHTNESS.capitalize()}: {na}"
        brightness_val: str | list[Never] = apo_data.out_brightness[preset_id]
        if brightness_val:
            brightness = f"{xml_keys.XML_BRIGHTNESS.capitalize()}: {brightness_val}"
            
        gamma: str = f"{xml_keys.XML_GAMMA.capitalize()}: {na}"
        gamma_val: str | list[Never] = apo_data.out_gamma[preset_id]
        if gamma_val:
            gamma = f"{xml_keys.XML_GAMMA.capitalize()}: {gamma_val}"

        highlight: str = f"{' '.join(xml_keys.XML_POWER.split('_')).capitalize()}: {na}"
        highlight_val: str | list[Never] = apo_data.out_highlight_power[preset_id]
        if highlight_val:
            highlight = f"{' '.join(xml_keys.XML_POWER.split('_')).capitalize()}: {highlight_val}"
            
        log_k2: str = f"{' '.join(xml_keys.XML_K2.split('_')).capitalize()}: {na}"
        log_k2_val: str | list[Never] = apo_data.out_logscale_k2[preset_id]
        if log_k2_val:
            log_k2 = f"{' '.join(xml_keys.XML_K2.split('_')).capitalize()}: {log_k2_val}"

        vibrancy: str = f"{xml_keys.XML_VIBRANCY.capitalize()}: {na}"
        vibrancy_val: str | list[Never] = apo_data.out_vibrancy[preset_id]
        if vibrancy_val:
            vibrancy = f"{xml_keys.XML_VIBRANCY.capitalize()}: {vibrancy_val}"
        
        cc_curves: list[str] = []
        
        # Get this preset_id curves data
        _this_out_curve_overall: str = apo_data.out_curve_overall[preset_id]
        _this_out_curve_red: str = apo_data.out_curve_red[preset_id]
        _this_out_curve_green: str = apo_data.out_curve_green[preset_id]
        _this_out_curve_blue: str = apo_data.out_curve_blue[preset_id]
        
        # Compare and build
        if _this_out_curve_overall and _this_out_curve_overall not in xml_keys.DEFAULT_CC_CURVE_ALL: cc_curves.append('Overall')
        if _this_out_curve_red and _this_out_curve_red not in xml_keys.DEFAULT_CC_CURVE_ALL: cc_curves.append('Red')
        if _this_out_curve_green and _this_out_curve_green not in xml_keys.DEFAULT_CC_CURVE_ALL: cc_curves.append('Green')
        if _this_out_curve_blue and _this_out_curve_blue not in xml_keys.DEFAULT_CC_CURVE_ALL: cc_curves.append('Blue')
        if not cc_curves: cc = f"{XML_updated}COLOR CORRECTION: Default (OFF)\nThe loaded preset CC Curves are default values."
        else: cc = f"{XML_updated}COLOR CORRECTION:\n{', '.join(cc_curves)}"
        
        build: tuple[str, ...] = (XML_updated, quality, nl,
                                XML_updated, brightness, nl,
                                XML_updated, gamma, nl,
                                XML_updated, highlight, nl,
                                XML_updated, log_k2, nl,
                                XML_updated, vibrancy, nnl,
                                cc
                                )
        
        return ''.join(build)
    
    
    @staticmethod
    def in_copy_sensor(node: hou.SopNode, f3r: in_flame_iter_data, preset_id: int) -> None:
        """Copy the loaded IN Flame preset sensor XML data into the FLAM3H™ OUT sensor data.

        Args:
            node(hou.SopNode): FLAM3H™ node.
            f3r(in_flame_iter_data): The XML Flame file data to get the loaded preset data from.
            preset_id(int): the preset index we are loading 
            
        Returns:
            (None):
        """  
        
        # SIZE (Resolution)
        prm_size_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_SIZE)
        assert prm_size_name is not None
        prm_size = node.parmTuple(prm_size_name)
        try:
            prm_size_val: hou.Vector2 = hou.Vector2((int(f3r.out_size[preset_id].split()[0]), int(f3r.out_size[preset_id].split()[1])))
            flam3h_prm_utils.set(node, prm_size, prm_size_val)
        except (AttributeError, TypeError): # If missing set it to its default
            flam3h_prm_utils.set(node, prm_size, hou.Vector2((int(1024), int(1024))))
            print(f"Warning:\nIN xml key: {xml_keys.XML_SIZE} -> NOT FOUND, default value used.\n")
            
        # CENTER
        prm_center_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CENTER)
        assert prm_center_name is not None
        prm_center = node.parmTuple(prm_center_name)
        try:
            prm_center_val: hou.Vector2 = hou.Vector2((float(f3r.out_center[preset_id].split()[0]), float(f3r.out_center[preset_id].split()[1])))
            flam3h_prm_utils.set(node, prm_center, prm_center_val)
        except (AttributeError, TypeError): # If missing set it to its default
            flam3h_prm_utils.set(node, prm_center, hou.Vector2((float(0), float(0))))
            print(f"Warning:\nIN xml key: {xml_keys.XML_CENTER} -> NOT FOUND, default value used.\n")
            
        # ROTATE
        prm_rotate_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_ROTATE)
        assert prm_rotate_name is not None
        prm_rotate = node.parm(prm_rotate_name)
        try:
            prm_rotate_val: float = float(f3r.out_rotate[preset_id])
            flam3h_prm_utils.set(node, prm_rotate, prm_rotate_val)
        except (AttributeError, TypeError): # If missing set it to its default
            flam3h_prm_utils.set(node, prm_rotate, float(0))
            print(f"Warning:\nIN xml key: {xml_keys.XML_ROTATE} -> NOT FOUND, default value used.\n")

        # SCALE (Zoom)
        prm_scale_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_SCALE)
        assert prm_scale_name is not None
        prm_scale = node.parm(prm_scale_name)
        try:
            prm_scale_val: float = float(f3r.out_scale[preset_id])
            flam3h_prm_utils.set(node, prm_scale, prm_scale_val)
        except (AttributeError, TypeError): # If missing set it to its default
            flam3h_prm_utils.set(node, prm_scale, float(400))
            print(f"Warning:\nIN xml key: {xml_keys.XML_SCALE} -> NOT FOUND, default value used.\n")
    
    
    @staticmethod
    def in_copy_render(node: hou.SopNode, f3r: in_flame_iter_data, preset_id: int) -> None:
        """Copy the loaded IN Flame preset render XML data into the FLAM3H™ OUT render data.</br>

        Args:
            node(hou.SopNode): FLAM3H™ node.
            f3r(in_flame_iter_data): The XML Flame file data to get the loaded preset data from.
            preset_id(int): the preset index we are loading 
            
        Returns:
            (None):
        """  
        
        # QUALITY
        prm_quality_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_QUALITY)
        assert prm_quality_name is not None
        prm_quality = node.parm(prm_quality_name)
        try:
            prm_quality_val: int = int(f3r.out_quality[preset_id])
            flam3h_prm_utils.set(node, prm_quality, prm_quality_val)
        except (AttributeError, TypeError): # If missing set it to its default
            flam3h_prm_utils.set(node, prm_quality, int(1000))
            print(f"Warning:\nIN xml key: {xml_keys.XML_QUALITY} -> NOT FOUND, default value used.\n")

        # BRIGHTNESS
        prm_brightness_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_BRIGHTNESS)
        assert prm_brightness_name is not None
        prm_brightness = node.parm(prm_brightness_name)
        try:
            prm_brightness_val: float = float(f3r.out_brightness[preset_id])
            flam3h_prm_utils.set(node, prm_brightness, prm_brightness_val)
        except (AttributeError, TypeError): # If missing set it to its default
            flam3h_prm_utils.set(node, prm_brightness, 3.0)
            print(f"Warning:\nIN xml key: {xml_keys.XML_BRIGHTNESS} -> NOT FOUND, default value used.\n")

        # GAMMA
        prm_gamma_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_GAMMA)
        assert prm_gamma_name is not None
        prm_gamma = node.parm(prm_gamma_name)
        try:
            prm_gamma_val: float = float(f3r.out_gamma[preset_id])
            flam3h_prm_utils.set(node, prm_gamma, prm_gamma_val)
        except (AttributeError, TypeError): # If missing set it to its default
            flam3h_prm_utils.set(node, prm_gamma, 2.5)
            print(f"Warning:\nIN xml key: {xml_keys.XML_GAMMA} -> NOT FOUND, default value used.\n")

        # HIGHLIGHT POWER
        prm_hpower_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_POWER)
        assert prm_hpower_name is not None
        prm_hpower = node.parm(prm_hpower_name)
        try:
            prm_hpower_val: float = float(f3r.out_highlight_power[preset_id])
            flam3h_prm_utils.set(node, prm_hpower, prm_hpower_val)
        except (AttributeError, TypeError): # If missing set it to its default
            flam3h_prm_utils.set(node, prm_hpower, 5.0)
            print(f"Warning:\nIN xml key: {xml_keys.XML_POWER} -> NOT FOUND, default value used.\n")

        # LOGSCALE K2
        prm_k2_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_K2)
        assert prm_k2_name is not None
        prm_k2 = node.parm(prm_k2_name)
        try:
            prm_k2_val: float = float(f3r.out_logscale_k2[preset_id])
            flam3h_prm_utils.set(node, prm_k2, prm_k2_val)
        except (AttributeError, TypeError): # If missing set it to its default
            flam3h_prm_utils.set(node, prm_k2, 0.0)
            print(f"Warning:\nIN xml key: {xml_keys.XML_K2} -> NOT FOUND, default value used.\n")

        # VIBRANCY
        prm_vibrancy_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_VIBRANCY)
        assert prm_vibrancy_name is not None
        prm_vibrancy = node.parm(prm_vibrancy_name)
        try:
            prm_vibrancy_val: float = float(f3r.out_vibrancy[preset_id])
            flam3h_prm_utils.set(node, prm_vibrancy, prm_vibrancy_val)
        except (AttributeError, TypeError): # If missing set it to its default
            flam3h_prm_utils.set(node, prm_vibrancy, 0.33333333)
            print(f"Warning:\nIN xml key: {xml_keys.XML_VIBRANCY} -> NOT FOUND, default value used.\n")
    
    
    @staticmethod
    def in_copy_render_cc_curves(node: hou.SopNode, f3r: in_flame_iter_data, preset_id: int) -> None:
        """Copy the loaded IN Flame preset color correction XML data into the FLAM3H™ render color correction curves data.</br>
        It will check if each is one of the defaults settings first.</br>

        Args:
            node(hou.SopNode): FLAM3H™ node.
            f3r(in_flame_iter_data): The XML Flame file data to get the loaded preset data from.
            preset_id(int): the preset index we are loading 
            
        Returns:
            (None):
        """     
        # Render curves
        # Note that we are setting the value into the curve data parameters. Those parameters are protected inside the PREFS tab.
        
        prm_cc_all_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVES)
        assert prm_cc_all_name is not None
        prm_cc_all = node.parm(prm_cc_all_name)
        prm_cc_all_val: str = f3r.out_curves[preset_id]
        if prm_cc_all_val in xml_keys.DEFAULT_CC_CURVES_ALL:
            flam3h_prm_utils.private_prm_set(node, prm_cc_all, xml_keys.DEFAULT_CC_CURVES)
        else:
            try:
                flam3h_prm_utils.private_prm_set(node, prm_cc_all, prm_cc_all_val)
            except (AttributeError, TypeError): # If missing set it to its default
                flam3h_prm_utils.private_prm_set(node, prm_cc_all, xml_keys.DEFAULT_CC_CURVES)
                # Not all third-party applications export these keys so we avoid printing as it can be annoying.
                # print(f"Warning:\nIN xml key: {xml_keys.XML_CC_CURVES} -> NOT FOUND, default value used.\n")
                
        
        prm_cc_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_OVERALL)
        assert prm_cc_name is not None
        prm_cc = node.parm(prm_cc_name)
        prm_cc_val: str = f3r.out_curve_overall[preset_id]
        if prm_cc_val in xml_keys.DEFAULT_CC_CURVE_ALL:
            flam3h_prm_utils.private_prm_set(node, prm_cc, xml_keys.DEFAULT_CC_CURVE)
        else:
            try:
                flam3h_prm_utils.private_prm_set(node, prm_cc, prm_cc_val)
            except (AttributeError, TypeError): # If missing set it to its default
                flam3h_prm_utils.private_prm_set(node, prm_cc, xml_keys.DEFAULT_CC_CURVE)
                # Not all third-party applications export these keys so we avoid printing as it can be annoying.
                # print(f"Warning:\nIN xml key: {xml_keys.XML_CC_CURVE_OVERALL} -> NOT FOUND, default value used.\n")
                
                
        prm_ccr_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_RED)
        assert prm_ccr_name is not None
        prm_ccr = node.parm(prm_ccr_name)
        prm_ccr_val: str = f3r.out_curve_red[preset_id]
        if prm_ccr_val in xml_keys.DEFAULT_CC_CURVE_ALL:
            flam3h_prm_utils.private_prm_set(node, prm_ccr, xml_keys.DEFAULT_CC_CURVE)
        else:
            try:
                flam3h_prm_utils.private_prm_set(node, prm_ccr, prm_ccr_val)
            except (AttributeError, TypeError): # If missing set it to its default
                flam3h_prm_utils.private_prm_set(node, prm_ccr, xml_keys.DEFAULT_CC_CURVE)
                # Not all third-party applications export these keys so we avoid printing as it can be annoying.
                # print(f"Warning:\nIN xml key: {xml_keys.XML_CC_CURVE_RED} -> NOT FOUND, default value used.\n")
                
                
        prm_ccg_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_GREEN)
        assert prm_ccg_name is not None
        prm_ccg = node.parm(prm_ccg_name)
        prm_ccg_val: str = f3r.out_curve_green[preset_id]
        if prm_ccg_val in xml_keys.DEFAULT_CC_CURVE_ALL:
            flam3h_prm_utils.private_prm_set(node, prm_ccg, xml_keys.DEFAULT_CC_CURVE)
        else:
            try:
                flam3h_prm_utils.private_prm_set(node, prm_ccg, prm_ccg_val)
            except (AttributeError, TypeError): # If missing set it to its default
                flam3h_prm_utils.private_prm_set(node, prm_ccg, xml_keys.DEFAULT_CC_CURVE)
                # Not all third-party applications export these keys so we avoid printing as it can be annoying.
                # print(f"Warning:\nIN xml key: {xml_keys.XML_CC_CURVE_GREEN} -> NOT FOUND, default value used.\n")


        prm_ccb_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_BLUE)
        assert prm_ccb_name is not None
        prm_ccb = node.parm(prm_ccb_name)
        prm_ccb_val: str = f3r.out_curve_green[preset_id]
        if prm_ccb_val in xml_keys.DEFAULT_CC_CURVE_ALL:
            flam3h_prm_utils.private_prm_set(node, prm_ccb, xml_keys.DEFAULT_CC_CURVE)
        else:
            try:
                flam3h_prm_utils.private_prm_set(node, prm_ccb, prm_ccb_val)
            except (AttributeError, TypeError): # If missing set it to its default
                flam3h_prm_utils.private_prm_set(node, prm_ccb, xml_keys.DEFAULT_CC_CURVE)
                # Not all third-party applications export these keys so we avoid printing as it can be annoying.
                # print(f"Warning:\nIN xml key: {xml_keys.XML_CC_CURVE_BLUE} -> NOT FOUND, default value used.\n")
    
    
    @staticmethod
    def in_copy_render_all_stats_msg(kwargs: dict,  apo_data: in_flame_iter_data | None = None, clipboard: bool = False, flash_message: bool = False) -> None:
        """Copy the loaded IN Flame preset ALL properties into the OUT Flame render properties to be written out.</br>

        Args:
            kwargs(hou.SopNode): houdini kwargs.
            apo_data(in_flame_iter_data | None): Default to: None</br>All the XML data from the loaded Flame preset.
            clipboard(bool): Default to: False</br>True: load from clipboard. False: load from disk file ( load from the node stored data ).
            flash_message(bool): Default to: False</br>If True it will fire a flash message.
            
        Returns:
            (None):
        """       
        
        node: hou.SopNode = kwargs['node']

        inisvalidpreset: int = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval()

        # If "clipboard" is True mean the incoming Flame preset from the Clipboard has been checked/validated already
        # so no needs to double check here any more...just use it as is.
        if apo_data is not None and clipboard: f3r: in_flame_iter_data | None = apo_data
        else:
            # Check and Update this data
            flam3h_iterator_utils(kwargs).update_xml_last_loaded()
            # Otherwise just use the stored data
            data: str | None = node.userData(f3h_userData.XML_LAST)
            if data is not None: f3r: in_flame_iter_data | None = in_flame_iter_data(node, data) # ELSE load from the stored data instead
            else: f3r = None
        # We are checking only for the XML Flame preset validity
        # becasue we want to copy the data when loading from the clipboard
        # Hence we skip the checking of the toggles
        if f3r is not None and f3r.isvalidtree:
            
            # sensor data
            in_flame_utils.in_copy_sensor(node, f3r, 0)
            # render data
            in_flame_utils.in_copy_render(node, f3r, 0)
            # render curves data
            in_flame_utils.in_copy_render_cc_curves(node, f3r, 0)
            
            # OUT render curves ui parm set
            out_flame_utils.out_render_curves_retrive_data(node)
            # Check if the CC curves are at their default values or not and set the toggle
            # I could have done this inside the above: in_flame_utils.in_copy_render_cc_curves(node, f3r, preset_id)
            # but since this one is run also from a callback script, i'm doing the checks twice anyway
            out_flame_utils.out_render_curves_compare_and_set_toggle(node)
            
            # Set folder heading
            if clipboard:
                # We are not using: def flam3h_prm_utils.setParms()
                # because those parameters have been already unlocked and cleared of their keyframes if any already
                node.setParms(  # type: ignore
                                {f3h_tabs.IN.MSG_PRM_STATS_HEADING: f"{f3h_tabs.IN.DEFAULT_MSG_PRM_STATS_HEADING} {f3h_tabs.IN.DEFAULT_MSG_CLIPBOARD_LABEL}", 
                                f3h_tabs.IN.MSG_PRM_SETTINGS_HEADING: f"{f3h_tabs.IN.DEFAULT_MSG_PRM_SETTINGS_HEADING} {f3h_tabs.IN.DEFAULT_MSG_CLIPBOARD_LABEL}"}
                                )
            else:
                node.setParms(  # type: ignore
                                {f3h_tabs.IN.MSG_PRM_STATS_HEADING: f"{f3h_tabs.IN.DEFAULT_MSG_PRM_STATS_HEADING}", 
                                f3h_tabs.IN.MSG_PRM_SETTINGS_HEADING: f"{f3h_tabs.IN.DEFAULT_MSG_PRM_SETTINGS_HEADING}"}
                                )
            
            node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_EDIT).set(1)
            
            if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
                flam3h_general_utils(kwargs).util_set_clipping_viewers()
                flam3h_general_utils(kwargs).util_set_front_viewer()
            
            if clipboard: _MSG: str = f"IN ALL settings Clipboard: COPIED"
            else: _MSG: str = f"IN ALL settings: COPIED"
            flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'IMP')
            if flash_message: flam3h_general_utils.flash_message(node, _MSG)
            
        else:
            # The actual toggle is needed here
            clipboard = node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval()
            if inisvalidpreset and not clipboard:
                _MSG: str = f"IN: Data corrupted"
                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}.", 'WARN')
                flam3h_general_utils.flash_message(node, _MSG)
            elif inisvalidpreset and clipboard:
                _MSG: str = f"IN Clipboard: Data corrupted"
                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}.", 'WARN')
                flam3h_general_utils.flash_message(node, _MSG)


    @staticmethod
    def in_copy_sensor_stats_msg(kwargs: dict) -> None:
        """Copy the loaded IN Flame preset SENSOR properties into the OUT Flame render properties to be written out.</br>

        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """
        
        node: hou.SopNode = kwargs['node']
        
        inisvalidpreset: int = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval()
        clipboard: int = node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval()

        # Here we are checking those toggles
        # because when a Flame preset has been loaded already and we want to make sure it is still valid
        if inisvalidpreset or clipboard:
            
            # If not loading from the Clipboard, Check and Update this data
            if not clipboard: flam3h_iterator_utils(kwargs).update_xml_last_loaded()
            
            data: str | None = node.userData(f3h_userData.XML_LAST)
            if data is not None:
                f3r: in_flame_iter_data | None = in_flame_iter_data(node, data)
            
            else:
                f3r: in_flame_iter_data | None = None
                
            if f3r is not None and f3r.isvalidtree:
            
                # sensor data
                in_flame_utils.in_copy_sensor(node, f3r, 0)
                
                node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_EDIT).set(1)
                
                if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
                    flam3h_general_utils(kwargs).util_set_clipping_viewers()
                    flam3h_general_utils(kwargs).util_set_front_viewer()
                    
                _MSG: str = f"IN SENSOR settings: COPIED"
                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'IMP')
                flam3h_general_utils.flash_message(node, _MSG)
                
            else:
                if inisvalidpreset and not clipboard:
                    _MSG: str = f"IN: Data corrupted"
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}.", 'WARN')
                    flam3h_general_utils.flash_message(node, _MSG)
                    
                elif inisvalidpreset and clipboard:
                    _MSG: str = f"IN Clipboard: Data corrupted"
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}.", 'WARN')
                    flam3h_general_utils.flash_message(node, _MSG)
            
        else:
            _MSG: str = f"Load a valid IN Preset first"
            flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'WARN')
            flam3h_general_utils.flash_message(node, _MSG)
        

    @staticmethod
    def in_copy_render_stats_msg(kwargs: dict) -> None:
        """Copy the loaded IN Flame preset RENDER properties into the OUT Flame render properties to be written out.</br>

        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """
        
        node: hou.SopNode = kwargs['node']
        
        inisvalidpreset: int = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval()
        clipboard: int = node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval()
        
        # Here we are checking those toggles
        # because the a Flame preset has been loaded already and we want to make sure it is still valid
        if inisvalidpreset or clipboard:
            
            # If not loading from the Clipboard, Check and Update this data
            if not clipboard: flam3h_iterator_utils(kwargs).update_xml_last_loaded()
            
            data: str | None = node.userData(f3h_userData.XML_LAST)
            if data is not None:
                f3r:in_flame_iter_data | None = in_flame_iter_data(node, data) # ELSE load from the stored data instead
            
            else:
                f3r: in_flame_iter_data | None = None
            
            if f3r is not None and f3r.isvalidtree:
                
                # render data
                in_flame_utils.in_copy_render(node, f3r, 0)
                # render curves data
                in_flame_utils.in_copy_render_cc_curves(node, f3r, 0)

                # OUT render curves ui parm set
                out_flame_utils.out_render_curves_retrive_data(node)
                # Check if the CC curves are at their default values or not and set the toggle
                # I could have done this inside the above: in_flame_utils.in_copy_render_cc_curves(node, f3r, preset_id)
                # but since this one is run also from a callback script, i'm doing the checks twice anyway
                out_flame_utils.out_render_curves_compare_and_set_toggle(node)
                
                node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_EDIT).set(1)
                
                # This is not needed for just the RENDER properties, but it casue no harm, so...
                if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
                    flam3h_general_utils(kwargs).util_set_clipping_viewers()
                    flam3h_general_utils(kwargs).util_set_front_viewer()
                    
                _MSG: str = f"IN RENDER settings: COPIED"
                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'IMP')
                flam3h_general_utils.flash_message(node, _MSG)
                
            else:
                if inisvalidpreset and not clipboard:
                    _MSG: str = f"IN: Data corrupted"
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}.", 'WARN')
                    flam3h_general_utils.flash_message(node, _MSG)
                    
                elif inisvalidpreset and clipboard:
                    _MSG: str = f"IN Clipboard: Data corrupted"
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}.", 'WARN')
                    flam3h_general_utils.flash_message(node, _MSG)
            
        else:
            _MSG: str = f"Load a valid IN Preset first"
            flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'WARN')
            flam3h_general_utils.flash_message(node, _MSG)
            
            
    @staticmethod
    def in_copy_cc_curves_stats_msg(kwargs: dict) -> None:
        """Copy the loaded IN Flame preset CC CURVES data into the OUT Flame render color correction curves properties to be written out.</br>

        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """
        node: hou.SopNode = kwargs['node']

        inisvalidpreset: int = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval()
        clipboard: int = node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval()
        
        # Here we are checking those toggles
        # because the a Flame preset has been loaded already and we want to make sure it is still valid
        if inisvalidpreset or clipboard:
            
            data: str | None = node.userData(f3h_userData.XML_LAST)
            if data is not None:
                f3r:in_flame_iter_data | None = in_flame_iter_data(node, data)
            
            else:
                f3r: in_flame_iter_data | None = None
            
            if f3r is not None and f3r.isvalidtree:
                
                # render curves data
                in_flame_utils.in_copy_render_cc_curves(node, f3r, 0)
                
                cc_o: str = node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_OVERALL)).eval()
                cc_r: str = node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_RED)).eval()
                cc_g: str = node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_GREEN)).eval()
                cc_b: str = node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_BLUE)).eval()
                if cc_o.strip() in xml_keys.DEFAULT_CC_CURVE_ALL and cc_r.strip() in xml_keys.DEFAULT_CC_CURVE_ALL and cc_g.strip() in xml_keys.DEFAULT_CC_CURVE_ALL and cc_b.strip() in xml_keys.DEFAULT_CC_CURVE_ALL:
                    parms_dict: dict = {f3h_tabs.OUT.PRM_LABEL_CC_DEFAULTS_MSG: 'Defaults', 
                                        f3h_tabs.OUT.PRM_TOGGLE_CC_DEFAULTS_MSG: 0}
                    flam3h_prm_utils.setParms(node, parms_dict)
                    
                    _MSG: str = f"IN CC Curves:"
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} the loaded IN Flame preset CC Curves are default values. COPY SKIPPED", 'IMP')
                    flam3h_general_utils.flash_message(node, f"{_MSG} Defaults. COPY SKIPPED")
                else:
                    # OUT render curves ui parm set
                    out_flame_utils.out_render_curves_retrive_data(node)
                    # Check if the CC curves are at their default values or not and set the toggle
                    # I could have done this inside the above: in_flame_utils.in_copy_render_cc_curves(node, f3r, preset_id)
                    # but since this one is run also from a callback script, i'm doing the checks twice anyway
                    out_flame_utils.out_render_curves_compare_and_set_toggle(node)
                    
                    # menu_label = in_flame_utils.in_presets_in_isvalid_file_menu_label(node, 0)
                    _MSG: str = f"IN CC Curves: COPIED"
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} from the IN Flame preset: {out_flame_utils.out_remove_iter_num(f3r.name[0])}", 'IMP')
                    flam3h_general_utils.flash_message(node, _MSG)
                    
            else:
                if inisvalidpreset and not clipboard:
                    _MSG: str = f"IN: Data corrupted"
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}.", 'WARN')
                    flam3h_general_utils.flash_message(node, _MSG)
                elif inisvalidpreset and clipboard:
                    _MSG: str = f"IN Clipboard: Data corrupted"
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}.", 'WARN')
                    flam3h_general_utils.flash_message(node, _MSG)
            
        else:
            _MSG: str = f"Load a valid IN Preset first"
            flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} to copy color correction curves data from.", 'WARN')
            flam3h_general_utils.flash_message(node, _MSG)


    @staticmethod
    def in_util_vars_dict_type_maker(vars_dict: dict[str, set[str]], func: Callable) -> dict:
        """Convert a dictionary of variation names into either PRE, VAR or POST variations names in one go.</br>
        This is used mainly with this dictionary: VARS_FRACTORIUM_DICT</br> 

        Args:
            vars_dict(dict[str, set[str]]): The dictionary to convert. For now, always: VARS_FRACTORIUM_DICT
            func(Callable):  The function to conert the variation name.</br>Can be any of:</br>in_flame_utils.in_util_make_PRE</br>in_flame_utils.in_util_make_VAR</br>in_flame_utils.in_util_make_POST</br>in_flame_utils.in_util_make_NULL
            
        Returns:
            (dict): A new dictionary equal to the one passed in but with all variation names converted based on the passed Callable func.
        """   
        return dict(map(lambda item: (item[0], func(item[1])), vars_dict.items()))


    @staticmethod
    def in_xml_key_val(xform: dict, key_name: str, default_val: float = 0) -> float:
        """Check for the queried XML key name value if it is an actual value.</br>
        if not will return a default value instead.</br>

        Args:
            xform(dict): The current xform dictionary.
            key_name(str):  The XMK key name to querie
            default_val(float): Default to: 0(Zero)</br>If anything goes wrong, return this value instead
            
        Returns:
            (float): Either the queried key name value or a default value.
        """   
        key_val: str | None = xform.get(key_name)
        assert key_val is not None # I can assert this becasue the passed key_name has been collected already from an xform
        
        try:
            float(key_val)
            
        except ValueError:
            clean: list[str] = [letter for letter in key_val if letter in f3h_char.ALLOWED_XFORM_VAL]
            new_val: str = ''.join(clean)
            
            try:
                float(new_val)
                
            except ValueError:
                if key_name is not None: print(f"Warning:\nIN xml key: {key_name} -> NOT A VALUE\n")
                
                return default_val
            
            else:
                if key_name is not None: print(f"Warning:\nIN xml key: {key_name} -> NOT A VALUE (Corrected)\n")
                
                return float(new_val)
            
        else:
            return float(key_val)


    @staticmethod
    def menu_in_presets_loop(node: hou.SopNode, menu: TA_Menu, i: int, item: str | list[Never], in_idx: int, is_clipboard: int) -> None:
        """This is spcifically to be run inside a list comprehension.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node.
            menu(TA_Menu): the menu list to populate.
            i(int): The outer loop index/iteration.
            item(str | list[Never]): The outer loop item at index/iteration.</br>It can also be an empty list if the XML key is missing from the Flame preset we are trying to load.
            in_idx(int): The currently selected IN preset index.
            is_clipboard(int): IN Clipboard toggle.

        Returns:
            (None):
        """  
        
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            menu.append(str(i)) # This menu is a string parameter so I do believe this is the correct way
            
            # 5 ending \s to be able to read the full label
            labels: tuple[ str, ...] = (f"{f3h_icons.STAR_FLAME_LOAD}  {item}     ", 
                                        f"{f3h_icons.STAR_FLAME_LOAD_CB}  {f3h_tabs.IN.DEFAULT_MSG_CLIPBOARD_LABEL} {item}     ")
            # ICON bookmarks
            #
            # If a flame preset from a file is loaded
            if i == in_idx:
                node.setCachedUserData(f3h_cachedUserData.in_presets_menu_idx, str(i))
                menu.append(labels[is_clipboard])
                
            else:
                menu.append(f"{item}")
            
            
    @staticmethod
    def menu_in_presets_loop_enum(node: hou.SopNode, menu: TA_Menu, i: int, item: str | list[Never], in_idx: int, is_clipboard: int) -> None:
        """This is spcifically to be run inside a list comprehension.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node.
            menu(TA_Menu): the menu list to populate.
            i(int): The outer loop index/iteration.
            item(str | list[Never]): The outer loop item at index/iteration.</br>It can also be an empty list if the XML key is missing from the Flame preset we are trying to load.
            in_idx(int): The currently selected IN preset index.
            is_clipboard(int): IN Clipboard toggle.

        Returns:
            (None):
        """  
        
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            menu.append(str(i)) # This menu is a string parameter so I do believe this is the correct way
            enum_label: str = str(i + 1) # start count from 1
            
            # 5 ending \s to be able to read the full label
            labels: tuple[str, ...] = ( f"{f3h_icons.STAR_FLAME_LOAD}  {enum_label}:  {item}     ", 
                                        f"{f3h_icons.STAR_FLAME_LOAD_CB}  {enum_label}:  {f3h_tabs.IN.DEFAULT_MSG_CLIPBOARD_LABEL} {item}     ")
            # ICON bookmarks
            #
            # If a flame preset from a file is loaded
            if i == in_idx:
                node.setCachedUserData(f3h_cachedUserData.in_presets_menu_idx, str(i))
                menu.append(labels[is_clipboard])
                
            else:
                menu.append(f"{enum_label}:  {item}")
            
            
    @staticmethod
    def menu_in_presets_empty_loop(node: hou.SopNode, menu: TA_Menu, i: int, item: str | list[Never]) -> None:
        """This is spcifically to be run inside a list comprehension.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node.
            menu(TA_Menu): the menu list to populate.
            i(int): The outer loop index/iteration.
            item(str | list[Never]): The outer loop item at index/iteration.</br>It can also be an empty list if the XML key is missing from the Flame preset we are trying to load.

        Returns:
            (None):
        """  
        
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            menu.append(str(i)) # This menu is a string parameter so I do believe this is the correct way

            in_idx: int = int(node.parm(f3h_tabs.IN.PRM_PRESETS_OFF).eval())
            clipboard: int = node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval()
            # ICON bookmarks
            #
            # If a flame preset from a file is loaded
            if i == in_idx and not clipboard:
                node.setCachedUserData(f3h_cachedUserData.in_presets_menu_off_idx, str(i))
                menu.append(f"{f3h_icons.STAR_FLAME_LOAD_EMPTY}  {item}     ") # 5 ending \s to be able to read the full label

            else:
                menu.append(f"{item}")
            
            
    @staticmethod
    def menu_in_presets_empty_loop_enum(node: hou.SopNode, menu: TA_Menu, i: int, item: str | list[Never]) -> None:
        """This is spcifically to be run inside a list comprehension.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node.
            menu(TA_Menu): the menu list to populate.
            i(int): The outer loop index/iteration.
            item(str | list[Never]): The outer loop item at index/iteration.</br>It can also be an empty list if the XML key is missing from the Flame preset we are trying to load.

        Returns:
            (None):
        """  
        
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            menu.append(str(i)) # This menu is a string parameter so I do believe this is the correct way
            enum_label: str = str(i + 1) # start count from 1

            in_idx: int = int(node.parm(f3h_tabs.IN.PRM_PRESETS_OFF).eval())
            clipboard: int = node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval()
            # ICON bookmarks
            #
            # If a flame preset from a file is loaded
            if i == in_idx and not clipboard:
                node.setCachedUserData(f3h_cachedUserData.in_presets_menu_off_idx, str(i))
                menu.append(f"{f3h_icons.STAR_FLAME_LOAD_EMPTY}  {enum_label}:  {item}     ") # 5 ending \s to be able to read the full label

            else:
                menu.append(f"{enum_label}:  {item}")


    # CLASS: PROPERTIES
    ##########################################
    ##########################################


    @property
    def kwargs(self) ->  dict[str, Any]:
        return self._kwargs
    
    @property
    def node(self) -> hou.SopNode:
        return self._node


    def in_copy_section_render_stats_msg(self) -> None:
        """Copy either the SENSOR or the RENDER settings from the loaded flame preset</br>
        into the OUT tab properties.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        kwargs: dict = self.kwargs
        if kwargs["ctrl"]:
            self.in_copy_render_stats_msg(kwargs)
        else:
            self.in_copy_sensor_stats_msg(kwargs)
    
    
    def in_flam3h_set_iterators(self, 
                                mode: int, 
                                node: hou.SopNode, 
                                apo_data: in_flame_iter_data, 
                                preset_id: int, 
                                ) -> None:
        """Set the FLAM3H™ iterators/FF parameters based on collected XML data from the flame file loaded.</br>
        
        The collection of XML data happen inside:
        * class in_flame_iter_data(in_flame)

        Args:
            (self):
            mode(int): iterator or FF
            node(hou.SopNode): FLAM3H™ node
            apo_data(in_flame_iter_data): Flames data from the flame file loaded in: class in_flame_iter_data(in_flame)
            preset_id(int): the flame preset we are loading out of all the presets included in the flame file
            exclude_keys(tuple): exclude those keys inside the current xform/iterator from the search to speed up a little
            
        Returns:
            (None):
        """ 
        
        # timenow = datetime.now().strftime('%b-%d-%Y %H:%M:%S')
        
        # Cache for resuse
        _V_F3H_DICT_IDX_keys: KeysView = VARS_FLAM3_DICT_IDX.keys()
        
        # I could hard-code the name into the function: def in_vars_keys_remove_pgb(...), but this way I keep this dict global for all purposes.
        pgb_name: str | list[str] | None = self.in_util_make_PRE(self.in_get_dict_key_from_value(VARS_FLAM3_DICT_IDX, 33))
        assert isinstance(pgb_name, str)
        
        xforms, _MAX_VARS_MODE = self.in_get_xforms_data_and_flam3h_vars_limit(mode, apo_data)
        
        __EXCLUDE__: tuple[str, ...] = copy(XML_XF_KEY_EXCLUDE)
        vars_keys: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys(xforms, _V_F3H_DICT_IDX_keys, __EXCLUDE__)
        
        if vars_keys is not None:
            vars_keys_flatten: list[str] = [item for sublist in vars_keys for item in sublist]
            if vars_keys_flatten: __EXCLUDE__ += tuple(vars_keys_flatten)
        assert vars_keys is not None # This can be asserted because this definition is run after this Flame preset has been checked for its validity.
        vars_keys_pre_pgb: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys(xforms, self.in_util_make_PRE(_V_F3H_DICT_IDX_keys), __EXCLUDE__)
        vars_keys_pre: TA_STR_ListUnflattened | None = self.in_vars_keys_remove_pgb(vars_keys_pre_pgb, pgb_name)
        if vars_keys_pre is not None:
            vars_keys_pre_flatten: list[str] = [item for sublist in vars_keys_pre for item in sublist]
            if vars_keys_pre_flatten: __EXCLUDE__ += tuple(vars_keys_pre_flatten)
        assert vars_keys_pre is not None # This can be asserted because this definition is run after this Flame preset has been checked for its validity.
        vars_keys_post: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys(xforms, self.in_util_make_POST(_V_F3H_DICT_IDX_keys), __EXCLUDE__)
        assert vars_keys_post is not None # This can be asserted because this definition is run after this Flame preset has been checked for its validity.
        
        app: str = apo_data.sw_version[preset_id]
        prx, prx_prm = self.in_util_flam3h_prx_mode(mode)
        var_prm: tuple = flam3h_varsPRM().varsPRM
        apo_prm: tuple = flam3h_varsPRM_APO().varsPRM
        n: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
        
        # Set variations ( iterator and FF )
        for mp_idx, xform in enumerate(xforms):
            
            iterator_vars_skipped: list[str] = []
            FF_vars_skipped: list[str] = []
            
            # Collect iterator or FF vars in excess  
            if len(vars_keys[mp_idx]) > _MAX_VARS_MODE:
                if mode: FF_vars_skipped.append(f"\n\t\tFF VAR -> {', '.join(vars_keys[mp_idx][_MAX_VARS_MODE:])}")
                else: iterator_vars_skipped.append(f"\n\t\tVAR -> {', '.join(vars_keys[mp_idx][_MAX_VARS_MODE:])}")
            
            # in case of an iterator only the first 4. In case of an FF only the first 2
            for t_idx, key_name in enumerate(vars_keys[mp_idx][:_MAX_VARS_MODE]):
                v_type: int | None = self.in_get_idx_by_key(key_name)
                if v_type is not None:
                    v_weight: float = self.in_xml_key_val(xform, key_name)
                    if apo_prm[v_type][-1]:
                        self.in_v_parametric(app, 
                                             mode, 
                                             node, 
                                             mp_idx, 
                                             t_idx, 
                                             xform, 
                                             v_type, 
                                             v_weight, 
                                             var_prm[v_type], 
                                             apo_prm[v_type]
                                             )
                    else:
                        self.in_v_generic(mode, node, mp_idx, t_idx, v_type, v_weight)
                else:
                    # if this variation is not found, set it to Linear and its weight to ZERO
                    # Note that if the missing variation will is int the first slot inside any of the available types (PRE, VAR or POST)
                    # it will be set to its respective default value becasue the multi param parameters are reverted baco to their defaults on Flame load.
                    self.in_v_generic(mode, node, mp_idx, t_idx, 0, 0)
                    
            # Set pre blur if found
            assert apo_data.pre_blur is not None
            self.in_v_pre_blur(mode, node, mp_idx, apo_data.pre_blur)
                    
            if mode:
                assert apo_data.finalxform_name is not None
                # Set finalxform name first if any
                if apo_data.finalxform_name[0]:
                    node.parm(f"{prx}{n.main_note}").set(apo_data.finalxform_name[0])
                    
                # Collect FF PRE vars in excess  
                if len(vars_keys_pre[mp_idx]) > xml_keys.f3h.DEFAULT_MAX_FF_VARS_PRE:
                    if FF_vars_skipped: FF_vars_skipped.insert(0, f"\n\t\tFF PRE -> {', '.join(vars_keys_pre[mp_idx][xml_keys.f3h.DEFAULT_MAX_FF_VARS_PRE:])}")
                    else: FF_vars_skipped.append(f"\n\t\tFF PRE -> {', '.join(vars_keys_pre[mp_idx][xml_keys.f3h.DEFAULT_MAX_FF_VARS_PRE:])}")
                    
                # FF PRE vars ( only the first one in "vars_keys_pre[mp_idx]" will be kept )
                if vars_keys_pre[mp_idx]:
                    for t_idx, key_name in enumerate(vars_keys_pre[mp_idx][:xml_keys.f3h.DEFAULT_MAX_FF_VARS_PRE]):
                        v_type: int | None = self.in_get_idx_by_key(str(self.in_util_make_VAR(key_name)))
                        if v_type is not None:
                            w: float = self.in_xml_key_val(xform, key_name)
                            v_weight: float = self.in_util_check_negative_weight(node, w, v_type, mode, mp_idx, self.in_util_make_PRE)
                            if apo_prm[v_type][-1]:
                                self.in_v_parametric_PRE_FF(app, 
                                                            node, 
                                                            t_idx, 
                                                            xform, 
                                                            v_type, 
                                                            v_weight, 
                                                            var_prm[v_type], 
                                                            apo_prm[v_type]
                                                            )
                            else: self.in_v_generic_PRE_FF(node, t_idx, v_type, v_weight)
                         
                # Collect FF POST vars in excess       
                if len(vars_keys_post[mp_idx]) > xml_keys.f3h.DEFAULT_MAX_FF_VARS_POST:
                    FF_vars_skipped.append(f"\n\t\tFF POST -> {', '.join(vars_keys_post[mp_idx][xml_keys.f3h.DEFAULT_MAX_FF_VARS_POST:])}")

                # FF POST vars ( only the first two in "vars_keys_post[mp_idx]" will be kept )
                if vars_keys_post[mp_idx]:
                    for t_idx, key_name in enumerate(vars_keys_post[mp_idx][:xml_keys.f3h.DEFAULT_MAX_FF_VARS_POST]):
                        v_type: int | None = self.in_get_idx_by_key(str(self.in_util_make_VAR(key_name)))
                        if v_type is not None:
                            w: float = self.in_xml_key_val(xform, key_name)
                            v_weight: float = self.in_util_check_negative_weight(node, w, v_type, mode, mp_idx, self.in_util_make_POST)
                            if apo_prm[v_type][-1]:
                                self.in_v_parametric_POST_FF(app, 
                                                             node, 
                                                             t_idx, 
                                                             xform, 
                                                             v_type, 
                                                             v_weight, 
                                                             var_prm[v_type], 
                                                             apo_prm[v_type]
                                                             )
                            else: self.in_v_generic_POST_FF(node, t_idx, v_type, v_weight)
                
                # Print all skipped FF vars if any
                if FF_vars_skipped:
                    build: str = f"Warning:\n{self.node}.FF\n\tThe following variations are in excess and skipped:{''.join(FF_vars_skipped)}\n"
                    print(build)
                
            else:
                
                # Collect iterator PRE vars in excess
                if len(vars_keys_pre[mp_idx]) > xml_keys.f3h.DEFAULT_MAX_ITER_VARS_PRE:
                    if iterator_vars_skipped:
                        iterator_vars_skipped.insert(0, f"\n\t\tPRE -> {', '.join(vars_keys_pre[mp_idx][xml_keys.f3h.DEFAULT_MAX_ITER_VARS_PRE:])}")
                    else:
                        iterator_vars_skipped.append(f"\n\t\tPRE -> {', '.join(vars_keys_pre[mp_idx][xml_keys.f3h.DEFAULT_MAX_ITER_VARS_PRE:])}")
                # PRE vars in this iterator ( only the first two in "vars_keys_pre[mp_idx]" will be kept )
                if vars_keys_pre[mp_idx]:
                    for t_idx, key_name in enumerate(vars_keys_pre[mp_idx][:xml_keys.f3h.DEFAULT_MAX_ITER_VARS_PRE]):
                        
                        v_type: int | None = self.in_get_idx_by_key(str(self.in_util_make_VAR(key_name)))
                        if v_type is not None:
                            w: float = self.in_xml_key_val(xform, key_name)
                            v_weight: float = self.in_util_check_negative_weight(node, w, v_type, mode, mp_idx, self.in_util_make_PRE)
                            if apo_prm[v_type][-1]:
                                self.in_v_parametric_PRE(app, 
                                                         mode, 
                                                         node, 
                                                         mp_idx, 
                                                         t_idx, 
                                                         xform, 
                                                         v_type, 
                                                         v_weight, 
                                                         var_prm[v_type], 
                                                         apo_prm[v_type]
                                                         )
                            else: self.in_v_generic_PRE(mode, node, mp_idx, t_idx, v_type, v_weight)
                
                # Collect iterator POST vars in excess
                if len(vars_keys_post[mp_idx]) > xml_keys.f3h.DEFAULT_MAX_ITER_VARS_POST:
                    iterator_vars_skipped.append(f"\n\t\tPOST -> {', '.join(vars_keys_post[mp_idx][xml_keys.f3h.DEFAULT_MAX_ITER_VARS_POST:])}")

                # POST vars in this iterator ( only the first one in "vars_keys_post[mp_idx]" will be kept )
                if vars_keys_post[mp_idx]:
                    for t_idx, key_name in enumerate(vars_keys_post[mp_idx][:xml_keys.f3h.DEFAULT_MAX_ITER_VARS_POST]):
                        v_type: int | None = self.in_get_idx_by_key(str(self.in_util_make_VAR(key_name)))
                        if v_type is not None:
                            w: float = self.in_xml_key_val(xform, key_name)
                            v_weight: float = self.in_util_check_negative_weight(node, w, v_type, mode, mp_idx, self.in_util_make_POST)
                            if apo_prm[v_type][-1]:
                                self.in_v_parametric_POST(app, 
                                                          mode, 
                                                          node, 
                                                          mp_idx, 
                                                          t_idx, 
                                                          xform, 
                                                          v_type, 
                                                          v_weight, 
                                                          var_prm[v_type], 
                                                          apo_prm[v_type]
                                                          )
                            else: self.in_v_generic_POST(mode, node, mp_idx, t_idx, v_type, v_weight)
                       
                # Print all skipped iterators vars if any
                if iterator_vars_skipped:
                    build: str = f"Warning:\n{self.node}.iterator.{mp_idx + 1}\n\tThe following variations are in excess and skipped:{''.join(iterator_vars_skipped)}\n"
                    print(build)
                                
                # Activate iterator
                node.parm(f"{n.main_vactive}_{mp_idx + 1}").set(1)
                # Set the rest of the iterator(FLAME or FF) parameters
                apo_data_set: dict[str, tuple | None] = {n.main_note: apo_data.xf_name, 
                                                         n.main_weight: apo_data.weight,
                                                         n.xaos: apo_data.xaos,
                                                         n.shader_color: apo_data.color,
                                                         n.shader_speed: apo_data.symmetry,
                                                         n.shader_alpha: apo_data.opacity
                                                         }
                for key, value in apo_data_set.items(): self.in_set_data(mode, node, prx, value, key, mp_idx)
            
            # Set Affine ( PRE, POST and F3H_PRE, F3H_POST) for this iterator or FF
            self.in_set_affine(mode, node, prx, apo_data, n, mp_idx)


    def in_load_collect_vars(self, apo_data: in_flame_iter_data, data_checks: in_flame_checks, pgb_name: str = 'pre_gaussian_blur') -> list[str]:
        """Build a message with all the used variations in the Flame preset we just loaded.</br>
        They will be collected inside a list of strings and they will be unique(no duplicates) and sorted.</br>

        Args:
            (self):
            apo_data(in_flame_iter_data): The XML Flame data for the preset we are loading in FLAM3H™.
            data_checks(in_flame_checks): Class containing checks about what is being used by the loaded Flame preset.</br>Please refere to the class itself for more infos.
            pgb_name(str): Default to: 'pre_gaussian_blur'</br>Correct name of the PRE gaussian blur, always "pre_gaussian_blur" but always computed in advance.</br>This variation will be removed if it is the first one in the list of PRE variations.

        Returns:
            (list[str]): A list containing the unique used variations sorted alphatically.
        """  
        
        # Cache for resuse
        _V_F3H_DICT_IDX_keys: KeysView = VARS_FLAM3_DICT_IDX.keys()
        
        # ITERATOR COLLECT
        __EXCLUDE__: tuple[str, ...] = copy(XML_XF_KEY_EXCLUDE)
        vars_keys: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys(apo_data.xforms, _V_F3H_DICT_IDX_keys, __EXCLUDE__)
        if vars_keys is not None:
            vars_keys_flatten: list[str] = [item for sublist in vars_keys for item in sublist]
            if vars_keys_flatten: __EXCLUDE__ += tuple(vars_keys_flatten)
        vars_keys_PRE_pgb: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys(apo_data.xforms, self.in_util_make_PRE(_V_F3H_DICT_IDX_keys), __EXCLUDE__)
        vars_keys_PRE: TA_STR_ListUnflattened | None = self.in_vars_keys_remove_pgb(vars_keys_PRE_pgb, pgb_name)
        if vars_keys_PRE is not None: 
            vars_keys_PRE_flatten: list[str] = [item for sublist in vars_keys_PRE for item in sublist]
            if vars_keys_PRE_flatten: __EXCLUDE__ += tuple(vars_keys_PRE_flatten)
        vars_keys_POST: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys(apo_data.xforms, self.in_util_make_POST(_V_F3H_DICT_IDX_keys), __EXCLUDE__)
        
        # FF COLLECT
        vars_keys_FF = vars_keys_PRE_FF = vars_keys_POST_FF = []
        if data_checks.ff_bool:
            __EXCLUDE__ = copy(XML_XF_KEY_EXCLUDE)
            vars_keys_FF: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys(apo_data.finalxform, _V_F3H_DICT_IDX_keys, __EXCLUDE__)
            if vars_keys_FF is not None:
                vars_keys_FF_flatten: list[str] = [item for sublist in vars_keys_FF for item in sublist]
                if vars_keys_FF_flatten: __EXCLUDE__ += tuple(vars_keys_FF_flatten)
            vars_keys_PRE_FF: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys(apo_data.finalxform, self.in_util_make_PRE(_V_F3H_DICT_IDX_keys), __EXCLUDE__)
            if vars_keys_PRE_FF is not None:
                vars_keys_PRE_FF_flatten: list[str] = [item for sublist in vars_keys_PRE_FF for item in sublist]
                if vars_keys_PRE_FF_flatten: __EXCLUDE__ += tuple(vars_keys_PRE_FF_flatten)
            vars_keys_POST_FF: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys(apo_data.finalxform, self.in_util_make_POST(_V_F3H_DICT_IDX_keys), __EXCLUDE__)
        
        # JOIN PRE, VAR and POST
        vars_all: list[list[str]] = vars_keys_PRE + vars_keys + vars_keys_POST + vars_keys_PRE_FF + vars_keys_FF + vars_keys_POST_FF # type: ignore
        if data_checks.pb_bool: vars_all += [["pre_blur"]]
        # Unique and sorted
        vars_used: list[str] = self.in_util_vars_flatten_unique_sorted(vars_all, self.in_util_make_NULL, True)
        
        return vars_used
    
    
    def in_load_collect_vars_missing(self, apo_data: in_flame_iter_data, data_checks: in_flame_checks, vars_used: list[str], pgb_name: str = 'pre_gaussian_blur') -> list[str]:
        """Build a message with all the missing variation in the Flame preset we just loaded.</br>
        They will be collected inside a list of strings and they will be unique(no duplicates) and sorted.</br>

        Args:
            (self):
            apo_data(in_flame_iter_data): The XML Flame data for the preset we are loading in FLAM3H™.
            data_checks(in_flame_checks): Class containing checks about what is being used by the loaded Flame preset.</br>Please refere to the class itself for more infos.
            vars_used(list[str]): Used variations unique and sorted.</br>This is coming from: def in_load_collect_vars(self, apo_data: in_flame_iter_data, data_checks: in_flame_checks, pgb_name: str = 'pre_gaussian_blur') -> list[str]:
            pgb_name(str): Default to: 'pre_gaussian_blur'</br>Correct name of the PRE gaussian blur, always "pre_gaussian_blur" but always computed in advance.</br>This variation will be removed if it is the first one in the list of PRE variations.

        Returns:
            (list[str]): A list containing the unique missing variations sorted alphatically.
        """  
        # Build ITERATOR MISSING
        __EXCLUDE__ = copy(XML_XF_KEY_EXCLUDE)
        vars_keys_from_fractorium: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys(apo_data.xforms, VARS_FRACTORIUM_DICT, __EXCLUDE__)
        if vars_keys_from_fractorium is not None:
            vars_keys_from_fractorium_flatten: list[str] = [item for sublist in vars_keys_from_fractorium for item in sublist]
            if vars_keys_from_fractorium_flatten: __EXCLUDE__ += tuple(vars_keys_from_fractorium_flatten)
        vars_keys_from_fractorium_pre_pgb: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys_PP(apo_data.xforms, VARS_FRACTORIUM_DICT_PRE, xml_keys.DEFAULT_VAR_PRE_PRX, __EXCLUDE__)
        vars_keys_from_fractorium_pre: TA_STR_ListUnflattened | None = self.in_vars_keys_remove_pgb(vars_keys_from_fractorium_pre_pgb, pgb_name)
        if vars_keys_from_fractorium_pre is not None:
            vars_keys_from_fractorium_pre_flatten: list[str] = [item for sublist in vars_keys_from_fractorium_pre for item in sublist]
            if vars_keys_from_fractorium_pre_flatten: __EXCLUDE__ += tuple(vars_keys_from_fractorium_pre_flatten)
        vars_keys_from_fractorium_post: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys_PP(apo_data.xforms, VARS_FRACTORIUM_DICT_POST, xml_keys.DEFAULT_VAR_POST_PRX, __EXCLUDE__)
        
        # BUILD FF MISSING
        vars_keys_from_fractorium_FF = vars_keys_from_fractorium_pre_FF = vars_keys_from_fractorium_post_FF = [] # TA_STR_ListUnflattened
        if data_checks.ff_bool:
            __EXCLUDE__ = copy(XML_XF_KEY_EXCLUDE)
            vars_keys_from_fractorium_FF: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys(apo_data.finalxform, VARS_FRACTORIUM_DICT, __EXCLUDE__)
            if vars_keys_from_fractorium_FF is not None:
                vars_keys_from_fractorium_FF_flatten: list[str] = [item for sublist in vars_keys_from_fractorium_FF for item in sublist]
                if vars_keys_from_fractorium_FF_flatten: __EXCLUDE__ += tuple(vars_keys_from_fractorium_FF_flatten)
            vars_keys_from_fractorium_pre_FF: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys_PP(apo_data.finalxform, VARS_FRACTORIUM_DICT_PRE, xml_keys.DEFAULT_VAR_PRE_PRX, __EXCLUDE__)
            if vars_keys_from_fractorium_pre_FF is not None:
                vars_keys_from_fractorium_pre_FF_flatten: list[str] = [item for sublist in vars_keys_from_fractorium_pre_FF for item in sublist]
                if vars_keys_from_fractorium_pre_FF_flatten: __EXCLUDE__ += tuple(vars_keys_from_fractorium_pre_FF_flatten)
            vars_keys_from_fractorium_post_FF: TA_STR_ListUnflattened | None = self.in_get_xforms_var_keys_PP(apo_data.finalxform, VARS_FRACTORIUM_DICT_POST, xml_keys.DEFAULT_VAR_POST_PRX, __EXCLUDE__)
        
        # JOIN ITERATORS and FF PRE, VARS and POST
        vars_keys_from_fractorium_all: list[list[str]] = vars_keys_from_fractorium + vars_keys_from_fractorium_pre + vars_keys_from_fractorium_post + vars_keys_from_fractorium_pre_FF + vars_keys_from_fractorium_FF + vars_keys_from_fractorium_post_FF # type: ignore
        # Unique and sorted
        result_sorted_fractorium: list[str] = self.in_util_vars_flatten_unique_sorted(vars_keys_from_fractorium_all, self.in_util_make_NULL, True)
        # Build MISSING: Compare, keep and build
        vars_missing: list[str] = [x for x in result_sorted_fractorium if x not in vars_used]
        
        return vars_missing
    
    
    def in_load_vars_used_msg(self, vars_used: list[str], grp_num: int = 5) -> str:
        """Build the IN infos stats message for the used variations in the Flame preset we just loaded.</br>

        Args:
            (self):
            vars_used(list[str]): List of unique variation used in the Flame preset we just loaded.
            grp_num(int): All the collected variations will be formatted in groups of 5 for each line.

        Returns:
            (str): The string message to print into the IN infos stats for the loaded Flame preset.
        """   
        vars_used_heading: str = 'Variations used:'
        result_grp: TA_STR_ListUnflattened = [vars_used[i:i + grp_num] for i in range(0, len(vars_used), grp_num)]  
        vars_used_msg: str = f"{vars_used_heading} {int(len(vars_used))}\n{self.in_util_join_vars_grp(result_grp)}"
        
        return vars_used_msg
    
    
    def in_load_vars_missing_msg(self, vars_missing: list[str], grp_num: int = 5) -> str:
        """Build the IN infos stats message for the missing variations in the Flame preset we just loaded.</br>

        Args:
            (self):
            vars_missing(list[str]): List of unique variation missing in the Flame preset we just loaded.
            grp_num(int): All the collected variations will be formatted in groups of 5 for each line.

        Returns:
            (str): The string message to print into the IN infos stats for the loaded Flame preset.
        """   
        vars_missing_heading: str = 'MISSING:'
        __vars_missing_grp__: TA_STR_ListUnflattened = [vars_missing[i:i + grp_num] for i in range(0, len(vars_missing), grp_num)]
        if vars_missing: vars_missing_msg: str = f"{vars_missing_heading}\n{self.in_util_join_vars_grp(__vars_missing_grp__)}"
        else: vars_missing_msg: str = ''
        
        return vars_missing_msg
    
    
    def in_load_vars_unknown_msg(self, apo_data: in_flame_iter_data, preset_id: int, grp_num: int = 5) -> str:
        """Build the IN infos stats message for the unknown variations in the Flame preset we just loaded.</br>

        Args:
            (self):
            apo_data(in_flame_iter_data): The XML Flame file data for the preset we are loading in FLAM3H™.
            preset_id(int): The loaded XML Flame preset
            grp_num(int): All the collected variations will be formatted in groups of 5 for each line.

        Returns:
            (str): The string message to print into the IN infos stats for the loaded Flame preset.
        """   
        vars_unknown_heading: str = 'UNKNOWN:'
        __vars_unknown__: list[str] = in_flame_utils.in_load_stats_unknown_vars(preset_id, apo_data)
        if __vars_unknown__: vars_unknown_msg: str = f"{vars_unknown_heading}\n{self.in_util_join_vars_grp( [__vars_unknown__[i:i + grp_num] for i in range(0, len(__vars_unknown__), grp_num)] )}"
        else: vars_unknown_msg: str = ''
        
        return vars_unknown_msg


    def in_load_stats_msg(self, preset_id: int, apo_data: in_flame_iter_data, clipboard: bool, XML_last_update: bool = False) -> str:
        """Build a message with all the informations about the Flame preset we just loaded.</br>

        Args:
            (self):
            preset_id(int): The loaded XML Flame preset
            apo_data(in_flame_iter_data): The XML Flame file data for the preset we are loading in FLAM3H™.
            clipboard(bool): Is the cuurently loaded Flame preset coming from the Clipboard? True or False.
            XML_last_update(bool): Default to: False</br>If True and when a Flame preset is modified on disk while it is loaded into FLAM3H™</br>will add an asterisk(*) to the infos lines as an indicator we need to reload the Flame preset to fully update.

        Returns:
            (str): A string to be used to set the IN Flame info data parameter message.
        """     
        
        node: hou.SopNode = self.node
        
        # checks
        data_checks: in_flame_checks = in_flame_checks(apo_data)
         
        # spacers
        nl: str = "\n"
        nnl: str = "\n\n"
        
        # If the XML Flame preset is modified on disk while it is currently loaded inside FLAM3H™ an asterisk(*) will be added to each IN infos line as an indicator.
        XML_updated: str = ''
        if XML_last_update: XML_updated = '*'
        
        # I could hard-code the name into the function: def in_vars_keys_remove_pgb(...), but this way I keep this dict global for all purposes.
        pgb_name: str | list[str] | None = self.in_util_make_PRE(self.in_get_dict_key_from_value(VARS_FLAM3_DICT_IDX, 33))
        assert isinstance(pgb_name, str)
        
        # checks msgs
        opacity_bool_msg = post_bool_msg = xaos_bool_msg = ff_post_bool_msg = "NO"
        if data_checks.opacity_bool: opacity_bool_msg = "YES"
        if data_checks.post_bool: post_bool_msg = "YES"
        if data_checks.xaos_bool: xaos_bool_msg = "YES"
        if data_checks.ff_post_bool: ff_post_bool_msg = "YES"
        
        # build msgs
        sw: str = f"Software: {apo_data.sw_version[preset_id]}"
        name: str = f"Name: {apo_data.name[preset_id]}"
        assert apo_data.xforms is not None
        iter_count: str = f"Iterators count: {len(apo_data.xforms)}"
        post: str = f"Post affine: {post_bool_msg}"
        opacity: str = f"Opacity: {opacity_bool_msg}"
        xaos: str = f"Xaos: {xaos_bool_msg}"
        
        # Used VARS
        __vars_used__: list[str] = self.in_load_collect_vars(apo_data, data_checks, pgb_name)
        vars_used_msg: str = self.in_load_vars_used_msg(__vars_used__)

        # Missing VARS
        __vars_missing__: list[str] = self.in_load_collect_vars_missing(apo_data, data_checks, __vars_used__, pgb_name)
        vars_missing_msg: str = self.in_load_vars_missing_msg(__vars_missing__)
        
        # Build unknown MSG
        vars_unknown_msg: str = self.in_load_vars_unknown_msg(apo_data, preset_id)
        
        # CC - build data
        cc_overall: str | list = apo_data.out_curve_overall[preset_id]
        if not apo_data.out_curve_overall[preset_id]: cc_overall = xml_keys.DEFAULT_CC_CURVE
        cc_red: str | list = apo_data.out_curve_red[preset_id]
        if not apo_data.out_curve_red[preset_id]: cc_red = xml_keys.DEFAULT_CC_CURVE
        cc_green: str | list = apo_data.out_curve_green[preset_id]
        if not apo_data.out_curve_green[preset_id]: cc_green = xml_keys.DEFAULT_CC_CURVE
        cc_blue: str | list = apo_data.out_curve_blue[preset_id]
        if not apo_data.out_curve_green[preset_id]: cc_blue = xml_keys.DEFAULT_CC_CURVE
        # CC - check - The following are now guarantee to be of type: str
        assert isinstance(cc_overall, str)
        assert isinstance(cc_red, str)
        assert isinstance(cc_green, str)
        assert isinstance(cc_blue, str)
        # Compare
        if cc_overall.strip() in xml_keys.DEFAULT_CC_CURVE_ALL and cc_red.strip() in xml_keys.DEFAULT_CC_CURVE_ALL and cc_green.strip() in xml_keys.DEFAULT_CC_CURVE_ALL and cc_blue.strip() in xml_keys.DEFAULT_CC_CURVE_ALL:
            cc: str = ''
        else:
            cc: str = f"{XML_updated}CC"
        
        # MB (Motion blur)
        if data_checks.f3h_mb_bool:
            mb: str = f", {XML_updated}MB{nnl}" if cc else f"{XML_updated}MB{nnl}"
        else: mb: str = nnl
        
        if data_checks.ff_bool: ff_msg: str = f"{XML_updated}FF: YES\n{XML_updated}FF Post affine: {ff_post_bool_msg}"
        else: ff_msg: str = f"{XML_updated}FF: NO\n"
        
        if data_checks.palette_bool:
            if apo_data.cp_flam3h_hsv is not False: palette_count_format = f"Palette count: {apo_data.palette[1]}, format: {apo_data.palette[2]} {f3h_tabs.IN.DEFAULT_MSG_HSV_LABEL}, {f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES_BASES_DICT[apo_data.cp_flam3h_basis]}" # custom to FLAM3H™ only
            else: palette_count_format: str = f"Palette count: {apo_data.palette[1]}, format: {apo_data.palette[2]}, {f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES_BASES_DICT[apo_data.cp_flam3h_basis]}"
        else: palette_count_format: str = f"Palette not found."
        
        # Check if the loaded Flame file is locked.
        in_path: str = os.path.expandvars(node.parm(f3h_tabs.IN.PRM_PATH).eval())
        in_path_checked: str | bool = out_flame_utils.out_check_outpath(node, in_path, f3h_tabs.OUT.DEFAULT_FILE_EXT, f3h_tabs.OUT.DEFAULT_AUTO_NAME)
        if flam3h_general_utils.isLOCK(in_path_checked): flame_lib_locked = f3h_tabs.IN.DEFAULT_MSG_FLAMESTATS_LOCK
        else: flame_lib_locked = ''
        
        # Build and set descriptive parameter msg
        if clipboard: preset_name: str = apo_data.name[0]
        else: preset_name: str = apo_data.name[preset_id]   # Get the correct menu parameter's preset menu label
                                                            # The apo_data.name[idx] is used for the descriptive parameter
                                                            # so to not print the icon path into the name.
        descriptive_prm: tuple[str, ...] = ( f"{XML_updated}sw: {apo_data.sw_version[preset_id]}\n", f"{XML_updated}{out_flame_utils.out_remove_iter_num(preset_name)}",)
        node.parm(f3h_tabs.PRM_DESCRIPTIVE).set(''.join(descriptive_prm))
        
        # If the Flame use a 256+ palette, update the CP palette MSG
        if apo_data.palette is not None and apo_data.palette[1] > 256:
            palette_msg: str = node.parm(f3h_tabs.CP.MSG_PRM_PALETTE).eval()
            if f3h_tabs.CP.DEFAULT_MSG_PLUS in palette_msg:
                pass
            else:
                node.parm(f3h_tabs.CP.MSG_PRM_PALETTE).set(f"{f3h_tabs.CP.DEFAULT_MSG_PLUS.strip()} {palette_msg.strip()}")
        
        # build full stats msg
        build: tuple[str, ...] = (
                                    flame_lib_locked, nl, 
                                    XML_updated, sw, nl, 
                                    XML_updated, name, nnl, 
                                    XML_updated, palette_count_format, nl, 
                                    cc, mb, 
                                    XML_updated, iter_count, nl, 
                                    XML_updated, post, nl, 
                                    XML_updated, opacity, nl, 
                                    XML_updated, xaos, nl, 
                                    XML_updated, ff_msg, nnl, 
                                    XML_updated, vars_used_msg, nnl if vars_missing_msg else '', 
                                    XML_updated if vars_missing_msg else '', vars_missing_msg, nnl if vars_unknown_msg else '', 
                                    XML_updated if vars_unknown_msg else '', vars_unknown_msg
                                )

        return ''.join(build)


    def menu_in_presets_data(self, node: hou.SopNode, xml_file_path: str, xml_is_file: bool) -> TA_Menu:
        """Populate the IN menu parameters with entries based on the loaded IN XML Flame file.</br>
        When a flame preset is loaded. This will use the blue star icon to signal wich preset is currently loaded.</br>

        Note:
            If you change the icon gobal variable name inside here,
            remember to updated with the same global variable names inside:</br>in_flame_utils.in_presets_in_isvalid_file_menu_label(...)

        Args:
            (self):
            node(hou.SopNode): this FLAM3H™ node
            xml_file_path(str): the IN_PATH parameter string.
            xml_is_valid(bool): wether the xml_file_path file is an existing file. True or False

        Returns:
            (TA_Menu): the actual menu
        """
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore

            _is_valid_file: bool = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_FILE).eval()
            _is_valid_preset: bool = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval()
            _xml_tree_obj: _xml_tree = _xml_tree(xml_file_path)
            
            if _xml_tree_obj.isvalidtree and _is_valid_file and _is_valid_preset:
                
                in_idx: int = int(node.parm(f3h_tabs.IN.PRM_PRESETS).eval())
                is_clipboard: int = node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval()
                
                enum: bool = node.parm(f3h_tabs.PREFS.PRM_ENUMERATE_MENU).eval()
                _menu_func: Callable[[hou.SopNode, TA_Menu, int, str | list[Never], int, int], None] = (self.menu_in_presets_loop_enum if enum else self.menu_in_presets_loop)
                
                menu: TA_Menu = []
                preset_names: tuple[str | list[Never], ...] = _xml_tree_obj.get_name()
                for i, item in enumerate(preset_names):
                    _menu_func(node, menu, i, item, in_idx, is_clipboard)
                        
                node.setCachedUserData(f3h_cachedUserData.in_presets_menu, menu)
                return menu
            
            flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.in_presets_menu)
            if not xml_is_file:
                return f3h_menus.PRESETS_INVALID
            
            return f3h_menus.PRESETS_EMPTY

            
    def menu_in_presets(self) -> TA_Menu:
        """Rerturn either a cached menu data or rebuild that data on the fly if needed.</br>

        Args:
            (self):
            
        Returns:
            (TA_Menu): Return a menu
        """
        node: hou.SopNode = self.node
        if hou.isUIAvailable() is False: node.updateParmStates()
        
        # quick return
        if self.kwargs['parm'].isHidden():
            return [] # f3h_menus.PRESETS_EMPTY_HIDDEN
        
        # Cache parm reads
        in_path: str = node.parm(f3h_tabs.IN.PRM_PATH).eval()
        iter_count: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        clipboard_toggle: int = node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval()
        
        if iter_count and not in_path:
            if node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval() and clipboard_toggle:
                return f3h_menus.IN_PRESETS_EMPTY_CB
            return f3h_menus.PRESETS_EMPTY
        
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            data: TA_Menu | None = node.cachedUserData(f3h_cachedUserData.in_presets_menu)
            data_idx: str | None = node.cachedUserData(f3h_cachedUserData.in_presets_menu_idx)
            preset_idx: str = node.parm(f3h_tabs.IN.PRM_PRESETS).eval()
            
            # Double check - expand only if path is non-empty
            xml_file_path: str = os.path.expandvars(in_path) if in_path else ''
            xml_is_file: bool = os.path.isfile(xml_file_path) if xml_file_path else False
                
            if not xml_is_file:
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_FILE, 0)
                if not clipboard_toggle: flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_PRESET, 0)
                data = None
                
            else:
                # This caused some pain becasue it is forcing us not to tell the truth sometime
                # but its quick and we added double checks for each file types (Palette or Flame) inside each menus empty presets (CP, IN and OUT)
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_FILE, 1)
                
            if data is not None and data_idx == preset_idx:
                return data
            
            return self.menu_in_presets_data(node, xml_file_path, xml_is_file)
        

    def menu_in_presets_empty_data(self, node: hou.SopNode, xml_file_path: str, xml_is_valid: bool) -> TA_Menu:
        """Populate the IN menu parameters with entries based on the loaded IN XML Flame file.</br>
        When no flame preset has been loaded. This will use the empty star icon to signal wich preset is being selected but not loaded.</br>

        This definition exist only becasue if I change the icon dynamically inside:
        * def menu_in_presets(self) -> TA_Menu:
        
        Houdini will mix them up sometime, giving inconsistent results until I perform a new selection from the menu labels list.

        Note:
            If you change the icon gobal variable name inside here,
            remember to updated with the same global variable names inside: in_flame_utils.in_presets_in_isvalid_file_menu_label(...)

        Args:
            (self):
            node(hou.SopNode): this FLAM3H™ node
            xml_file_path(str): the IN_PATH parameter string.
            xml_is_valid(bool): wether the xml_file_path file is an existing file. True or False

        Returns:
            (TA_Menu): the actual menu
        """
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore

            _is_valid_file: bool = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_FILE).eval()
            _is_valid_preset: bool = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval()
            _xml_tree_obj: _xml_tree = _xml_tree(xml_file_path)
            
            if _xml_tree_obj.isvalidtree and _is_valid_file and not _is_valid_preset:
                    
                enum: bool = node.parm(f3h_tabs.PREFS.PRM_ENUMERATE_MENU).eval()
                _menu_func: Callable[[hou.SopNode, TA_Menu, int, str | list[Never]], None] = (self.menu_in_presets_empty_loop_enum if enum else self.menu_in_presets_empty_loop)
                
                menu: TA_Menu = []
                preset_names: tuple[str | list[Never], ...] = _xml_tree_obj.get_name()
                for i, item in enumerate(preset_names):
                    _menu_func(node, menu, i, item)
                    
                node.setCachedUserData(f3h_cachedUserData.in_presets_menu_off, menu)
                return menu
                
            else:
                if node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval() and node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval():
                    if not xml_is_valid:
                        return f3h_menus.PRESETS_INVALID_CB
                    
                    return f3h_menus.IN_PRESETS_EMPTY_CB
                        
            flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.in_presets_menu_off)
            if node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval():
                if not xml_is_valid:
                    return f3h_menus.PRESETS_INVALID
                
                return f3h_menus.PRESETS_EMPTY
            
            if xml_file_path and not xml_is_valid:
                return f3h_menus.ZERO_ITERATORS_PRESETS_INVALID
            
            return f3h_menus.ZERO_ITERATORS

            
    def menu_in_presets_empty(self) -> TA_Menu:
        """Rerturn either a cached menu data or rebuild that data on the fly if needed.</br>

        Args:
            (self):
            
        Returns:
            (TA_Menu): Return a menu
        """
        node: hou.SopNode = self.node
        if hou.isUIAvailable() is False: node.updateParmStates()
        
        # quick return
        if self.kwargs['parm'].isHidden():
            return [] # f3h_menus.PRESETS_EMPTY_HIDDEN
        
        # Cache parm reads
        in_path: str = node.parm(f3h_tabs.IN.PRM_PATH).eval()
        iter_count: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        is_valid_preset: int = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval()
        clipboard_toggle: int = node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval()
        
        if iter_count and not in_path:
            if is_valid_preset and clipboard_toggle:
                return f3h_menus.IN_PRESETS_EMPTY_CB
            return f3h_menus.PRESETS_EMPTY
        
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            data: TA_Menu | None = node.cachedUserData(f3h_cachedUserData.in_presets_menu_off)
            data_idx: str | None = node.cachedUserData(f3h_cachedUserData.in_presets_menu_off_idx)
            preset_idx: str = node.parm(f3h_tabs.IN.PRM_PRESETS_OFF).eval()
            
            # Double check 
            xml_file_path: str = os.path.expandvars(in_path) if in_path else ''
            xml_is_valid: bool = os.path.isfile(xml_file_path) if xml_file_path else False
                
            if not xml_is_valid:
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_FILE, 0)
                if not clipboard_toggle: flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_PRESET, 0)
                data = None
                
            else:
                if not clipboard_toggle: # to double check
                    # This caused some pain becasue it is forcing us not to tell the truth sometime
                    # but its quick and we added double checks for each file types (Palette or Flame) inside each menus empty presets (CP, IN and OUT)
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_FILE, 1)
                
            if data is not None and data_idx == preset_idx:
                return data
            
            return self.menu_in_presets_empty_data(node, xml_file_path, xml_is_valid)
        
        
    def set_iter_on_load_callback(self) -> None:
        """Set the iteration number based on the "iteration on load" number.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        iter_on_load: int = self.node.parm(f3h_tabs.IN.PRM_ITER_NUM_ON_LOAD).eval()
        flam3h_prm_utils.set(self.node, f3h_tabs.GLB.PRM_ITERATIONS, iter_on_load)
        
        # update Flame preset name if any
        out_flame_utils(self.kwargs).out_auto_change_iter_num_to_prm()
        
        
    def use_iter_on_load_callback(self) -> None:
        """When the IN tab "force iterations on Load" option is turned ON it will set the initial iteration number wisely.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        useiteronload: int = node.parm(f3h_tabs.IN.PRM_USE_ITER_ON_LOAD).eval()
        if useiteronload:
            
            prm_iter_num_on_load = node.parm(f3h_tabs.IN.PRM_ITER_NUM_ON_LOAD)
            iternumonload: int = prm_iter_num_on_load.eval()
            iter: int = node.parm(f3h_tabs.GLB.PRM_ITERATIONS).eval()
            if iternumonload == iter:
                pass
            
            elif iternumonload > iter:
                flam3h_prm_utils.set(node, prm_iter_num_on_load, iter)
                
            else:
                flam3h_prm_utils.set(node, prm_iter_num_on_load, iternumonload)
                # update Flame preset name if any
                out_flame_utils(self.kwargs).out_auto_change_iter_num_to_prm()


    def in_to_flam3h_toggle(self, prm: str) -> None:
        """Given a FLAM3H™ parameter name, toggle it ON or OFF and reload the currently selected flame preset right after.</br>

        Args:
            prm(str): The strin parameter name (toggle parameter) we desire to switch either ON or OFF before reloading the selected flame preset.
            
        Returns:
            (None)
        """
        xml: str = self.node.parm(f3h_tabs.IN.PRM_PATH).eval()
        # Here we could take a shortcut and use: if node.parm(f3h_tabs.IN.PVT_ISVALID_FILE).eval(): instead,
        # but for now we keep it safe and use the class: _xml_tree(..) instead.
        if _xml_tree(xml).isvalidtree:
            flam3h_general_utils(self.kwargs).flam3h_toggle(prm)
            self.in_to_flam3h()
        else:
            _MSG: str = f"{self.node.name()}: {prm.upper()}: No valid flame file to load the flame from, load a valid flame file first."
            flam3h_general_utils.set_status_msg(_MSG, 'WARN')
            

    def in_to_flam3h_toggle_f3h_affine(self) -> None:
        """When loading a flame preset that use F3H affine style, this function will reload it</br>
        and switch the "F3H affine style" toggle ON/OFF on the fly.</br></br>
        
        If no F3H affine style are present in the currently selected flame preset,</br>
        nothing will happen and a status bar warning message will let the user know about it.
        
        Args:
            (self):
            
        Returns:
            (None):
        """ 
        node: hou.SopNode = self.node
        xml, clipboard, preset_id, flame_name_clipboard, load_from_clipboard, chaos = self.in_to_flam3h_init_data(node)
        
        # Here we are forced to use the class: _xml_tree(...) becasue a Flame can come from the clipboard
        # and we need to carefully validate it before proceding.
        if xml is not None and _xml_tree(xml).isvalidtree:
            
            apo_data: in_flame_iter_data = in_flame_iter_data(node, xml, preset_id)
            if apo_data.f3h_coefs is not None or apo_data.f3h_post is not None or apo_data.finalxform_f3h_coefs is not None or apo_data.finalxform_f3h_post:
                flam3h_general_utils(self.kwargs).flam3h_toggle(f3h_tabs.IN.PRM_FLAM3H_AFFINE_STYLE)
                self.in_to_flam3h()
                
            else:
                if clipboard:
                    _MSG: str = f"{node.name()}: Reload of preset: \"{out_flame_utils.out_remove_iter_num(flame_name_clipboard)}\" from Clipboard -> SKIPPED. The flame preset stored into the Clipboard do not have F3H affine style."
                    flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                else:
                    # Get the correct menu parameter's preset menu label
                    preset_name = in_flame_utils.in_presets_in_isvalid_file_menu_label(node, preset_id)
                        
                    _MSG: str = f"{node.name()}: Reload of preset: \"{out_flame_utils.out_remove_iter_num(preset_name)}\" -> SKIPPED. The currently selected flame preset do not have F3H affine style."
                    flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                
        else:
            if load_from_clipboard:
                _MSG: str = f"{node.name()}: No valid flame preset to load from the Clipboard, copy a valid flame to the Clipboard first or load from a valid flame file instead."
            else:
                if chaos:
                    _MSG: str = f"IN: Chaotica XML not supported"
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                    flam3h_general_utils.flash_message(node, _MSG)
                else:
                    _MSG: str = f"{node.name()}: No valid flame file to load the flame from, load a valid flame file first."
            flam3h_general_utils.set_status_msg(_MSG, 'WARN')
            

    def in_to_flam3h_reset_user_data(self) -> None:
        """Every time we load a flame preset, this definition will reset all FLAM3H™ data</br>
        so not to clash or cause conflict with the new data generated by the new loaded flame preset.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        # lets initialize those to default values in case their data no longer exist.
        flam3h_iterator_utils.flam3h_init_hou_session_iterator_data(node)
        flam3h_iterator_utils.flam3h_init_hou_session_ff_data(node)
        
        # Reset iterator user data if needed
        from_FLAM3H_NODE: TA_MNode = hou.session.F3H_MARKED_ITERATOR_NODE # type: ignore
        if from_FLAM3H_NODE is not None and node == from_FLAM3H_NODE:
            if flam3h_iterator_utils.exist_user_data(from_FLAM3H_NODE):
                flam3h_iterator_utils.del_comment_and_user_data_iterator(from_FLAM3H_NODE)
                hou.session.F3H_MARKED_ITERATOR_MP_IDX: TA_M = None # type: ignore
        
        # Reset mp idx FLAM3H™ mem parameter
        if node.parm(f3h_tabs.PREFS.PVT_PRM_DATA_PRM_MPIDX).eval() != 0:
            flam3h_iterator_utils.iterator_mpidx_mem_set(node, 0)
        
        # Reset FF user data if needed
        from_FLAM3H_NODE: TA_MNode = hou.session.F3H_MARKED_FF_NODE # type: ignore
        if from_FLAM3H_NODE is not None and node == from_FLAM3H_NODE:
            if flam3h_iterator_utils.exist_user_data(from_FLAM3H_NODE, f3h_userData.MARKED_FF):
                flam3h_iterator_utils.del_comment_and_user_data_iterator(from_FLAM3H_NODE, f3h_userData.MARKED_FF)
                hou.session.F3H_MARKED_FF_CHECK: TA_M = None # type: ignore


    def in_to_flam3h_reset_iterators_parms(self, node: hou.SopNode, in_flame_iter_count: int) -> None:
        """Prior to this, I was setting the iterator's count to zero and then back to the requested count to reset all their values.</br>
        It was not the fastest solution and this is actually making it more performant overall.</br>

        Args:
            (self):
            node(hou.SopNode): This FLAM3H™ node
            in_flame_iter_count(int): IN flame iterator's count ( number of xforms )

        Returns:
            (None):
        """
        # iterators count
        flam3h_iter_count_prm = node.parm(f3h_tabs.PRM_ITERATORS_COUNT)
        flam3h_iter_count: int = flam3h_iter_count_prm.eval()
        
        for p in node.parms():
            if p.name() in f3h_pvt.PVT_ALL:
                p.lock(False)
                p.deleteAllKeyframes()
                p.lock(True)
                
            else:
                p.lock(False)
                p.deleteAllKeyframes()
                    
            if p.isMultiParmInstance():
                p.revertToDefaults()
            
        if in_flame_iter_count > flam3h_iter_count:
            flam3h_iter_count_prm.set(in_flame_iter_count)

        elif in_flame_iter_count == flam3h_iter_count:
            pass

        else:
            flam3h_iter_count_prm.set(in_flame_iter_count)


    def in_to_flam3h_resets(self, node: hou.SopNode, _FLAM3H_INIT_DATA: TA_F3H_Init) -> None:
        """Reset the FLAM3H™ UI parameters to welcome the new one from the XML Flame preset we are loading.</br>
        
        Args:
            (self):
            node(hou.SopNode): FLAM3H™ node to load the flame file/preset into.
            _FLAM3H_INIT_DATA(TA_F3H_Init): tuple(  xml, 
                                                    clipboard, 
                                                    preset_id, 
                                                    clipboard_flame_name, 
                                                    attempt_to_load_from_clipboard, 
                                                    chaos
                                                    )
                                                
                                                    * xml ( str | None ): either a flame preset from a flame file or from the Clipboard.
                                                    * clipboard ( bool ): did we get a valid flame preset from the clipboard ? True or False.
                                                    * preset_id ( int ): flame preset index. From clipboard will always be ZERO.
                                                    * clipboard_flame_name ( str ): If a valid flame preset from the clipboard is loaded, this will store the preset name of it.
                                                    * attempt_to_load_from_clipboard ( bool ): Did we try to load flame preset from the clipboard ? True or False.
                                                    * chaos ( bool ): Is it a chaotica XML file type ? True or False.

        Returns:
            (None):
        """
        xml, clipboard, preset_id, flame_name_clipboard, attempt_from_clipboard, chaos = _FLAM3H_INIT_DATA
        
        iter_on_load: int = in_flame_utils.in_set_iter_on_load(node, preset_id, clipboard, flame_name_clipboard)
        flam3h_general_utils(self.kwargs).reset_SYS(1, iter_on_load, 0)
        flam3h_general_utils(self.kwargs).reset_MB()
        flam3h_general_utils(self.kwargs).reset_PREFS()


    def in_to_flam3h_set_iterators(self, node: hou.SopNode, apo_data: in_flame_iter_data, _FLAM3H_INIT_DATA: TA_F3H_Init) -> None:
        """Set the iterators data (FLAME or FF tab) into FLAM3H™ from the loaded XML Flame preset.</br>
        
        Args:
            (self):
            node(hou.SopNode): FLAM3H™ node to load the flame file/preset into.
            apo_data(in_flame_iter_data): All the XML data from the loaded Flame preset.
            _FLAM3H_INIT_DATA(TA_F3H_Init): tuple(  xml, 
                                                    clipboard, 
                                                    preset_id, 
                                                    clipboard_flame_name, 
                                                    attempt_to_load_from_clipboard, 
                                                    chaos
                                                    )
                                                    
                                                    * xml ( str | None ): either a flame preset from a flame file or from the Clipboard.
                                                    * clipboard ( bool ): did we get a valid flame preset from the clipboard ? True or False.
                                                    * preset_id ( int ): flame preset index. From clipboard will always be ZERO.
                                                    * clipboard_flame_name ( str ): If a valid flame preset from the clipboard is loaded, this will store the preset name of it.
                                                    * attempt_to_load_from_clipboard ( bool ): Did we try to load flame preset from the clipboard ? True or False.
                                                    * chaos ( bool ): Is it a chaotica XML file type ? True or False.

        Returns:
            (None):
        """
        xml, clipboard, preset_id, flame_name_clipboard, attempt_from_clipboard, chaos = _FLAM3H_INIT_DATA
        
        # ITERATOR
        ####################################################
        # prepare iterators
        assert apo_data.xforms is not None
        self.in_to_flam3h_reset_iterators_parms( node, len(apo_data.xforms) )
        
        # RIP: if there are ZERO opacities, always turn RIP toggle ON
        if apo_data.opacity is not None and min(apo_data.opacity) == 0.0:
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_RIP, 1)
            
        else:
            # Otherwise set RIP toggle accordingly from the XML data if any
            if apo_data.sys_flam3h_rip is not None:
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_RIP, apo_data.sys_flam3h_rip)
            else:
                # Otherwise always turn it OFF
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_RIP, 0)

        # Set iterators
        self.in_flam3h_set_iterators(0, node, apo_data, preset_id)
        
        # FF
        ####################################################
        flam3h_iterator_utils(self.kwargs).flam3h_reset_FF()
        if apo_data.finalxform is not None:
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_DOFF, 1)
            self.in_flam3h_set_iterators(1, node, apo_data, preset_id)
        else:
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_DOFF, 0)

        # Disable post affine if they are at default values (iterators and FF)
        # This should not be needed because the post affine are not added to the XML flame preset when at default values
        # But just in case some third-party app will include them anyway.
        if apo_data.post is not None or apo_data.finalxform_post is not None: flam3h_scripts(self.kwargs).is_post_affine_default_on_load(node)


    def in_to_flam3h_set_motion_blur(self, node: hou.SopNode, apo_data: in_flame_iter_data) -> None:
        """Set the Motion Blur data into FLAM3H™ from the loaded XML Flame preset.</br>
        
        Args:
            (self):
            node(hou.SopNode): FLAM3H™ node to load the flame file/preset into.
            apo_data(in_flame_iter_data): All the XML data from the loaded Flame preset.

        Returns:
            (None):
        """ 
        if apo_data.mb_flam3h_fps is not False:
            
            parms_mb_dict: dict[str, int | float] = {f3h_tabs.MB.PRM_DO: 1,
                                                    f3h_tabs.MB.PRM_FPS: apo_data.mb_flam3h_fps,
                                                    f3h_tabs.MB.PRM_SAMPLES: apo_data.mb_flam3h_samples,
                                                    f3h_tabs.MB.PRM_SHUTTER: apo_data.mb_flam3h_shutter
                                                    }
            flam3h_prm_utils.setParms(node, parms_mb_dict)
            
        else:
            flam3h_general_utils(self.kwargs).reset_MB()
            

    def in_to_flam3h_set_palette(self, node: hou.SopNode, apo_data: in_flame_iter_data, _FLAM3H_INIT_DATA: TA_F3H_Init, flashmessage: bool = False) -> bool:
        """Set the Palette data into FLAM3H™ from the loaded XML Flame preset.</br>
        
        Args:
            (self):
            node(hou.SopNode): FLAM3H™ node to load the flame file/preset into.
            apo_data(in_flame_iter_data): All the XML data from the loaded Flame preset.
            _FLAM3H_INIT_DATA(TA_F3H_Init): tuple(  xml, 
                                                    clipboard, 
                                                    preset_id, 
                                                    clipboard_flame_name, 
                                                    attempt_to_load_from_clipboard, 
                                                    chaos
                                                    )

                                                    * xml ( str | None ): either a flame preset from a flame file or from the Clipboard.
                                                    * clipboard ( bool ): did we get a valid flame preset from the clipboard ? True or False.
                                                    * preset_id ( int ): flame preset index. From clipboard will always be ZERO.
                                                    * clipboard_flame_name ( str ): If a valid flame preset from the clipboard is loaded, this will store the preset name of it.
                                                    * attempt_to_load_from_clipboard ( bool ): Did we try to load flame preset from the clipboard ? True or False.
                                                    * chaos ( bool ): Is it a chaotica XML file type ? True or False.
            flashmessage(bool): Default to: False</br>if True, it will fire a flash and status message instead of a print message to the console.</br>To be used when loading Palette data from the clipboard from a Flame preset.

        Returns:
            (bool): True if all goes well. False if the loaded palette fail, most likely due to wrong HEX values in it.
        """ 
        xml, clipboard, preset_id, flame_name_clipboard, attempt_from_clipboard, chaos = _FLAM3H_INIT_DATA
        ramp_parm = node.parm(f3h_tabs.CP.PRM_RAMP_SRC_NAME)
        ramp_parm.lock(False)
        
        if apo_data.palette is not None:
            
            # if CP HSV vals
            # in theory I should not need to use: flam3h_prm_utils.set() definition
            # But since I can copy a a palette from a Flame file (from Clipboard) we need to force the unlock and delete keyframes anyways in that case.
            prm_hsv = node.parmTuple(f3h_tabs.CP.PRM_RAMP_HSV_VAL_NAME)
            if apo_data.cp_flam3h_hsv is not False:
                flam3h_prm_utils.set(node, prm_hsv, apo_data.cp_flam3h_hsv)
            else:
                flam3h_prm_utils.set(node, prm_hsv, hou.Vector3((1.0, 1.0, 1.0)))
            
            # Set XML palette data
            
            # Reset ramps to default
            flam3h_palette_utils.build_ramp_palette_default(ramp_parm)
            flam3h_palette_utils.delete_ramp_all_keyframes(ramp_parm)
            flam3h_palette_utils.delete_ramp_all_keyframes(node.parm(f3h_tabs.CP.PRM_RAMP_HSV_NAME))
            ramp_parm.set(apo_data.palette[0])
            flam3h_palette_utils(self.kwargs).palette_cp()
            # Set palette lookup samples and basis
            parms_dict: dict = {f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES: apo_data.cp_flam3h_samples, 
                                f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES_BASES: apo_data.cp_flam3h_basis}
            flam3h_prm_utils.setParms(node, parms_dict)

            # Mark this as not a loaded palette preset
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.CP.PVT_PRM_ISVALID_PRESET, 0)
            # reset tmp ramp palette
            flam3h_palette_utils(self.kwargs).reset_CP_TMP()
            
            return True
            
        _BASEs, _POSs, _COLORs = flam3h_palette_utils.build_ramp_palette_error()
        ramp_parm.set(hou.Ramp(_BASEs, _POSs, _COLORs))
        
        if attempt_from_clipboard: _MSG = f"CP ERROR from the Clipboard"
        else: _MSG = f"CP ERROR"
        if flashmessage:
            flam3h_general_utils.flash_message(node, _MSG)
            
        # This always
        _FULL_MSG = f"{node.name()}: {_MSG}. The loaded Palette data has invalid HEX values."
        flam3h_general_utils.set_status_msg(_FULL_MSG, "WARN")
        print(_FULL_MSG)
            
        # Now that I do have proper exception handling in place this else statement is not needed anymore.
        # I leave it here for now just in case I decide to print anything else.
        
        '''
        else:
            if attempt_from_clipboard: _MSG: str = "\nFlame IN Clipboard: The loaded Flame preset's Palette has invalid HEX values."
            else: _MSG: str = "\nFlame IN: The loaded Flame preset's Palette has invalid HEX values."
            # A print() is being used here becasue otherwise
            # it will be cleared out by other status bar messages down the line when loading a Flame preset
            print(f"Warning:\n{node.name()}: {_MSG}\n")
        '''
            
        return False
            
            
    def in_to_flam3h_stats_and_properties(self, node: hou.SopNode, apo_data: in_flame_iter_data, _FLAM3H_INIT_DATA: TA_F3H_Init, copy_only: bool = False) -> None:
        """Set all the loaded Flame preset stats/infos and copy its render properties if needed into the OUT tab.</br>
        
        Args:
            (self):
            node(hou.SopNode): FLAM3H™ node to load the flame file/preset into.
            apo_data(in_flame_iter_data): All the XML data from the loaded Flame preset.
            _FLAM3H_INIT_DATA(TA_F3H_Init): tuple(  xml, 
                                                    clipboard, 
                                                    preset_id, 
                                                    clipboard_flame_name, 
                                                    attempt_to_load_from_clipboard, 
                                                    chaos
                                                    )
                                                    
                                                    * xml ( str | None ): either a flame preset from a flame file or from the Clipboard.
                                                    * clipboard ( bool ): did we get a valid flame preset from the clipboard ? True or False.
                                                    * preset_id ( int ): flame preset index. From clipboard will always be ZERO.
                                                    * clipboard_flame_name ( str ): If a valid flame preset from the clipboard is loaded, this will store the preset name of it.
                                                    * attempt_to_load_from_clipboard ( bool ): Did we try to load flame preset from the clipboard ? True or False.
                                                    * chaos ( bool ): Is it a chaotica XML file type ? True or False.
                                                                                                
            copy_only (bool): Default to: False</br>This is used to distinguish a Flame preset coming in from the Clipboard only for the Render Properties copy/paste. 

        Returns:
            (None):
        """ 
        xml, clipboard, preset_id, flame_name_clipboard, attempt_from_clipboard, chaos = _FLAM3H_INIT_DATA
        
        # This for when we are loading a Flame preset in full
        if copy_only is False:
            # We are not using: def flam3h_prm_utils.setParms()
            # because those parameters have been already unlocked and cleared of their keyframes if any already
            
            # Update flame stats
            node.setParms(  # type: ignore
                            {f3h_tabs.IN.MSG_PRM_FLAMESTATS: self.in_load_stats_msg(preset_id, apo_data, clipboard), 
                            f3h_tabs.IN.MSG_PRM_FLAMESENSOR: self.in_load_sensor_stats_msg(preset_id, apo_data), 
                            f3h_tabs.IN.MSG_PRM_FLAMERENDER: self.in_load_render_stats_msg(preset_id, apo_data)}
                            )
            
            # if we are loading from the clipboard, always copy the render settings on load
            if clipboard: self.in_copy_render_all_stats_msg(self.kwargs, apo_data, clipboard)
            else:
                # We are not using: def flam3h_prm_utils.setParms()
                # because those parameters have been already unlocked and cleared of their keyframes if any already
                
                # If not from clipboard
                # Update SYS inpresets parameters
                node.setParms(  # type: ignore
                                {f3h_tabs.IN.PRM_SYS_PRESETS: str(preset_id), 
                                f3h_tabs.IN.PRM_SYS_PRESETS_OFF: str(preset_id)}
                                )
                
                # if "copy render properties on Load" is checked
                if node.parm(f3h_tabs.IN.PRM_COPY_RENDER_PROPERTIES_ON_LOAD).eval():
                    self.in_copy_render_all_stats_msg(self.kwargs, apo_data, clipboard)
                    
        # And this when we are loading a Flame preset from the Clipboard to only copy its Render properties
        else:
            # if we are loading from the clipboard (in this case we always are), copy all the Render Properties
            if clipboard: self.in_copy_render_all_stats_msg(self.kwargs, apo_data, clipboard)
            

    def in_to_flam3h_toggles_and_msg(self, node: hou.SopNode, apo_data: in_flame_iter_data, _FLAM3H_INIT_DATA: TA_F3H_Init) -> None:
        """Set all the toggles about file and preset validity.
        
        Args:
            (self):
            node(hou.SopNode): FLAM3H™ node to load the flame file/preset into.
            apo_data(in_flame_iter_data): All the XML data from the loaded Flame preset.
            _FLAM3H_INIT_DATA(TA_F3H_Init): tuple(  xml, 
                                                    clipboard, 
                                                    preset_id, 
                                                    clipboard_flame_name, 
                                                    attempt_to_load_from_clipboard, 
                                                    chaos
                                                    )
                                                    
                                                    * xml ( str | None ): either a flame preset from a flame file or from the Clipboard.
                                                    * clipboard ( bool ): did we get a valid flame preset from the clipboard ? True or False.
                                                    * preset_id ( int ): flame preset index. From clipboard will always be ZERO.
                                                    * clipboard_flame_name ( str ): If a valid flame preset from the clipboard is loaded, this will store the preset name of it.
                                                    * attempt_to_load_from_clipboard ( bool ): Did we try to load flame preset from the clipboard ? True or False.
                                                    * chaos ( bool ): Is it a chaotica XML file type ? True or False.

        Returns:
            (None):
        """ 
        
        xml, clipboard, preset_id, flame_name_clipboard, attempt_from_clipboard, chaos = _FLAM3H_INIT_DATA
        
        if clipboard:
            # If it is a valid preset from the clipboard, set the "valid preset" and "clipboard" toggles
            # but do not change the "is valid file" toggle as we dnt know if a valid file is already loaded.
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_PRESET, 1)
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE, 1)
            
            preset_name: str = flame_name_clipboard
            _MSG: str = f"{node.name()}: LOAD Flame preset from Clipboard: \"{out_flame_utils.out_remove_iter_num(preset_name)}\" -> Completed"
        else:
            # Otherwise mean the preset is coming from a file,
            # set all of them and uncheck the clipboard toggle just in case.
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_FILE, 1)
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_PRESET, 1)
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE, 0)
            
            # Get the correct menu parameter's preset menu label
            preset_name: str = apo_data.name[preset_id]
            _MSG: str = f"{node.name()}: LOAD Flame preset: \"{out_flame_utils.out_remove_iter_num(preset_name)}\" -> Completed"
            
        flam3h_general_utils.set_status_msg(_MSG, 'IMP')
        flam3h_general_utils.flash_message(node, f"{preset_name}")


    def in_to_flam3h_init_data_ALT(self) -> TA_F3H_Init:
        """Load a flame preset from the clipboard.</br>
        This definition will be used inside: 
        * def in_to_flam3h_init_data(self, node: hou.SopNode) -> TA_F3H_Init:
        
        It will also output some data to be used inside: def in_to_flam3h(self) -> None:

        Args:
            (self):

        Returns:
            (TA_F3H_Init): tuple(xml, 
                                 clipboard, 
                                 preset_id, 
                                 clipboard_flame_name, 
                                 attempt_to_load_from_clipboard, 
                                 chaos
                                 )

                                 * xml ( str | None ): either a flame preset from a flame file or from the Clipboard.
                                 * clipboard ( bool ): did we get a valid flame preset from the clipboard ? True or False.
                                 * preset_id ( int ): flame preset index. From clipboard will always be ZERO.
                                 * clipboard_flame_name ( str ): If a valid flame preset from the clipboard is loaded, this will store the preset name of it.
                                 * attempt_to_load_from_clipboard ( bool ): Did we try to load flame preset from the clipboard ? True or False.
                                 * chaos ( bool ): Is it a chaotica XML file type ? True or False.
        """     
        xml: str = hou.ui.getTextFromClipboard() # type: ignore
        
        try:
            tree: lxmlET._ElementTree = lxmlET.ElementTree(lxmlET.fromstring(xml))
            
        except ValueError:
            return None, False, 0, '', True, False
        
        except lxmlET.XMLSyntaxError:
            return None, False, 0, '', True, False
        
        assert xml is not None
        if any(True for _ in tree.getroot().iter(xml_keys.XML_NAME)):
            flame_name_clipboard: str = _xml_tree(xml).name[0]
            return xml, True, 0, flame_name_clipboard, True, False
        
        if self.in_to_flam3h_is_CHAOS(xml):
            return None, False, 0, '', True, True
        
        return None, False, 0, '', True, False


    def in_to_flam3h_init_data_SHIFT(self, node: hou.SopNode) -> TA_F3H_Init:
        """Load a flame file from a file dialog.</br>
        This definition will be used inside: 
        * def in_to_flam3h_init_data(self, node: hou.SopNode) -> TA_F3H_Init:
        
        It will also output some data to be used inside: def in_to_flam3h(self) -> None:

        Args:
            (self):
            node(hou.SopNode): FLAM3H™ node to load the flame file/preset into.

        Returns:
            (TA_F3H_Init): tuple(xml, 
                                 clipboard, 
                                 preset_id, 
                                 clipboard_flame_name, 
                                 attempt_to_load_from_clipboard, 
                                 chaos
                                 )

                                 * xml ( str | None ): either a flame preset from a flame file or from the Clipboard.
                                 * clipboard ( bool ): did we get a valid flame preset from the clipboard ? True or False.
                                 * preset_id ( int ): flame preset index. From clipboard will always be ZERO.
                                 * clipboard_flame_name ( str ): If a valid flame preset from the clipboard is loaded, this will store the preset name of it.
                                 * attempt_to_load_from_clipboard ( bool ): Did we try to load flame preset from the clipboard ? True or False.
                                 * chaos ( bool ): Is it a chaotica XML file type ? True or False.
        """
        
        # Get start directory if one is already set in the IN file path (e.g. a Flame file is already being loaded)
        _START_DIR: str | None = flam3h_general_utils.select_file_start_dir(node)
        # Open a floating file chooser
        flameFile: str = hou.ui.selectFile(start_directory=_START_DIR, title="FLAM3H™ Load a *.flame file", collapse_sequences=False, file_type=hou.fileType.Any, pattern="*.flame", default_value=None, multiple_select=False, image_chooser=None, chooser_mode=hou.fileChooserMode.Read, width=0, height=0)  # type: ignore
        flameFile_expandvars: str = os.path.expandvars(flameFile)
        
        dir: str = os.path.dirname(flameFile_expandvars)
        if os.path.isdir(dir):
            
            if _xml_tree(flameFile_expandvars).isvalidtree:
                
                flam3h_prm_utils.set(node, f3h_tabs.IN.PRM_PATH, flameFile_expandvars)
                # Since this goes directly into: self.in_to_flam3h() definition only
                # its argument is set to 0 so not to create a loop of loading processes
                # becasue inside the following definition there is another call to: self.in_to_flam3h()
                flam3h_general_utils(self.kwargs).flam3h_init_presets_IN_PRESETS(0)
                
                # Set menu parameters index to the first entry
                for prm in (node.parm(f3h_tabs.IN.PRM_PRESETS), node.parm(f3h_tabs.IN.PRM_PRESETS_OFF), node.parm(f3h_tabs.IN.PRM_SYS_PRESETS), node.parm(f3h_tabs.IN.PRM_SYS_PRESETS_OFF)): flam3h_prm_utils.set(node, prm, '0')
                
                return flameFile_expandvars, False, 0, '', False, False
            
            if self.in_to_flam3h_is_CHAOS(flameFile_expandvars):
                return None, False, 0, '', False, True
            
            return None, False, 0, '', False, False
            
        return None, False, 0, '', False, False
        
        
    def in_to_flam3h_init_data_CTRL(self) -> TA_F3H_Init:
        """Load nothing, as the kwargs['ctrl'] is not mapped to anything yet so this is a place holder.</br>
        This definition will be used inside: 
        * def in_to_flam3h_init_data(self, node: hou.SopNode) -> TA_F3H_Init:
        
        It will also output some data to be used inside: def in_to_flam3h(self) -> None:

        Args:
            (self):

        Returns:
            (TA_F3H_Init): tuple(xml, 
                                 clipboard, 
                                 preset_id, 
                                 clipboard_flame_name, 
                                 attempt_to_load_from_clipboard, 
                                 chaos
                                 )

                                 * xml ( str | None ): either a flame preset from a flame file or from the Clipboard.
                                 * clipboard ( bool ): did we get a valid flame preset from the clipboard ? True or False.
                                 * preset_id ( int ): flame preset index. From clipboard will always be ZERO.
                                 * clipboard_flame_name ( str ): If a valid flame preset from the clipboard is loaded, this will store the preset name of it.
                                 * attempt_to_load_from_clipboard ( bool ): Did we try to load flame preset from the clipboard ? True or False.
                                 * chaos ( bool ): Is it a chaotica XML file type ? True or False.
    """
        return None, False, 0, '', False, False
    
    
    def in_to_flam3h_init_data_LMB(self, node: hou.SopNode) -> TA_F3H_Init:
        """Load a flame preset with a mouse click, no kwargs.</br>
        This definition will be used inside:
        * def in_to_flam3h_init_data(self, node: hou.SopNode) -> TA_F3H_Init:
        
        It will also output some data to be used inside:
        * def in_to_flam3h(self) -> None:

        Args:
            (self):
            node(hou.SopNode): FLAM3H™ node to load the flame file/preset into.

        Returns:
            (TA_F3H_Init): tuple(xml, 
                                 clipboard, 
                                 preset_id, 
                                 clipboard_flame_name, 
                                 attempt_to_load_from_clipboard, 
                                 chaos
                                 )

                                 * xml ( str | None ): either a flame preset from a flame file or from the Clipboard.
                                 * clipboard ( bool ): did we get a valid flame preset from the clipboard ? True or False.
                                 * preset_id ( int ): flame preset index. From clipboard will always be ZERO.
                                 * clipboard_flame_name ( str ): If a valid flame preset from the clipboard is loaded, this will store the preset name of it.
                                 * attempt_to_load_from_clipboard ( bool ): Did we try to load flame preset from the clipboard ? True or False.
                                 * chaos ( bool ): Is it a chaotica XML file type ? True or False.
    """
        xml: str = os.path.expandvars(node.parm(f3h_tabs.IN.PRM_PATH).eval())
        
        # Get the correct menu parameter's preset idx
        if node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval():
            preset_id: str = node.parm(f3h_tabs.IN.PRM_PRESETS).eval()
            # Update
            flam3h_prm_utils.set(node, f3h_tabs.IN.PRM_PRESETS_OFF, preset_id)
        else:
            preset_id: str = node.parm(f3h_tabs.IN.PRM_PRESETS_OFF).eval()
            # Update
            flam3h_prm_utils.set(node, f3h_tabs.IN.PRM_PRESETS, preset_id)
            
        return xml, False, int(preset_id), '', False, False


    def in_to_flam3h_init_data(self, node: hou.SopNode) -> TA_F3H_Init:
        """Check if we are able to load a flame from a selected file or to parse a flame from the clipboard</br>
        and provide some output data to work with if any of those cases are true.</br>
        
        Args:
            (self):
            node(hou.SopNode): FLAM3H™ node to load the flame file/preset into.

        Returns:
            (TA_F3H_Init): tuple(xml, 
                                 clipboard, 
                                 preset_id, 
                                 clipboard_flame_name, 
                                 attempt_to_load_from_clipboard, 
                                 chaos
                                 )

                                 * xml ( str | None ): either a flame preset from a flame file or from the Clipboard.
                                 * clipboard ( bool ): did we get a valid flame preset from the clipboard ? True or False.
                                 * preset_id ( int ): flame preset index. From clipboard will always be ZERO.
                                 * clipboard_flame_name ( str ): If a valid flame preset from the clipboard is loaded, this will store the preset name of it.
                                 * attempt_to_load_from_clipboard ( bool ): Did we try to load flame preset from the clipboard ? True or False.
                                 * chaos ( bool ): Is it a chaotica XML file type ? True or False.
        """ 
        # The following try/except block is in place to avoid a 'KeyError' when
        # loading a flame preset from the menu parameter entries instead of clicking the Action Button's icon.
        try:
            self.kwargs['alt']
            
        except KeyError:
            return self.in_to_flam3h_init_data_LMB(node)
        
        else:
            # ALT - If we are loading a flame from the clipboard
            if self.kwargs['alt']:
                return self.in_to_flam3h_init_data_ALT()
                
            # SHIFT - If we are selecting a flame file to load
            elif self.kwargs['shift']:
                return self.in_to_flam3h_init_data_SHIFT(node)
            
            # CTRL - not mapped yet...
            elif self.kwargs['ctrl']:
                return self.in_to_flam3h_init_data_CTRL()
            
            else:
                return self.in_to_flam3h_init_data_LMB(node)


    '''
        The following function is just a shortcut to set and load
        a new preset from the IN Tab IN_PRESETS parameter,
        It works like a hook to then set and evaluate it from the SYS Tab.
    '''
    def in_to_flam3h_sys(self) -> None:
        """Load a Flame preset into FLAM3H™ from the SYS Tab Flame load icon.</br>
        This will set all FLAM3H™ node parameters based on values from the loaded XML Flame preset.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        xml: str = node.parm(f3h_tabs.IN.PRM_PATH).eval()

        if xml and node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_FILE).eval():
            if node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval():
                preset_id: str = node.parm(f3h_tabs.IN.PRM_SYS_PRESETS).eval()
                # Update other PRESETS menu parameters
                for prm in (node.parm(f3h_tabs.IN.PRM_SYS_PRESETS_OFF), node.parm(f3h_tabs.IN.PRM_PRESETS), node.parm(f3h_tabs.IN.PRM_PRESETS_OFF)):
                    flam3h_prm_utils.set(node, prm, preset_id)
                
            else:
                preset_id: str = node.parm(f3h_tabs.IN.PRM_SYS_PRESETS_OFF).eval()
                # Update other PRESETS menu parameters
                for prm in (node.parm(f3h_tabs.IN.PRM_SYS_PRESETS_OFF), node.parm(f3h_tabs.IN.PRM_PRESETS), node.parm(f3h_tabs.IN.PRM_PRESETS_OFF)):
                    flam3h_prm_utils.set(node, prm, preset_id)

            self.in_to_flam3h()


    '''
        The following is the actual load preset/flame function to be used.
    '''
    def in_to_flam3h(self) -> None:
        """Load a Flame preset into FLAM3H™.</br>
        This will set all FLAM3H™ node parameters based on values from the loaded XML Flame preset.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        _FLAM3H_INIT_DATA: TA_F3H_Init = self.in_to_flam3h_init_data(node)
        xml, clipboard, preset_id, flame_name_clipboard, attempt_from_clipboard, chaos = _FLAM3H_INIT_DATA

        if xml is not None and _xml_tree(xml).isvalidtree:

            # IN flame preset data
            apo_data: in_flame_iter_data = in_flame_iter_data(node, xml, preset_id)
            # If there are xforms/iterators
            if apo_data.xforms is not None:
                
                assert apo_data.flame is not None
                # Store into the FLAM3H™ node data storage
                node.setUserData(f3h_userData.XML_LAST, lxmlET.tostring(apo_data.flame[preset_id], encoding="unicode"))
                # Transfer the data from the stored XML into FLAM3H™
                self.in_to_flam3h_resets(node, _FLAM3H_INIT_DATA)
                self.in_to_flam3h_set_iterators(node, apo_data, _FLAM3H_INIT_DATA)
                self.in_to_flam3h_set_motion_blur(node, apo_data)
                self.in_to_flam3h_set_palette(node, apo_data, _FLAM3H_INIT_DATA)                
                self.in_to_flam3h_stats_and_properties(node, apo_data, _FLAM3H_INIT_DATA)
                self.in_to_flam3h_reset_user_data()
                self.in_to_flam3h_toggles_and_msg(node, apo_data, _FLAM3H_INIT_DATA)
                # Updates
                flam3h_iterator_utils(self.kwargs).auto_set_xaos()
                out_flame_utils(self.kwargs).out_auto_change_iter_num_to_prm(apo_data.name[preset_id])
                flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.iter_sel)
                flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.edge_case_01)
                # This is needed to help to updates the menus from time to time so to pick up sneaky changes to the loaded files
                # (ex. the user perform hand made modifications like renaming a Preset and such).
                flam3h_iterator_utils(self.kwargs).destroy_all_menus_data(node, False)
                
                # F3C ( the if statement is for backward compatibility )
                if apo_data.prefs_flam3h_f3c is not None: flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_F3C, apo_data.prefs_flam3h_f3c)
                # Reset/Set density
                flam3h_general_utils.reset_density(node)
                
                # XF VIZ SOLO OFF (but leave the xforms handles VIZ ON)
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO, 0) # Turn Off iterator xf viz solo mode
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_VIZ_SOLO_MP_IDX, 0) # Reset mp index to Off value: 0(Zero)
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.PREFS.PVT_PRM_XF_FF_VIZ_SOLO, 0) # Turn Off FF xf viz solo mode
                flam3h_iterator_utils.destroy_userData(node, f"{f3h_userData.PRX}_{f3h_userData.XFVIZ_SOLO}")
                # BUILD XFVIZ if needed
                flam3h_general_utils.util_xf_viz_force_cook(node, self.kwargs)
                
                # As a backup plan. Most likely not needed by why not
                data: str | None = node.userData(f3h_userData.XML_LAST)
                if data is None or not _xml_tree(data).isvalidtree:
                    out_flame_utils(self.kwargs).out_userData_XML_last_loaded(f3h_userData.XML_LAST, apo_data.name[preset_id])
                
            else:
                if attempt_from_clipboard: _MSG: str = "Flame IN Clipboard: The loaded Flame preset have 0(Zero) xforms/iterators. SKIPPED"
                else: _MSG: str = "Flame IN: The loaded Flame preset have 0(Zero) xforms/iterators. SKIPPED"
                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'WARN')
                _MSG: str = f"ZERO xforms"
                flam3h_general_utils.flash_message(node, f"{_MSG}")
            
        else:
            
            # If there is an already loaded file set in the parameter
            in_xml: str = os.path.expandvars(node.parm(f3h_tabs.IN.PRM_PATH).eval())
            
            # If we loaded a Chaotica XML style preset from the Clipboard 
            if self.in_to_flam3h_clipboard_is_CHAOS():
                _MSG: str = "IN Clipboard: Chaotica XML not supported"
                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'WARN')
                flam3h_general_utils.flash_message(node, _MSG)

            # If we are trying to load from the Clipboard
            elif attempt_from_clipboard:
                _MSG: str = "IN Clipboard: Nothing to load"
                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                flam3h_general_utils.flash_message(node, _MSG)
                
            else:
                
                # If we did try to load a chaotica XML style file
                if chaos:
                    _MSG: str = f"IN: Chaotica XML not supported"
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'WARN')
                    flam3h_general_utils.flash_message(node, _MSG)
                
                # If there was already a valid flame file
                elif _xml_tree(in_xml).isvalidtree:
                    pass
                    
                # If there was already a preset loaded from the clipboard
                elif node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval() and node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval():
                    
                    flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_FILE, 0)
                        
                    _MSG: str = "IN: Nothing to load"
                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                    flam3h_general_utils.flash_message(node, _MSG)
                     
                # Anything else   
                else:
                    for prm in (node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_FILE), node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET), node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE)): flam3h_prm_utils.private_prm_set(node, prm, 0)
                    # clear info msgs
                    for prm in (node.parm(f3h_tabs.IN.MSG_PRM_FLAMESTATS), node.parm(f3h_tabs.IN.MSG_PRM_FLAMERENDER), node.parm(f3h_tabs.PRM_DESCRIPTIVE)): flam3h_prm_utils.set(node, prm, '')

                    # If iterator's count is 0(Zero), change focus back to the IN's Tab
                    # And let the user know it should load a flame file first
                    if node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval() == 0:
                        _MSG: str = "IN: Load an IN flame file first"
                        flam3h_prm_utils.set(node, f3h_tabs.PRM_ITERATORS_TAB, (1,))
                    else: _MSG: str = "IN: Nothing to load"

                    flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'MSG')
                    flam3h_general_utils.flash_message(node, _MSG)
                    
                    
    def in_to_flam3h_render_properties_only(self) -> None:
        """Load a Flame preset render properties into FLAM3H™.</br>
        This will set all FLAM3H™ node parameters based on values from the loaded XML Flame preset.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        _FLAM3H_INIT_DATA: TA_F3H_Init = self.in_to_flam3h_init_data(node)
        xml, clipboard, preset_id, flame_name_clipboard, attempt_from_clipboard, chaos = _FLAM3H_INIT_DATA

        if xml is not None and _xml_tree(xml).isvalidtree:

            # IN flame preset data
            apo_data: in_flame_iter_data = in_flame_iter_data(node, xml, preset_id)
            
            # Transfer the data from the stored XML Render Properties from the Clipboard into FLAM3H™               
            self.in_to_flam3h_stats_and_properties(node, apo_data, _FLAM3H_INIT_DATA, True)
            flam3h_general_utils.flash_message(self.node, f"ALL settings Clipboard: COPIED")
            
        else:
            
            # If we loaded a Chaotica XML style preset from the Clipboard 
            if self.in_to_flam3h_clipboard_is_CHAOS():
                _MSG: str = "Render Properties Clipboard: Chaotica XML not supported"
                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'WARN')
                flam3h_general_utils.flash_message(node, _MSG)
                
            else:
                _MSG: str = "Render Properties Clipboard: Nothing to load"
                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}. Copy a Flame into the clipboard first to copy its render properties into here.", 'IMP')
                flam3h_general_utils.flash_message(node, _MSG)


    def reset_IN(self, mode: int = 0) -> None:
        """Reset the FLAM3H™ IN Tab parameters.</br>

        Args:
            (self):
            mode(int): Default to: 0(Zero)</br>1 will reset the remainder of the parameters.
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_ISVALID_PRESET, 0)
        flam3h_prm_utils.private_prm_set(node, f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE, 0)
        for prm in (node.parm(f3h_tabs.IN.MSG_PRM_FLAMESTATS), node.parm(f3h_tabs.IN.MSG_PRM_FLAMERENDER), node.parm(f3h_tabs.IN.MSG_PRM_FLAMESENSOR), node.parm(f3h_tabs.PRM_DESCRIPTIVE), node.parm(f3h_tabs.IN.MSG_PRM_STATS_HEADING), node.parm(f3h_tabs.IN.MSG_PRM_SETTINGS_HEADING)): flam3h_prm_utils.set(node, prm, '')
        
        if mode:
            # This is not being used anymore but I leave it here just in case
            parms_dict: dict = {f3h_tabs.IN.PRM_PATH: "",
                                f3h_tabs.IN.PRM_PRESETS: str(-1), 
                                f3h_tabs.IN.PRM_PRESETS_OFF: str(-1), 
                                f3h_tabs.IN.PRM_ITER_NUM_ON_LOAD: 64, 
                                f3h_tabs.IN.PRM_USE_ITER_ON_LOAD: 0, 
                                f3h_tabs.IN.PRM_COPY_RENDER_PROPERTIES_ON_LOAD: 1}
            flam3h_prm_utils.setParms(node, parms_dict)


# CONVERT FRACTORIUM's VAR DICT start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
# Turn Fractorium variation names dictionary into PRE and POST variation names dictionary
VARS_FRACTORIUM_DICT_PRE: dict[str, tuple[str, ...]]  = in_flame_utils.in_util_vars_dict_type_maker(VARS_FRACTORIUM_DICT, in_flame_utils.in_util_make_PRE)
VARS_FRACTORIUM_DICT_POST: dict[str, tuple[str, ...]] = in_flame_utils.in_util_vars_dict_type_maker(VARS_FRACTORIUM_DICT, in_flame_utils.in_util_make_POST)


# SAVE XML FILES start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################

# this has been pre-built to work with: menu_sensor_resolution_set(self, update=True) -> None:
MENU_OUT_SENSOR_RESOLUTIONS: TA_Menu = [0, '', 1, '640x480', 2, 'HDTV 720', 3, 'HDTV 1080', 4, 'HDTV 2160 (4K)', 5, '', 6, 'NTSC', 7, 'NTSC D1', 8, 'PAL', 9, 'PAL 16:9 (1 to 1)', 10, '', 11, 'Full Ap 4K', 12, 'Full Ap 2K', 13, 'Acad 4K', 14, 'Acad 2K', 15, 'Scope 4K', 16, 'Scope 2K', 17, 'Vista 2K', 18, '', 19, '256^2', 20, '512^2', 21, '1024^2', 22, '2048^2', 23, '4096^2', 24, '']


class out_flame_utils:
    """
class out_flame_utils

@STATICMETHODS
* out_render_curves_set_data_defaults(node: hou.SopNode) -> None:
* out_render_curves_retrive_data(node: hou.SopNode) -> None:
* out_render_curves_set_and_retrieve_defaults(node: hou.SopNode) -> None:
* out_render_curves_compare(node: hou.SopNode, mode: bool = False) -> bool:
* out_render_curves_compare_and_set_toggle(node: hou.SopNode) -> None:
* out_render_curves_set_defaults_on_load(node: hou.SopNode):
* out_auto_add_iter_num(iter_num: int, name: str, autoadd: int, flame: bool = True) -> str:
* out_auto_change_iter_num(iter_num: int, flame_name: str, autoadd: int) -> str:
* out_remove_iter_num(flame_name: str) -> str:
* out_flame_default_name(node: hou.SopNode, autoadd: int) -> str:
* out_util_round_float(val: float) -> str:
* out_util_round_floats(val_list: TA_RoundFloats) -> TA_STR_ListUnflattened:
* out_util_vars_duplicate(vars: list[str]) -> list[str]:
* out_check_build_file(file_split: tuple[str, str] | list[str], file_name: str, file_ext: str) -> str:
* out_check_outpath_messages(node: hou.SopNode, infile: str, file_new: str, file_ext: str, prx: str) -> None:
* out_file_cleanup(_out_file: str) -> str:
* out_check_outpath(node: hou.SopNode, infile: str, file_ext: str, prx: str, out: bool = True, auto_name: bool = True) -> str | bool:
* out_affine_rot(affine: TA_Affine, angleDeg: float) -> TA_Affine:
* out_xaos_cleanup(xaos: TA_STR_ListUnflattened) -> TA_STR_ListUnflattened:
* out_xaos_collect(node: hou.SopNode, iter_count: int, prm: str) -> TA_XAOS_Collect:
* out_xaos_collect_vactive(node: hou.SopNode, fill: list[list[str]] | list[list[float]], prm: str) -> list[list[str] | list[Never]]:
* _out_pretty_print(current: lxmlET._Element, parent: lxmlET._Element | None = None, index: int = -1, depth: int = 0) -> None: #type: ignore
* _out_pretty_print(current, parent=None, index: int=-1, depth: int=0) -> None:
* menu_out_presets_loop(menu: TA_Menu, i: int, item: str) -> None:
* menu_out_presets_loop_enum(menu: TA_Menu, i: int, item: str) -> None:
* out_collect_var_section_names_dict(node: hou.SopNode, mode: bool = False, var_section: str = "VAR") -> dict[str, list[str]] | bool:
* out_build_xf_names(f3d: out_flame_xforms_data) -> tuple[str, ...]:

@METHODS
* get_iter_affine_pre(self, iterator_num: int) -> TA_Affine:
* get_iter_affine_pre_rot(self, iterator_num: int) -> float:
* get_iter_affine_post(self, iterator_num: int) -> TA_Affine:
* get_iter_affine_post_rot(self, iterator_num: int) -> float:
* get_FF_affine_pre(self) -> TA_Affine:
* get_FF_affine_pre_rot(self) -> float:
* get_FF_affine_post(self) -> TA_Affine:
* get_FF_affine_post_rot(self) -> float:
* out_to_flam3h_init_data_quick(self, node: hou.SopNode, tab: str = 'OUT') -> tuple[str | None, int]:
* out_to_flam3h_quick(self, tab: str = 'OUT') -> None:
* out_palette_256_plus_check(self) -> None:
* out_presets_get_selected_menu_label(self) -> str | None:
* out_presets_copy_menu_label_callback(self) -> None:
* out_palette_keys_count(self, palette_plus: int, keys: int, type: int, _MSG = True) -> str:
* __menu_sensor_resolution(self) -> TA_Menu:
* menu_sensor_resolution(self) -> TA_Menu:
* menu_sensor_resolution_set(self, update=True) -> None:
* reset_OUT_sensor(self) -> None:
* reset_OUT_render(self) -> None:
* reset_OUT_kwargs(self) -> None:
* reset_OUT_options(self) -> None:
* reset_OUT(self, mode=0) -> None:
* out_xf_xaos_to(self) -> tuple[str, ...]:
* out_xf_xaos_from(self, mode: int = 0) -> tuple[str, ...]:
* menu_out_contents_presets_data(self, node: hou.SopNode, xml_file_path: str, xml_is_file: bool) -> TA_Menu:
* menu_out_contents_presets(self) -> TA_Menu:
* out_auto_add_iter_data(self) -> tuple[int, str, int]:
* out_auto_add_iter_num_to_prm(self) -> None:
* out_auto_change_iter_num_to_prm(self, name: str | None = None) -> None:
* out_flame_name_inherit_on_load(self) -> None:
* out_flame_properties_build(self, f3r: out_flame_render_properties) -> dict:
* out_flam3_compatibility_check_and_msg(self) -> bool:                                
* out_populate_xform_vars_XML(self, 
                                varsPRM: tuple, 
                                TYPES_tuple: tuple[str, ...], 
                                WEIGHTS_tuple: tuple[tuple[str, int], ...], 
                                element_xform: lxmlET._Element,
                                MP_IDX: str, 
                                FUNC: Callable) -> list[str]:
* out_build_XML(self, flame: lxmlET._Element) -> bool:
* out_userData_XML_last_loaded(self, data_name: str = f3h_userData.XML_LAST, flame_name: str | None = None) -> None:
* out_new_XML(self, outpath: str) -> None:
* out_preset_XML_clipboard(self) -> None
* out_append_XML(self, root: lxmlET._Element, out_path: str) -> None:
* out_XML(self) -> None:
* __out_flame_data(self, prm_name: str = '') -> str:
* __out_flame_name(self, prm_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_XF_NAME)) -> str:
* __out_xf_data(self, prm_name: str) -> tuple[str, ...]:
* __out_xf_data_color_speed(self) -> tuple[str, ...]:
* __out_xf_name(self) -> tuple[str, ...]:
* __out_finalxf_name(self) -> str:
* __out_xf_pre_blur(self) -> tuple[str, ...]:
* __out_xf_xaos(self) -> tuple[str, ...]:
* __out_xf_preaffine(self) -> TA_OUT_Pre_Affine:
* __out_xf_postaffine(self) -> TA_OUT_Post_Affine:
* __out_finalxf_preaffine(self) -> TA_OUT_Affine_FF:
* __out_finalxf_postaffine(self) -> TA_OUT_Affine_FF:
* __out_palette_hex(self) -> str:
* __out_flame_palette_mode(self) -> str:
* __out_flame_data_flam3h_hsv(self, prm_name: str = f3h_tabs.CP.PRM_RAMP_HSV_VAL_NAME) -> str | bool:
* __out_flame_data_flam3h_mb_val(self, prm_name: str = '') -> str | bool:
* __out_flame_data_flam3h_toggle(self, toggle: bool) -> str:
* __out_flame_palette_lookup_samples(self) -> str | bool:
* __out_flame_palette_basis(self) -> str | bool:
    """

    __slots__ = ("_cached_data", 
                 "_kwargs", "_node", 
                 "_flam3h_iter_prm_names", "_flam3h_iter", "_flam3h_iter_FF", "_flam3h_do_FF", 
                 "_iter_count", "_palette", "_palette_hsv_do", "_palette_plus_do", "_f3h_affine", "_xm", 
                 "_flam3h_rip", "_flam3h_mb_do", "_flam3h_f3c", "_flam3h_cp_lookup_samples", "_flam3h_cp_basis")

    def __init__(self, kwargs: dict) -> None:
        """
        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """ 
        self._kwargs: dict[str, Any] = kwargs
        self._node: hou.SopNode = kwargs['node']
        
        self._flam3h_iter_prm_names: flam3h_iterator_prm_names = flam3h_iterator_prm_names()
        self._flam3h_iter: flam3h_iterator = flam3h_iterator()
        self._flam3h_iter_FF: flam3h_iterator_FF = flam3h_iterator_FF()
        self._flam3h_do_FF: int = self._node.parm(f3h_tabs.PREFS.PVT_PRM_DOFF).eval()
        
        self._iter_count: int = self._node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        self._palette: hou.Ramp = self._node.parm(f3h_tabs.CP.PRM_RAMP_SRC_NAME).evalAsRamp()
        self._palette_hsv_do: int = self._node.parm(f3h_tabs.OUT.PRM_HSV_PALETTE_DO).eval()
        self._palette_plus_do: int = self._node.parm(f3h_tabs.PREFS.PRM_PALETTE_256_PLUS).eval()
        if self._palette_hsv_do:
            # Update hsv ramp before storing it.
            flam3h_palette_utils(self.kwargs).palette_cp()
            self._palette: hou.Ramp = self._node.parm(f3h_tabs.CP.PRM_RAMP_HSV_NAME).evalAsRamp()
        self._f3h_affine: int = self._node.parm(f3h_tabs.OUT.PRM_FLAM3H_AFFINE_STYLE).eval()
        self._xm: int = self._node.parm(f3h_tabs.PREFS.PRM_XAOS_MODE).eval()
        
        # custom to FLAM3H™ only
        self._flam3h_rip: int = self._node.parm(f3h_tabs.PREFS.PVT_PRM_RIP).eval()
        self._flam3h_mb_do: int = self._node.parm(f3h_tabs.MB.PRM_DO).eval()
        self._flam3h_f3c: int = self._node.parm(f3h_tabs.PREFS.PVT_PRM_F3C).eval()
        self._flam3h_cp_lookup_samples: int = self._node.parm(f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES).eval()
        self._flam3h_cp_basis: int = self._node.parm(f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES_BASES).eval()
        
    
    @staticmethod
    def out_render_curves_set_data_defaults(node: hou.SopNode) -> None:
        """Set the defaults values into the color correction curves data parameters.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node

        Returns:
            (None):
        """
        # render curves
        parms_dict: dict = {XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVES): xml_keys.DEFAULT_CC_CURVES, 
                            XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_OVERALL): xml_keys.DEFAULT_CC_CURVE, 
                            XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_RED): xml_keys.DEFAULT_CC_CURVE, 
                            XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_GREEN): xml_keys.DEFAULT_CC_CURVE, 
                            XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_BLUE): xml_keys.DEFAULT_CC_CURVE}
        
        flam3h_prm_utils.setParms(node, parms_dict)
        
        
    @staticmethod
    def out_render_curves_retrive_data(node: hou.SopNode) -> None:
        """Retrieve the data from color correction curves data parameters</br>
        and copy it into the corresponding color correction curves UI parameters.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node

        Returns:
            (None):
        """
        # render curves data
        prm_data: dict[str, hou.Parm] = {'prm_curves': node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVES)), 
                                         'prm_curve_overall': node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_OVERALL)), 
                                         'prm_curve_red': node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_RED)), 
                                         'prm_curve_green': node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_GREEN)), 
                                         'prm_curve_blue': node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_BLUE))
                                        }
        
        # render curves parms
        prm_ui: dict[str, hou.Parm] = { 'prm_curves': node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVES), 
                                        'prm_curve_overall': node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVE_OVERALL), 
                                        'prm_curve_red': node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVE_RED), 
                                        'prm_curve_green': node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVE_GREEN), 
                                        'prm_curve_blue': node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVE_BLUE)
                                        }
        
        for key in prm_ui.keys():
            _prm: hou.Parm | hou.ParmTuple | None = prm_ui.get(key)
            assert _prm is not None
            _prm_data: hou.Parm | hou.ParmTuple | None = prm_data.get(key)
            assert _prm_data is not None
            _prm_data_val: TA_PrmData = _prm_data.eval()
            flam3h_prm_utils.private_prm_set(node, _prm, _prm_data_val)

        
    @staticmethod
    def out_render_curves_set_and_retrieve_defaults(node: hou.SopNode) -> None:
        """Set the defaults values into the color correction curves data parameters</br>
        and copy it into the correcsponding color correction curves UI parameters.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node

        Returns:
            (None):
        """
        out_flame_utils.out_render_curves_set_data_defaults(node)
        out_flame_utils.out_render_curves_retrive_data(node)

        parms_dict: dict = {f3h_tabs.OUT.PRM_LABEL_CC_DEFAULTS_MSG: 'Defaults', 
                            f3h_tabs.OUT.PRM_TOGGLE_CC_DEFAULTS_MSG: 0}
        flam3h_prm_utils.setParms(node, parms_dict)
    
    
    @staticmethod
    def out_render_curves_compare(node: hou.SopNode, mode: bool = False) -> bool:
        """Compare the current UI CC curves with the CC CURVES DATA.</br></br>
        Two modes:
        * (mode: False)</br>will compare if they are default values(return: True) or not(return: False)
        * (mode: True)</br>will compare the UI data with the CC CURVES DATA and check if they are identical(return: True) or not(return: False)

        Args:
            node(hou.SopNode): this FLAM3H™ node
            mode(bool): Default to: False
                * (mode: False) will compare if they are default values( return: True) or not(return: False)
                * (mode: True) will compare the UI data with the CC CURVES DATA and check if they are identical(return: True) or not(return: False)

        Returns:
            (bool): True or Flase
        """
        cc_o: str = str(node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_OVERALL)).eval()).strip()
        cc_r: str = str(node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_RED)).eval()).strip()
        cc_g: str = str(node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_GREEN)).eval()).strip()
        cc_b: str = str(node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_BLUE)).eval()).strip()
        
        if not mode:
            if cc_o in xml_keys.DEFAULT_CC_CURVE_ALL and cc_r in xml_keys.DEFAULT_CC_CURVE_ALL and cc_g in xml_keys.DEFAULT_CC_CURVE_ALL and cc_b in xml_keys.DEFAULT_CC_CURVE_ALL:
                return True
            
            return False
        
        cc_o_ui: str = str(node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVE_OVERALL).eval()).strip()
        cc_r_ui: str = str(node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVE_RED).eval()).strip()
        cc_g_ui: str = str(node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVE_GREEN).eval()).strip()
        cc_b_ui: str = str(node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVE_BLUE).eval()).strip()
        
        if cc_o != cc_o_ui or cc_r != cc_r_ui or cc_g != cc_g_ui or cc_b != cc_b_ui:
            return False
        
        return True
    
    
    @staticmethod
    def out_render_curves_compare_and_set_toggle(node: hou.SopNode) -> None:
        """Check if the color correction curves data parameters are at their default values</br>
        and set the UI heading label parameter accordingly.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node

        Returns:
            (None):
        """
        if out_flame_utils.out_render_curves_compare(node):
            parms_dict: dict = {f3h_tabs.OUT.PRM_LABEL_CC_DEFAULTS_MSG: 'Defaults', 
                                f3h_tabs.OUT.PRM_TOGGLE_CC_DEFAULTS_MSG: 0}
            flam3h_prm_utils.setParms(node, parms_dict)
        else:
            parms_dict: dict = {f3h_tabs.OUT.PRM_LABEL_CC_DEFAULTS_MSG: 'Modified: Click to Reset', 
                                f3h_tabs.OUT.PRM_TOGGLE_CC_DEFAULTS_MSG: 1}
            flam3h_prm_utils.setParms(node, parms_dict)
    
    
    @staticmethod
    def out_render_curves_set_defaults_on_load(node: hou.SopNode):
        """This is for backward compatibility when loading hip files with older version of FLAM3H™ nodes.</br>
        it will set proper color correction curves default values if needed.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node

        Returns:
            (None):
        """
        # render curves data
        prm_curves_data: hou.Parm = node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVES))
        prm_data: dict[str, hou.Parm] = {'prm_curve_overall': node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_OVERALL)), 
                                         'prm_curve_red': node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_RED)), 
                                         'prm_curve_green': node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_GREEN)), 
                                         'prm_curve_blue': node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_BLUE))
                                         }
        
        # render curves parms
        prm_curves_ui: hou.Parm = node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVES)
        prm_ui: dict[str, hou.Parm] = { 'prm_curve_overall': node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVE_OVERALL),
                                        'prm_curve_red': node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVE_RED), 
                                        'prm_curve_green': node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVE_GREEN), 
                                        'prm_curve_blue': node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_CURVE_BLUE)
                                        }
        
        # Set the prm data defaults first
        if len(prm_curves_data.eval()) == 1:
            prm_curves_ui.set(xml_keys.DEFAULT_CC_CURVES) # type: ignore
            # Update CC label and toggle to their defaults
            parms_dict: dict = {f3h_tabs.OUT.PRM_LABEL_CC_DEFAULTS_MSG: 'Defaults', 
                                f3h_tabs.OUT.PRM_TOGGLE_CC_DEFAULTS_MSG: 0}
            flam3h_prm_utils.setParms(node, parms_dict)
        
        for key in prm_ui.keys():
            if len(prm_data.get(key).eval()) == 1: # type: ignore
                prm_data.get(key).set(xml_keys.DEFAULT_CC_CURVE) # type: ignore

        # Set the prm ui defaults
        for prm in prm_ui.values():
            prm.lock(False)
            prm.deleteAllKeyframes()
        for key in prm_data.keys():
            if len(prm_data.get(key).eval()) == 1: # type: ignore
                prm_ui.get(key).set(xml_keys.DEFAULT_CC_CURVE) # type: ignore
        for prm in prm_ui.values(): prm.lock(True) 

    
    @staticmethod
    def out_auto_add_iter_num(iter_num: int, name: str, autoadd: int, flame: bool = True) -> str:
        """It will check and correct the passed Flame name and add the iteration number to it if needed.</br>
        Additionally, when the "flame" arg is set to False, it will just autocorrect the passed name, to be used for example for the Palette name.</br>

        Args:
            iter_num(int): the current iteration's number
            flame_name(str): The Flame name to check and correct
            autoadd(int): Auto add iter num toggle value (This toggle will eventually be removed from FLAM3H™ at some point)
            flame(bool): Default to: True(Flame)</br>Use False for Palette

        Returns:
            (str): A new name with either the iterations number added to it if needed or corrected or both.
        """

        name = name.strip()
        
        if name:
            
            splt: list | str = ':'
            # Prep an automated Flame/Palette name if no name is provided
            if flame: name_new: str = datetime.now().strftime("Flame_%b-%d-%Y_%H%M%S")
            else: name_new: str = datetime.now().strftime("Palette_%b-%d-%Y_%H%M%S")
            
            rp: list[str] = name.split(splt)
            rp[:] = [item for item in rp if item]
            # Lets make some name checks first
            #
            # if it start with a special character
            if not name[0].isalnum():
                rp = name_new.split(splt)
                rp[:] = [item for item in rp if item]
                
            # if it end with special character
            elif not name[-1].isalnum():
                
                rp = name.split(splt)
                if len(rp) == 1 and len(rp[0]):
                    item_cleaned: str =''.join(letter for letter in rp[0].strip() if letter.isalnum() or letter in f3h_char.ALLOWED_OUT_AUTO_ADD_ITER_NUM)
                    rp = [item_cleaned]
                    
                elif len(rp) > 1:
                    name_new: str = ' '.join(rp[:-1])
                    rp = name_new.split(splt)
                    rp[:] = [item for item in rp if item]
                    
                else:
                    rp = name_new.split(splt)
                    rp[:] = [item for item in rp if item]
            
            is_int: bool = True

            # if the name is a number, I want to still add the iteration num to it
            # and not evaluate this as integer, even if it is an integer.
            if rp[-1] != name:
                
                try:
                    int(rp[-1].strip())
                    
                except ValueError:
                    is_int: bool = False
                    
            else:
                is_int: bool = False
                
            if is_int is False:
                
                _join: Callable[[Iterable[str]], str] = ''.join
                rp_clean: list = [_join(letter for letter in item.strip() if letter.isalnum() or letter in f3h_char.ALLOWED_OUT_AUTO_ADD_ITER_NUM) for item in rp]
                if flame:
                    if autoadd: name_new: str = ' '.join(rp_clean) + f3h_tabs.IN.DEFAULT_ITERATIONS_FLAME_NAME_DIV + str(iter_num)
                    else: name_new: str = ' '.join(rp_clean)
                    
                else: name_new: str = ' '.join(rp_clean)
                
                return name_new.strip()
            
            
            splt = name.split(":")
            if len(splt) > 1:
                build: str = ''.join([item.strip() for item in splt[:-1]])
                if flame: 
                    if autoadd:
                        return f"{build}{f3h_tabs.IN.DEFAULT_ITERATIONS_FLAME_NAME_DIV}{iter_num}"
                    
                    return build
                    
                return build
                
            return name
                
        return name

    
    @staticmethod 
    def out_auto_change_iter_num(iter_num: int, flame_name: str, autoadd: int) -> str:
        """It will check the passed Flame name </br>
        and update the iteration number when changing iterations.</br>
        If no iteration number is present in the passed Flame name</br>
        it will add it to the end of the Flame name.</br>

        Args:
            iter_num(int): the current iteration's number
            flame_name(str): The Flame name to check
            autoadd(int): Auto add iter num toggle value

        Returns:
            (str): A new Flame name with the iter num updated/added if needed.
        """
        if autoadd:
            
            flame_name = flame_name.strip()
            if flame_name:
                
                flame_name = out_flame_utils.out_auto_add_iter_num(iter_num, flame_name, autoadd)
                rp: tuple[str, str, str] = flame_name.rpartition(f3h_tabs.IN.DEFAULT_ITERATIONS_FLAME_NAME_DIV)

                is_int: bool = False
                if rp[-1] != flame_name:
                    
                    try:
                        int(rp[-1])
                        
                    except ValueError:
                        pass
                    
                    else:
                        is_int = True
                else:
                    pass
                
                if is_int:
                    flame_name_changed: str = ''.join(rp[:-1]) + str(iter_num)
                    
                    return flame_name_changed
                
                return flame_name
            
            return flame_name
        
        return flame_name
        
        
    @staticmethod 
    def out_remove_iter_num(flame_name: str) -> str:
        """Remove the iterations number from the Flame name if any.</br>

        Args:
            flame_name(str): The Flame name to check

        Returns:
            (str): A new Flame name without the iter num if any.
        """
            
        flame_name = flame_name.strip()
        
        if flame_name:
            
            rp: tuple[str, str, str] = flame_name.rpartition(f3h_tabs.IN.DEFAULT_ITERATIONS_FLAME_NAME_DIV)

            is_int: bool = False
            
            if rp[-1] != flame_name:
                
                try:
                    int(rp[-1])
                    
                except ValueError:
                    pass
                
                else:
                    is_int = True
                
            else:
                pass
            
            if is_int:
                return ''.join(rp[:-2])
            
            return flame_name
        
        return flame_name
        
        
    @staticmethod
    def out_flame_default_name(node: hou.SopNode, autoadd: int) -> str:
        """Create a default name to be used for the output Flame file path.</br>

        Args:
            node(hou.SopNode): Current FLAM3H™ houdini node
            autoadd(int): Autoadd ON/OFF value. If ON, it will auto add the iteration number to the filename, otherwise not.

        Returns:
            (str): Return a default name composed of today's date and time.
        """
        flame_name: str = datetime.now().strftime("Flame_%b-%d-%Y_%H%M%S")
        iter_num: int = node.parm(f3h_tabs.GLB.PRM_ITERATIONS).eval()
        
        return out_flame_utils.out_auto_add_iter_num(iter_num, flame_name, autoadd)
    
    
    @staticmethod
    def out_util_round_float(val: float) -> str:
        """remove floating Zeros if it is an integer value ( ex: from '1.0' to '1' )

        Args:
            val(float): The value to remove the floating zeros from

        Returns:
            (str): A value without the floating zeros
        """
        if float(val).is_integer():
            return str(int(float(val)))
        
        return str(round(float(val), xml_keys.f3h.DEFAULT_ROUND_DECIMAL_COUNT))
        
        
    @staticmethod
    def out_util_round_floats(val_list: TA_RoundFloats) -> TA_STR_ListUnflattened:
        """remove floating Zeros if it is an integer value ( ex: from '1.0' to '1' ) in a list or tuple of values.</br>
        You can pass in:
        * list[list[float]]
        * list[list[str]]

        Args:
            val_list(TA_RoundFloats): A collection of values to rounds

        Returns:
            (TA_STR_ListUnflattened): A list/tuple of list[str]/tuple[str] with the rounded values if any
        """    
        _is_integer: Callable[[float], bool] = float.is_integer
        _round: Callable[[float, int], float] = round
        return [[str(int(float(i))) if _is_integer(float(i)) else str(_round(float(i), xml_keys.f3h.DEFAULT_ROUND_DECIMAL_COUNT)) for i in item] for item in val_list]
    
    
    @staticmethod
    def out_util_vars_duplicate(vars: list[str]) -> list[str]:
        """Collect duplicate variation's names in an iterator.</br>

        Args:
            vars(list[str]): List of all variation's list names

        Returns:
            (list[str]): duplicate variation's names per each iterator
        """
        v: list[str] = []
        d: list[str] = []

        for var in vars:
            if var in v:
                d.append(var)
                
            else:
                v.append(var)

        return d

    
    @staticmethod
    def out_check_build_file(file_split: tuple[str, str] | list[str], file_name: str, file_ext: str) -> str:
        """Used in conjuction with: def out_check_outpath()</br>
        help to make spelling auto corrections to the provided output file path.</br>

        Args:
            file_split(tuple[str, str] | list[str]): Returns tuple "(head, tail)" where "tail" is everything after the final slash. Either part may be empty
            file_name(str): The input filename to be checked
            file_ext(str): the desired filename extension

        Returns:
            (str): A corrected file path
        """    
        # This code is very old and need some revision ;D
        build_f: str = "/".join(file_split) + file_ext
        build_f_s: list[str] = os.path.split(build_f)[0].split("/")
        build_f_s[:] = [item for item in build_f_s if item]
        # Clean location directories. ( maybe not needed but whatever )
        _join: Callable[[Iterable[str]], str] = ''.join
        build_f_s_cleaned: list = [_join(letter for letter in item if letter.isalnum() or letter in f3h_char.ALLOWED) for item in build_f_s]
        # append cleaned file_name
        build_f_s_cleaned.append(''.join(letter for letter in file_name if letter.isalnum() or letter in f3h_char.ALLOWED))
        
        # the file_ext start with a dot so its added as last
        return "/".join(build_f_s_cleaned) + file_ext
    
    
    @staticmethod
    def out_check_outpath_messages(node: hou.SopNode, infile: str, file_new: str, file_ext: str, prx: str) -> None:
        """Print out some messages in the console and in the status bar.</br>

        Args:
            node(hou.SopNode): This FLAM3H™ node.
            infile(str): THe file path to check.
            file_new(str): The new generated file full path
            file_ext(str): Provide an extension to tell this function if it is a Flame file or a FLAM3H™ palette file. 
            prx(str): A prefix for an automated file name to be provided for the XML Flame file or a Palette flame file. 'Palette' or 'Flame' (f3h_tabs.CP.DEFAULT_AUTO_NAME: str or f3h_tabs.OUT.DEFAULT_AUTO_NAME: str)

        Returns:
            (None):
        """  
        # Print out proper msg based on file extension
        if f3h_tabs.OUT.DEFAULT_FILE_EXT == file_ext:
            if os.path.isfile(infile) and os.path.exists(infile):
                _MSG: str = f"OUT: You selected an OUT file that is not a {prx} file type."
                # print(f"{node.name()}.{_MSG}\n")
                flam3h_general_utils.set_status_msg(f"{node.name()}.{_MSG}", 'WARN')
                
            else:
                if os.path.isdir(os.path.split(file_new)[0]) and not os.path.exists(file_new):
                    if flam3h_general_utils.isLOCK(os.path.split(file_new)[1]):
                        _MSG: str = 'OUT: Flame lib file: LOCKED'
                        flam3h_general_utils.set_status_msg(f"{node.name()}.{_MSG}: {file_new}", 'IMP')
                        
                    else:
                        _MSG: str = 'OUT: Save to create this file'
                        flam3h_general_utils.set_status_msg(f"{node.name()}.{_MSG}: {file_new}", 'IMP')
                        
        elif f3h_tabs.CP.DEFAULT_FILE_EXT == file_ext:
            if os.path.isfile(infile) and os.path.exists(infile):
                _MSG: str = f"CP: You selected an OUT file that is not a {prx} file type."
                # print(f"{node.name()}.{_MSG}\n")
                flam3h_general_utils.set_status_msg(f"{node.name()}.{_MSG}", 'WARN')
                
            else:
                if os.path.isdir(os.path.split(file_new)[0]) and not os.path.exists(file_new):
                    if flam3h_general_utils.isLOCK(os.path.split(file_new)[1]):
                        _MSG: str = 'CP: Flame lib file: LOCKED'
                        flam3h_general_utils.set_status_msg(f"{node.name()}.{_MSG}: {file_new}", 'IMP')
                        
                    else:
                        _MSG: str = 'CP: Save to create this file'
                        flam3h_general_utils.set_status_msg(f"{node.name()}.{_MSG}: {file_new}", 'IMP')
                        
                        
    @staticmethod
    def out_file_cleanup(_out_file: str) -> str:
        """Further cleanup the generated out file before sending it out.</br>

        Args:
            _out_file(str): The incoming out_file string to further cleanup.

        Returns:
            (str): The out_file string ready to go out
        """  
        # Further cleanup
        _out_s: tuple[str, str] = os.path.split(_out_file)
        _out_st: tuple[str, str] = os.path.splitext(_out_s[-1].strip())
        # We can add as many of the following as we want.
        _out_st_root: str = _out_st[0].replace(".", "_")
        
        # Build final out file
        if _out_s[0][-1] == "/":
            out_file: str = f"{_out_s[0]}{_out_st_root}{_out_st[-1]}"
            
        else:
            out_file: str = f"{_out_s[0]}/{_out_st_root}{_out_st[-1]}"
            
        return out_file


    @staticmethod
    def out_check_outpath(node: hou.SopNode, infile: str, file_ext: str, prx: str, out: bool = True, auto_name: bool = True) -> str | bool:
        """Check for the validity of the provided output file path and correct it if needed.</br>
        
        Note:
            This definition was very old and I am improving it.

        Args:
            node(hou.SopNode): Current FLAM3H™ node.
            infile(str): THe file path to check.
            file_ext(str): Provide an extension to tell this function if it is a Flame file or a FLAM3H™ palette file. 
            prx(str): A prefix for an automated file name to be provided for the XML Flame file or a Palette flame file.</br>'Palette' or 'Flame'</br>(f3h_tabs.CP.DEFAULT_AUTO_NAME: str or f3h_tabs.OUT.DEFAULT_AUTO_NAME: str)
            out(int): Default to: True</br>Which Flame tab are we running this from? False for IN tab, True for OUT tab.
            auto_name(bool): Default to: True</br>When checking the output path you some time do not want to generate a filename and extension, </br>like for example inside the IN file string parameter.
        
        Returns:
            str | bool: Either a corrected/valid file path or False if not valid.
        """
        
        file: str = os.path.expandvars(infile)
        
        # Early exit if the file is already valid
        if (prx == f3h_tabs.CP.DEFAULT_AUTO_NAME and flam3h_palette_utils.isJSON_F3H(node, file, False)[-1]) or \
           (prx == f3h_tabs.OUT.DEFAULT_AUTO_NAME and _xml_tree(file).isvalidtree):
               
            return file

        # Otherwise lets be sure to build a proper output path and file name.
        
        # Cache path components once
        file_split: tuple[str, str] = os.path.split(file)
        file_dir: str = file_split[0]
        file_s: list[str] = [''.join(x.split(' ')) for x in file_split]
        file_dir_is_valid: bool = os.path.isdir(file_dir)
        
        # This toggle should be removed from FLAM3H™ at some point
        autopath: int = node.parm(f3h_tabs.PREFS.PVT_PRM_AUTO_PATH_CORRECTION).eval()
        if autopath:
            
            # Just in case lets check is a valid location
            if file_dir_is_valid or os.path.isdir(file_s[0]):
                
                file_new = ''
                # Generate timestamp once if needed
                new_name: str = datetime.now().strftime(f"{prx}_%b-%d-%Y_%H%M%S") if auto_name else ''
                
                filename_s: tuple[str, str] = os.path.splitext(file_s[-1].strip())
                
                if filename_s[-1] == file_ext:
                    # This code is very old and need some revision ;D
                    build_f_s: list[str] = file.split("/")
                    build_f_s[:] = [item for item in build_f_s if item]
                    build_f_s[-1] = ''.join(letter for letter in build_f_s[-1] if letter.isalnum() or letter in f3h_char.ALLOWED)
                    file_new: str = "/".join(build_f_s)
                
                elif not filename_s[-1] and filename_s[0]:
                    
                    # this is done in case only the extension is left in the prm field
                    if file_s[-1] in file_ext and file_s[-1][0] == ".":
                        if auto_name: file_new: str = out_flame_utils.out_check_build_file(file_s, new_name, file_ext)
                        else: file_new: str = out_flame_utils.out_check_build_file(file_s, new_name, '')
                        
                    else:
                        
                        if not file_s[-1][0].isalnum():
                            if auto_name: file_new: str = out_flame_utils.out_check_build_file(file_s, new_name, file_ext)
                            else: file_new: str = out_flame_utils.out_check_build_file(file_s, new_name, '')
                            
                        else:
                            file_new: str = out_flame_utils.out_check_build_file(file_s, file_s[-1], file_ext)
                            
                    # Print out proper msg based on file extension
                    out_flame_utils.out_check_outpath_messages(node, file, file_new, file_ext, prx)
                    
                elif not filename_s[-1] and not filename_s[0]:
                    if auto_name: file_new: str = out_flame_utils.out_check_build_file(file_s, new_name, file_ext)
                    else: file_new: str = out_flame_utils.out_check_build_file(file_s, new_name, '')
                
                # this as last for now
                #
                # If there is a file extension and it match part or all of the file_ext string.
                #
                # This will execute only if the string match at the beginning of the file extension
                # otherwise the above if/elif statements would have executed already.
                elif len(filename_s) > 1 and filename_s[-1] in file_ext:
                    file_new: str = out_flame_utils.out_check_build_file(file_s, filename_s[0], file_ext)

                else:
                    if not os.path.exists(file):
                        file_new: str = out_flame_utils.out_check_build_file(file_s, filename_s[0], file_ext)
                
                if file_new:
                    
                    # The following will allow network paths to work as well
                    
                    # Cache file_new split
                    file_new_split: tuple[str, str] = os.path.split(file_new)
                    file_new_name: str = file_new_split[1]
                    file_new_dir: str = file_new_split[0]
                    
                    # Lets check if the original output path is a valid location
                    if file_dir_is_valid:
                        _out_file = f"{file_dir}{'' if file_dir.endswith('/') else '/'}{file_new_name}"
                        
                    # Otherwise lets check if the generated output path is a valid location
                    elif os.path.isdir(file_new_dir):
                        _out_file = file_new
                    
                    # Otherwise get the expanded and corrected infile location and append the new filename to it
                    else:
                        _out_file = f"{file_s[0]}{'' if file_s[0].endswith('/') else '/'}{file_new_name}"
                    
                    # Check if there are messages worth printing
                    out_flame_utils.out_check_outpath_messages(node, file, file_new, file_ext, prx)
                    
                    # OUT
                    return out_flame_utils.out_file_cleanup(_out_file)
                        
                else:
                    return False

            if file:
                if f3h_tabs.OUT.DEFAULT_FILE_EXT == file_ext:
                    if out: _MSG: str = f"OUT: Select a valid OUT flame directory location."
                    else: _MSG: str = f"IN: Select a valid IN flame file path."
                    flam3h_general_utils.set_status_msg(f"{node.name()}.{_MSG}", 'WARN')
                    
            else:
                # If the path string is empty we do not want to print out
                flam3h_general_utils.set_status_msg('', 'MSG')
                
            return False
            
        # The following else statement is not really needed anymore
        # but until I do not remove the hidden toggle I leave it here.
        else:
            # just check if the user input is a valid location using cached checks
            if file_dir_is_valid or os.path.isdir(file_s[0]):
                return infile
            
            if file:
                if f3h_tabs.OUT.DEFAULT_FILE_EXT == file_ext:
                    _MSG: str = f"OUT: Select a valid OUT flame directory location." if out else f"IN: Select a valid IN flame file path."
                elif f3h_tabs.CP.DEFAULT_FILE_EXT == file_ext:
                    _MSG: str = f"CP: Select a valid OUT directory location."
                else:
                    _MSG: str = ""
                
                if _MSG:
                    flam3h_general_utils.set_status_msg(f"{node.name()}.{_MSG}", 'WARN')
            else:
                # If the path string is empty we do not want to print out
                flam3h_general_utils.set_status_msg('', 'MSG')
                
            return False
    
    
    @staticmethod
    def out_affine_rot(affine: TA_Affine, angleDeg: float) -> TA_Affine:
        """
        Rotate a 2D affine by a given angle in degrees for export.</br></br>

        Each affine has an internal angle parameter that rotates X/Y values. </br>
        When saving iterators using this angle, we need to apply the rotation</br>
        and export the resulting affine values so they can be restored correctly.</br>

        Args:
            affine (TA_Affine): X, Y, O affine components.
            angleDeg (float): Rotation angle in degrees.

        Returns:
            (TA_Affine): Rotated affine (X, Y, O) components.
        """
        # Early termination
        if angleDeg == 0.0:
            return affine

        # Otherwise do the calculations
        angleRad: float = hou.hmath.degToRad(angleDeg) # type: ignore
        m2: hou.Matrix2 = hou.Matrix2(affine[:2])
        rot: hou.Matrix2 = hou.Matrix2(((cos(angleRad), -sin(angleRad)), (sin(angleRad), cos(angleRad))))
        rotated: hou.Matrix2 = m2 * rot
        rotated_xy: tuple[tuple[float, ...], ...] = rotated.asTupleOfTuples()

        # Return rotated X/Y and original O
        return [rotated_xy[0], rotated_xy[1], affine[2]]
    
    
    @staticmethod
    def out_xaos_cleanup(xaos: TA_STR_ListUnflattened) -> TA_STR_ListUnflattened:
        """Remove all inactive iterators from each xaos weight list.</br>

        Args:
            xaos (TA_STR_ListUnflattened): All iterators xaos values.

        Returns:
           (TA_STR_ListUnflattened): an iterator Xaos cleaned up from the inactive iterator's values
        """
        _len: Callable[[str | list[str]], int] = len
        return [list(x[:_len(x) - next((i for i, v in enumerate(reversed(x)) if v != '1'), _len(x))]) for x in xaos]
    

    @staticmethod
    def out_xaos_collect(node: hou.SopNode, iter_count: int, prm: str) -> TA_XAOS_Collect:
        """Collect all xaos command string weights.</br>
        Provide also a form of Undo in the case we enter non numeric characters instead.</br>
        
        XAOS COMMAND OPTIONS:

        * If you type a non-numeric character in any of the xaos's weights,</br>
        FLAM3H™ will undo to what you had before.

        * If you dnt use the “ xaos: ” keywork at the beginning,</br>
        FLAM3H™ will undo to what you had before.

        * If you type a number,</br>
        the entire xaos string will be reset to all weights set to that number.

        * If you type a negative number, it will be reset to a value of: 1

        Args:
            node(hou.SopNode): FLAM3H™ node
            iter_count(int): Iterator's count
            prm(str): xaos varnote parameter

        Returns:
            (TA_XAOS_Collect): A list of list[str], list[float] or empty list.
        """   

        val: list = []
        val_prev: list[list[str]] | None = flam3h_iterator_utils.auto_set_xaos_data_get_XAOS_PREV(node)
        
        for iter in range(iter_count):
            
            # Get this iterator Xoas command string
            iter_xaos: str = node.parm(f"{prm}_{iter + 1}").eval()
            
            # If the xaos string is not empty
            if iter_xaos:
                
                strip: list[str] = iter_xaos.split(':')
                
                # if the first element of the strip is: "xaos"
                if strip[0].lower().replace(" ", "") == 'xaos':
                    
                    try:
                        _xaos: list[str] = strip[1:iter_count + 1]
                        _xf_val_cleanup_str: Callable[[str], str] = in_flame.xf_val_cleanup_str
                        if _xaos[0] and val_prev is not None and len(val_prev) == iter_count:
                            _xaos_strip: list[str] = [str(_val_now) if (_val_now := float(_xf_val_cleanup_str(str(x), val_prev[iter][idx]))) >= 0 else '1' for idx, x in enumerate(_xaos)]
                            
                        else:
                            # Otherwise use the safer version.
                            # This is used every time we add or remove an iterator or when loading Flames with different iterator's count than what we currently have.
                            _xaos_strip: list[str] = [str(_x_strip) if (_x_strip := float(str(x).strip())) >= 0 else '1' for x in _xaos if x]
                            
                        val.append([float(x.strip()) for x in _xaos_strip])
                        
                    except Exception as e: # I do not remember so lets try to catch one
                        print(f"FLAM3H™ Error\nPython {__py_version__} H21 UP\ndef out_xaos_collect(...)\nCaught an error: {type(e).__name__}: {e}")
                        if val_prev is not None:
                            val.append(val_prev[iter])
                            
                        else:
                            # Otherwise reset to all values of 1
                            val.append([])
                            
                # If the split fail to validate and it just start with the word: 'xaos'
                elif iter_xaos.lower().replace(" ", "").startswith('xaos'):
                    
                    if val_prev is not None:
                        # retrive from the history instead ( Undo )
                        val.append(val_prev[iter])
                    else:
                        # Otherwise reset to all values of 1
                        val.append([])
                        
                else:

                    isNUM: bool = False
                    iter_xaos_clean: str = in_flame.xf_val_cleanup_str(iter_xaos, '@') # default_val here is set to an invalid char to make it fail on purpose if needed
                    
                    try:
                        float(iter_xaos_clean)
                            
                    except ValueError:
                        pass
                    
                    else:
                        isNUM = True
                    
                    # If a number is typed, fill all xaos weights with that number.
                    if isNUM:
                        v: list[str] = [str((float(iter_xaos_clean))) if float(iter_xaos_clean) >= 0 else '1' for x in range(iter_count)]
                        val.append(v)
                        
                    else:
                        # if we entered an invalid string,
                        # retrive from the history instead ( Undo )
                        if val_prev is not None:
                            val.append(val_prev[iter])
                            
                        else:
                            # Otherwise reset to all values of 1
                            val.append([])
                            
            else:
                # Otherwise reset to all values of 1
                val.append([])
                
        return val


    @staticmethod
    def out_xaos_collect_vactive(node: hou.SopNode, fill: list[list[str]] | list[list[float]], prm: str) -> list[list[str] | list[Never]]:
        """Check for any NO-active iterators and account for those.</br>

        Args:
            node(hou.SopNode): FLAM3H™ node.
            fill(list[list[str]] | list[list[float]]): List of list representing all xaos weights.
            prm(str): iterator vactive parameter.

        Returns:
            (list[list[str] | list[Never]]): return a list of list[str] with the NO-active iterators taken into consideration.
        """    
        xaos_no_vactive: list[list[str] | list[Never]] = []
        for x in fill:
            collect: list[str] = [str(item) for idx, item in enumerate(x) if node.parm(f"{prm}_{idx + 1}").eval()]
            
            if collect:
                xaos_no_vactive.append(collect)
                
            else:
                xaos_no_vactive.append([])
                
        return xaos_no_vactive


    @staticmethod
    def _out_pretty_print(current: lxmlET._Element, parent: lxmlET._Element | None = None, index: int = -1, depth: int = 0) -> None: #type: ignore
        """Reformat the XML data in a pretty way.</br>

        Args:
            current(lxmlET._Element): The Flame XML root we want to reformat.
            parent(lxmlET.Element | None): Default to: None
            index(int): Default to: -1
            depth(int): Default to: 0(Zero)
        """

        for i, node in enumerate(current):
            out_flame_utils._out_pretty_print(node, current, i, depth + 1)

        if parent is not None:
            if index == 0:
                parent.text = '\n' + ('  ' * depth)
            else:
                parent[index - 1].tail = '\n' + ('  ' * depth)
            if index == len(parent) - 1:
                current.tail = '\n' + ('  ' * (depth - 1))
                
                
    @staticmethod
    def menu_out_presets_loop(menu: TA_Menu, i: int, item: str | list[Never]) -> None:
        """This is specifically to be run inside a list comprehension.</br>

        Args:
            menu(list): the menu list to populate.
            i(int): The outer loop index/iteration.
            item(str | list[NEver]): The outer loop item at index/iteration.</br>It can also be an empty list if the XML key is missing from the Flame preset we are trying to load.

        Returns:
            (None):
        """  
        # This undo's disabler is needed to make the undo work.  (probably not needed anymore)
        with hou.undos.disabler(): # type: ignore
            
            menu.append(str(i)) # This menu is a string parameter so I do believe this is the correct way
            menu.append(f"{f3h_icons.STAR_FLAME_SAVE_ENTRIE}  {item}     ")


    @staticmethod
    def menu_out_presets_loop_enum(menu: TA_Menu, i: int, item: str | list[Never]) -> None:
        """This is specifically to be run inside a list comprehension.</br>

        Args:
            menu(list): the menu list to populate.
            i(int): The outer loop index/iteration.
            item(str | list[Never]): The outer loop item at index/iteration.</br>It can also be an empty list if the XML key is missing from the Flame preset we are trying to load.

        Returns:
            (None):
        """  
        # This undo's disabler is needed to make the undo work.  (probably not needed anymore)
        with hou.undos.disabler(): # type: ignore
            
            menu.append(str(i)) # This menu is a string parameter so I do believe this is the correct way
            enum_label: str = str(i + 1) # start count from 1
            menu.append(f"{f3h_icons.STAR_FLAME_SAVE_ENTRIE}  {enum_label}:  {item}     ")
        
        
    @staticmethod
    def out_collect_var_section_names_dict(node: hou.SopNode, mode: bool = False, var_section: str = "VAR") -> dict[str, list[str]] | bool:
        """Collect all the variation's names inside any of the available sections (PRE, VAR, POST)</br>
        They will be built inside a dict with the keys representing the irterator number and the value the used variations collected inside a list.</br>
        For the FF, the dictionary key will always be 'FF'</br>
        
        
        Args:
            node(hou.SopNode): FLAM3H™ node
            mode(bool): Default to: False</br>False for iterators and True for FF.
            var_section(str): Default to: 'VAR'</br>Desired variation's section to query, Can be one of: 'PRE', 'VAR' or 'POST' keynames.

        Returns:
            (dict[str, list[str]] | bool): A dictionary of used variations in this iterator/xform/FF or False if none in the desired section (VAR, PRE, POST)
        """
        
        # Pick iterator type (regular or FF)
        f3h_iter: flam3h_iterator | flam3h_iterator_FF = flam3h_iterator_FF() if mode else flam3h_iterator()
        
        # Map section attributes dynamically
        suffix: str = "_FF" if mode else ""
        prm_sections_T = {
            "VAR": getattr(f3h_iter, f"sec_varsT{suffix}"),
            "PRE": getattr(f3h_iter, f"sec_prevarsT{suffix}"),
            "POST": getattr(f3h_iter, f"sec_postvarsT{suffix}")
        }
        prm_sections_W = {
            "VAR": getattr(f3h_iter, f"sec_varsW{suffix}"),
            "PRE": getattr(f3h_iter, f"sec_prevarsW{suffix}"),
            "POST": getattr(f3h_iter, f"sec_postvarsW{suffix}")
        }

        # Select correct parameter tuples
        T_tuple, W_tuple = prm_sections_T.get(var_section), prm_sections_W.get(var_section)
        if not T_tuple or not W_tuple:
            return False

        # Small optimization for the non-FF PRE section
        if not mode and var_section == "PRE":
            W_tuple = W_tuple[1:]
        
        # Shortcuts
        eval_parm = node.parm
        _in_get_dict_key_from_value: Callable[[dict[str, int], int], str] = in_flame_utils.in_get_dict_key_from_value

        names_idx: dict[str, list[str]] = {}

        if mode:  # FF
            if not node.parm(f3h_tabs.PREFS.PVT_PRM_DOFF).eval():
                return False

            names: list[str] = [_in_get_dict_key_from_value(VARS_FLAM3_DICT_IDX, eval_parm(T_tuple[i]).eval()) for i, prm in enumerate(W_tuple) if eval_parm(prm[0]).eval() != 0]
            if names:
                names_idx["FF"] = names

        else:  # Iterators
            iter_count: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
            for i in range(1, iter_count + 1):
                suffix = str(i)
                names = [_in_get_dict_key_from_value(VARS_FLAM3_DICT_IDX, eval_parm(f"{T_tuple[j]}{suffix}").eval()) for j, prm in enumerate(W_tuple) if eval_parm(f"{prm[0]}{suffix}").eval() != 0]
                if names:
                    names_idx[suffix] = names

        return names_idx or False


    @staticmethod
    def out_build_xf_names(f3d: out_flame_xforms_data) -> tuple[str, ...]:
        """Build the XML Flame iterator's names to account for inactive ierators if any.</br>
        If all are active or if an iterator has a custom name nothing will be changed.</br></br>
        
        The iterator's name *.strip() is probably not needed as they are stripped already during the XML data collection but why not.</br>

        Args:
            (self):
            f3d(out_flame_xforms_data): Class to pull the data from.

        Returns:
            (bool): A tuple of either the corrected names or the untouched ones.
        """

        # Shortcuts
        xf_name: tuple[str, ...] = f3d.xf_name
        xf_vactive: tuple[str, ...] = f3d.xf_vactive
        iter_count: int = f3d.iter_count
        _flam3h_iterator_is_default_name: Callable[[str, str], bool] = flam3h_iterator_utils.flam3h_iterator_is_default_name

        # build
        new_names: list[str] = []
        if '0' in xf_vactive:
            mp_idx: int = 1
            for i in range(iter_count):
                
                if int(xf_vactive[i]):
                    
                    if _flam3h_iterator_is_default_name((xfn := xf_name[i])) or not str(xfn).strip():
                        new_names.append(f"iterator_{mp_idx}")
                        
                    else:
                        new_names.append(xf_name[i])
                        
                    mp_idx = mp_idx + 1
                    
                else:
                    new_names.append('OFF')

            return tuple(new_names)
        
        return tuple(f"iterator_{i + 1}" if _flam3h_iterator_is_default_name((xfn := xf_name[i])) or not str(xfn).strip() else xfn for i in range(iter_count))


    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @property
    def kwargs(self) -> dict[str, Any]:
        return self._kwargs

    @property
    def node(self) -> hou.SopNode:
        return self._node

    @cached_slot_property
    def flam3h_iter_prm_names(self) -> flam3h_iterator_prm_names:
        return self._flam3h_iter_prm_names
    
    @cached_slot_property
    def flam3h_iter(self) -> flam3h_iterator:
        return self._flam3h_iter
    
    @cached_slot_property
    def flam3h_iter_FF(self) -> flam3h_iterator_FF:
        return self._flam3h_iter_FF
    
    @property
    def flam3h_do_FF(self) -> int:
        return self._flam3h_do_FF

    @property
    def iter_count(self) -> int:
        return self._iter_count

    @cached_slot_property
    def palette(self) -> hou.Ramp:
        return self._palette
    
    @property
    def palette_hsv_do(self) -> int:
        return self._palette_hsv_do
    
    @property
    def palette_plus_do(self) -> int:
        return self._palette_plus_do
    
    @property
    def f3h_affine(self) -> int:
        return self._f3h_affine
    
    @property
    def xm(self) -> int:
        return self._xm
    
    # custom to FLAM3H™ only
    
    @property
    def flam3h_rip(self) -> int:
        return self._flam3h_rip
    
    @property
    def flam3h_mb_do(self) -> int:
        return self._flam3h_mb_do
    
    @property
    def flam3h_f3c(self) -> int:
        return self._flam3h_f3c

    @property
    def flam3h_cp_lookup_samples(self) -> int:
        return self._flam3h_cp_lookup_samples
    
    @property
    def flam3h_cp_basis(self) -> int:
        return self._flam3h_cp_basis
    
    
    def get_iter_affine_pre(self, iterator_num: int) -> TA_Affine:
        """Return the selected iterator pre affine values in a list of tuples: X, Y, O</br>
        It does not collect the Rotation/Angle parameter, must collect this in a separate call if needed using: 
        * def get_iter_affine_pre_rot(self, iterator_num: int) -> float:
        
        Note:</br>
        This must run inside a for loop for each available iterator: e.g. for iter_idx in total_number_of_iterators:</br>
        The correct number of the iterator will be: (iter_idx + 1) as multi parameter indexes in FLAM3H™ start count from 1 and not from Zero

        Args:
            (self):
            iterator_num(int): the iterator number we want to collect the pre affine from. Note that from inside the for loop, the iterator number will be the loop iteration number + 1

        Returns:
            (TA_Affine):
        """
        return [self.node.parmTuple(f"{prm[0]}{iterator_num}").eval() for prm in self.flam3h_iter.sec_preAffine[:-1]]
    
    
    def get_iter_affine_pre_rot(self, iterator_num: int) -> float:
        """Return the selected iterator pre affine Rotation/Angle value.</br>
        
        Note:</br>
        This must run inside a for loop for each available iterator: e.g. for iter_idx in total_number_of_iterators:</br>
        The correct number of the iterator will be: (iter_idx + 1) as multi parameter indexes in FLAM3H™ start count from 1 and not from Zero

        Args:
            (self):
            iterator_num(int): the iterator number we want to collect the pre affine from. Note that from inside the for loop, the iterator number will be the loop iteration number + 1

        Returns:
            (float):
        """
        return self.node.parm(f"{self.flam3h_iter.sec_preAffine[-1][0]}{iterator_num}").eval()
    
    
    def get_iter_affine_post(self, iterator_num: int) -> TA_Affine:
        """Return the selected iterator post affine values in a list of tuples: X, Y, O</br>
        It does not collect the Rotation/Angle parameter, must collect this in a separate call if needed using:
        * def get_iter_affine_post_rot(self, iterator_num: int) -> float:
        
        Note:</br>
        This must run inside a for loop for each available iterator: e.g. for iter_idx in total_number_of_iterators:</br>
        The correct number of the iterator will be: (iter_idx + 1) as multi parameter indexes in FLAM3H™ start count from 1 and not from Zero

        Args:
            (self):
            iterator_num(int): the iterator number we want to collect the pre affine from. Note that from inside the for loop, the iterator number will be the loop iteration number + 1

        Returns:
            (TA_Affine):
        """
        return [self.node.parmTuple(f"{prm[0]}{iterator_num}").eval() for prm in self.flam3h_iter.sec_postAffine[1:-1]]
    
    
    def get_iter_affine_post_rot(self, iterator_num: int) -> float:
        """Return the selected iterator post affine Rotation/Angle value.</br>
        
        Note:</br>
        This must run inside a for loop for each available iterator: e.g. for iter_idx in total_number_of_iterators:</br>
        The correct number of the iterator will be: (iter_idx + 1) as multi parameter indexes in FLAM3H™ start count from 1 and not from Zero

        Args:
            (self):
            iterator_num(int): the iterator number we want to collect the pre affine from. Note that from inside the for loop, the iterator number will be the loop iteration number + 1

        Returns:
            (float):
        """
        return self.node.parm(f"{self.flam3h_iter.sec_postAffine[-1][0]}{iterator_num}").eval()
    
    
    def get_FF_affine_pre(self) -> TA_Affine:
        """Return the FF pre affine values in a list of tuples: X, Y, O</br>
        It does not collect the Rotation/Angle parameter, must collect this in a separate call if needed using:
        * def get_FF_affine_pre_rot(self) -> float:

        Args:
            (self):

        Returns:
            (TA_Affine):
        """
        return [self.node.parmTuple(f"{prm[0]}").eval() for prm in self.flam3h_iter_FF.sec_preAffine_FF[:-1]]
    
    
    def get_FF_affine_pre_rot(self) -> float:
        """Return the FF pre affine Rotation/Angle value.</br>

        Args:
            (self):

        Returns:
            (float):
        """
        return self.node.parm(f"{self.flam3h_iter_FF.sec_preAffine_FF[-1][0]}").eval()
    
    
    def get_FF_affine_post(self) -> TA_Affine:
        """Return the FF post affine values in a list of tuples: X, Y, O</br>
        It does not collect the Rotation/Angle parameter, must collect this in a separate call if needed using:
        * def get_FF_affine_post_rot(self) -> float:

        Args:
            (self):

        Returns:
            (TA_Affine):
        """
        return [self.node.parmTuple(f"{prm[0]}").eval() for prm in self.flam3h_iter_FF.sec_postAffine_FF[1:-1]]
    
    
    def get_FF_affine_post_rot(self) -> float:
        """Return the FF post affine Rotation/Angle value.</br>

        Args:
            (self):

        Returns:
            (float):
        """
        return self.node.parm(f"{self.flam3h_iter_FF.sec_postAffine_FF[-1][0]}").eval()
    
    
    def out_to_flam3h_init_data_quick(self, node: hou.SopNode, tab: str = 'OUT') -> tuple[str | None, int]:
        """Load a flame preset and gather some data.</br>

        Args:
            (self):
            node(hou.SopNode): FLAM3H™ node to load the flame file/preset into.
            tab(str): Default to: "OUT" (for the OUT tab)</br>Set it to "SYS" for the sys tab out preset menu to be evaluated.

        Returns:
            (tuple[Union[str, None], int]):  tuple( xml, 
                                                    preset_id, 
                                                    )

                                                    * xml: either a flame preset from a flame file or from the Clipboard.
                                                    * preset_id: flame preset index. From clipboard will always be ZERO.
    """
        xml: str = os.path.expandvars(node.parm(f3h_tabs.OUT.PRM_PATH).eval())
        
        # Get the correct menu parameter's preset idx
        if node.parm(f3h_tabs.OUT.PVT_PRM_ISVALID_FILE).eval():
            if tab.upper() == 'OUT':
                preset_id: str = node.parm(f3h_tabs.OUT.PRM_PRESETS).eval()
            
            elif tab.upper() == 'SYS':
                preset_id: str = node.parm(f3h_tabs.OUT.PRM_SYS_PRESETS).eval()
            
            else:
                preset_id = '0'
            
            return xml, int(preset_id)
        
        return None, 0
        
        
    def out_to_flam3h_quick(self, tab: str = 'OUT') -> None:
        """Load a Flame preset to then print its compact infos into the status bar and flash message for purely informational purpose.</br></br>
        
        This is done so instead of having just a list of the Flames included into the file as a menu,</br>
        we can also gather a bit of infos quickly every time we select a menu entrie.</br></br>
        
        The infos are:
        * Flame preset name.
        * Number of iterators/xforms.
        * Is it using a finalXform(FF) ?
        * How many colors in the palette. If something goes wrong it will report: -1 .
        * Is the palette using the HSV color correction ?
        * The HSV values being used.
        
        Args:
            (self):
            tab(str): Default to: "OUT" (for the OUT tab)</br>Set it to "SYS" for the sys tab out preset menu to be evaluated.
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        _FLAM3H_INIT_DATA: tuple[str | None, int] = self.out_to_flam3h_init_data_quick(node, tab)
        xml, preset_id = _FLAM3H_INIT_DATA

        if xml is not None and _xml_tree(xml).isvalidtree:

            # IN flame preset data
            apo_data: in_flame_iter_data = in_flame_iter_data(node, xml, preset_id)
            name: str = apo_data.name[preset_id]
            
            # If there are xforms/iterators
            if apo_data.xforms is not None:
                
                build: list[str] = []
                build_flash: list[str] = []
                n_xf: int = len(apo_data.xforms)
                build.append(f"XF: {n_xf}")
                
                palette: int = -1
                if apo_data.palette is not None:
                    
                    palette = len(apo_data.palette[0].keys())
                    build.append(f"Palette: {palette}")
                    build_flash: list[str] = build.copy()
                    if apo_data.cp_flam3h_hsv is not False:
                        assert isinstance(apo_data.cp_flam3h_hsv, hou.Vector3)
                        build_flash.append('HSV')
                        hsv_val: str = f"({', '.join([str(val) for val in apo_data.cp_flam3h_hsv])})"
                        build.append(f"HSV: {hsv_val}")
                        
                    basis: str = f3h_tabs.CP.PRM_RAMP_LOOKUP_SAMPLES_BASES_DICT[apo_data.cp_flam3h_basis]
                    build.append(f"Basis: {basis}")
                    build_flash.append(basis)
                    
                else:
                    build.append('Palette not Found')
                    build_flash = build.copy()
                
                # As last, so we dnt add those to the build_flash list
                if apo_data.prefs_flam3h_f3c is not None and apo_data.prefs_flam3h_f3c:
                    build.insert(0, 'F3C')
                if apo_data.sys_flam3h_rip is not None and apo_data.sys_flam3h_rip:
                    build.insert(0, 'RIP')
                if apo_data.finalxform is not None: 
                    build.insert(0,'FF')
                    build_flash.insert(0,'FF') # also in the build flash message string
                
                # Build and Display infos
                _MSG: str = ', '.join(build)
                _MSG_FLASH: str = ', '.join(build_flash)
                flam3h_general_utils.set_status_msg(f"Name: {name}  ->  {_MSG}", 'MSG')
                flam3h_general_utils.flash_message(node, _MSG_FLASH)
                
            else:
                _MSG: str = f"ZERO xforms"
                flam3h_general_utils.set_status_msg(f"Name: {name}  ->  {_MSG}", 'WARN')
                flam3h_general_utils.flash_message(node, f"{_MSG}")
                
        else:
            _MSG: str = f"Load a valid OUT flame file first"
            flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'WARN')
            flam3h_general_utils.flash_message(node, f"{_MSG}")


    def out_palette_256_plus_check(self) -> None:
        """When activating the PREFS option: palette 256+ toggle,</br>
        let the user knows if the current palette posses enough colors and give some infos.</br>

        Args:
            (self):

        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        prm_prefs_256_plus = self.kwargs['parm']
        rmp_src: hou.Ramp = node.parm(f3h_tabs.CP.PRM_RAMP_SRC_NAME).evalAsRamp()
        if prm_prefs_256_plus.eval():
            
            if len(rmp_src.keys()) <= 256:
                _MSG: str = f"PALETTE 256+ ACTIVE but the CP palette do not have more than 256 color keys ({len(rmp_src.keys())})."
                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} The Flame will be saved with a Palette sampled at 256 color keys, which is the standard for fractal flames.", 'IMP')
                
            else:
                _MSG: str = f"OUT palette 256+: ON"
                flam3h_general_utils.flash_message(node, _MSG)
                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'IMP')
        else:
            _MSG: str = f"OUT palette 256+: OFF"
            flam3h_general_utils.flash_message(node, _MSG)
            flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} - The number of palette color keys are: {len(rmp_src.keys())}", 'MSG')


    def out_presets_get_selected_menu_label(self) -> str | None:
        """Get the currently selected OUT preset menu label string.</br>

        Args:
            (self):

        Returns:
            (str | None): The selected menu preset menu label string if any or None
        """
        node: hou.SopNode = self.node

        if node.parm(f3h_tabs.OUT.PVT_PRM_ISVALID_FILE).eval():
            toggle_PREFS_ENUMERATE_MENU: int = node.parm(f3h_tabs.PREFS.PRM_ENUMERATE_MENU).eval()
            preset_id: int = int(node.parm(f3h_tabs.OUT.PRM_PRESETS).eval())
            menu_label: str = str(node.parm(f3h_tabs.OUT.PRM_PRESETS).menuLabels()[preset_id]).split(f3h_icons.STAR_FLAME_SAVE_ENTRIE)[-1].strip()

            if toggle_PREFS_ENUMERATE_MENU:
                # We are using "str.lstrip()" because the preset name has been "str.strip()" already in the above line.
                # and there are only the leading white spaces left from the menu enumaration index number string to remove.
                flame_name: str = ':'.join(str(menu_label).split(':')[1:]).lstrip()
                
            else:
                flame_name: str = menu_label
                
            return flame_name
        
        return None
    
    
    def out_presets_copy_menu_label_callback(self) -> None:
        """Get the currently selected OUT preset menu label string and copy it into the OUT Flame name parameter string field.</br></br>
        
        Additionally:
        - [SHIFT+LMB] to display quick informations message about the selected OUT Flame preset
        - [CTRL+LMB] to display informations about the Flame name tips
        - [ALT+LMB] to copy the selected OUT Flame preset into the Clipboard.
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        
        node: hou.SopNode = self.node
        kwargs: dict = self.kwargs
        
        if kwargs['shift']:
            out_flame_utils(kwargs).out_to_flam3h_quick()
            
        elif kwargs['ctrl']:
            flam3h_ui_msg_utils(kwargs).ui_OUT_presets_name_infos()
            
        elif kwargs['alt']:
            self.out_preset_XML_clipboard()
            
        else:
            if node.parm(f3h_tabs.OUT.PVT_PRM_ISVALID_FILE).eval():
                menu_label: str | None = self.out_presets_get_selected_menu_label()
                if menu_label is not None:
                    flame_name: str = self.out_remove_iter_num(menu_label)
                    iter_num: int = node.parm(f3h_tabs.GLB.PRM_ITERATIONS).eval()
                    autoadd: int = node.parm(f3h_tabs.OUT.PRM_AUTO_ADD_ITER_NUM).eval()
                    flame_name_new: str = self.out_auto_add_iter_num(iter_num, flame_name, autoadd)
                    
                    prm = node.parm(f3h_tabs.OUT.PRM_FLAME_PRESET_NAME)
                    flam3h_prm_utils.set(node, prm, flame_name_new)

                    _MSG: str = f"{node.name()}: COPY Flame name: {flame_name_new}"
                    flam3h_general_utils.set_status_msg(_MSG, 'MSG')
                    flam3h_general_utils.flash_message(node, f"{flame_name_new}")
                    
                else:
                    _MSG: str = f"{node.name()}: COPY Flame name: Select an existing preset name. There are no presets to copy the name from."
                    flam3h_general_utils.set_status_msg(_MSG, 'WARN')
            else:
                _MSG: str = f"Load a valid OUT flame file first"
                flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG} to COPY its Flame preset names into the Flame name string parameter.", 'WARN')
                flam3h_general_utils.flash_message(node, f"{_MSG}")
                
                
    def out_palette_keys_count(self, palette_plus: int, keys: int, type: int, _MSG = True) -> str:
        """This is used to find the number of colors we want to export when saving out a Flame file.</br>
        We need to always export as many colors to include the current color keys count in the palette based on a predefined set of value.</br></br>
        
        So for example,</br>
        if the current palette posses 270 color keys,</br>
        we will export using the closest but greater menu entry whitch is: 512 (the smaller being: 256).</br></br>
        
        The minimum will always be clamped at: 256

        Args:
            (self):
            palette_plus(bool): "save palette 256+" toggle parameter value.
            keys(int): number of color keys in the palette.
            type(int): 0(Zero) for a Flame and 1 for a Palette.
            _MSG:(bool): Default to: True</br>Print a warning message or not.

        Returns:
            (str): number of color to export
        """  

        if palette_plus:
            
            if keys <= 1024:
                
                if keys <= 256:
                    
                    if not type:
                        # For a Flame
                        return f3h_tabs.CP.DEFAULT_COUNT_256
                    
                    # For a palette
                    return flam3h_palette_utils.get_ramp_keys_count(self.palette)
                
                return str(flam3h_palette_utils.find_nearest_idx(f3h_tabs.CP.DEFAULT_MENU_OPTIONS_PLUS, keys))
            
            # Otherwise clamp to 1024 color keys
            if _MSG:
                print(f"Warning:\n{self.node.name()}: the palette exceed the allowed amount of color keys and it has been clamped at: 1024\n")
            return f3h_tabs.CP.DEFAULT_COUNT_1024
        
        # Otherwise always export the Flame with 256 color palette
        return f3h_tabs.CP.DEFAULT_COUNT_256


    def __menu_sensor_resolution(self) -> TA_Menu:
        """ NOT USED ANYMORE</br>
        and it has been prefixed with two underscores (__)</br>
        as the menu is now pre computed inside: MENU_SENSOR_RESOLUTIONS</br>
        I leave it here for future needs to re-generate the menu with new entries.</br></br>
        
        Build sensor resolution menu parameter with a list of options.</br>
        
        Args:
            (self):
            
        Returns:
            (TA_Menu): Return a menu
        """

        outedit = self.node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_EDIT).eval()
        menu: TA_Menu = []
        menuitems: tuple[str, ...] = ()
        if outedit:
            menuitems = ("", "640x480", "HDTV 720", "HDTV 1080", "HDTV 2160 (4K)", # 1 2 3 4
                        "", "NTSC", "NTSC D1", "PAL", "PAL 16:9 (1 to 1)", # 6 7 8 9
                        "", "Full Ap 4K", "Full Ap 2K", "Acad 4K", "Acad 2K", "Scope 4K", "Scope 2K", "Vista 2K", # 11 12 13 14 15 16 17
                        "", "256^2", "512^2", "1024^2", "2048^2", "4096^2", ""  ) # 19 20 21 22 23
        else:
            menuitems = ( "",)
            
        for i, item in enumerate(menuitems):
            menu.append(i)
            menu.append(item)
            
        return menu
    
    
    def menu_sensor_resolution(self) -> TA_Menu:
        """ Pre computed menu: MENU_SENSOR_RESOLUTIONS</br></br>
        The old sensor resolution menu definition has been renamed to:
        * def __menu_sensor_resolution(self) -> TA_Menu: (just above)
        
        Output sensor resolution menu parameter with a list of options.
        
        Args:
            (self):
            
        Returns:
            (TA_Menu): Return a menu
        """
        return MENU_OUT_SENSOR_RESOLUTIONS


    def menu_sensor_resolution_set(self, update: bool=True) -> None:
        """Set sensor resolution parameter based on user choice.</br>
        
        Args:
            (self):
            update(bool): Default to: True</br>False if we want to update the OUT Sensor front viewer
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        sel: int = int(node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_RES_PRESETS_MENU).eval())
        res: dict[int, tuple[int, ...] | None] = {  -1: None, 1: (640, 480), 2: (1280, 720), 3: (1920, 1080), 4: (3840, 2160), # 1 2 3 4
                                                    -1: None, 6: (640, 486), 7: (720, 486), 8: (768, 586), 9: (1024, 576), # 6 7 8 9
                                                    -1: None, 11: (4096, 3112), 12: (2048, 1556), 13: (3656, 2664), 14: (1828, 1332), 15: (3656, 3112), 16: (1828, 1556), 17: (3072, 2048), # 11 12 13 14 15 16 17
                                                    -1: None, 19: (256, 256), 20: (512, 512), 21: (1024, 1024), 22: (2048, 2048), 23: (4096, 4096), # 19 20 21 22 23
                                                    -1: None 
                                                    }
 
        if res.get(sel) is not None:
            flam3h_prm_utils.set(node, str(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_SIZE)), hou.Vector2(res.get(sel)))

            if update:
                flam3h_general_utils(self.kwargs).util_set_front_viewer()
            else:
                update_sensor: int = node.parm(f3h_tabs.OUT.PRM_UPDATE_SENSOR).eval()
                if update_sensor:
                    flam3h_general_utils(self.kwargs).util_set_front_viewer()
        
        # reset to null value so we can set the same preset again
        node.parm(f3h_tabs.OUT.PRM_RENDER_PROPERTIES_RES_PRESETS_MENU).set('0')


    def reset_OUT_sensor(self) -> None:
        """Reset the OUT Camera sensor settings parameters tab.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        
        node: hou.SopNode = self.node
        
        parms_out_sensor_data: dict[str | None, hou.Vector2 | float] = {XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_SIZE): hou.Vector2((1024, 1024)),    # tuple
                                                                        XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CENTER): hou.Vector2((0, 0)),  # tuple
                                                                        XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_ROTATE): 0,
                                                                        XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_SCALE): 400
                                                                        }
        
        flam3h_prm_utils.setParms(node, parms_out_sensor_data)
        
    def reset_OUT_render(self) -> None:
        """Reset the OUT Render settings parameters tab.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        parms_out_render_data: dict[str | None, int | float] = {XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_QUALITY): 1000,
                                                                XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_BRIGHTNESS): 3,
                                                                XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_GAMMA): 2.5,
                                                                XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_POWER): 5,
                                                                XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_K2): 0,
                                                                XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_VIBRANCY): 0.3333
                                                                }
        
        flam3h_prm_utils.setParms(node, parms_out_render_data)


    def reset_OUT_kwargs(self) -> None:
        """Build a multifunctional reset OUT render properties method.</br>
        IT will allow to reset the entire tab or either only the Sensor or Render settings tab.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        # Check and Update this data
        flam3h_iterator_utils(self.kwargs).update_xml_last_loaded()
        
        kwargs: dict = self.kwargs
            
        if kwargs['shift']:
            # Reset only the Camera Sensor
            self.reset_OUT_sensor()
            flam3h_general_utils.flash_message(self.node, f"OUT Camera sensor: RESET")
            
        elif kwargs['ctrl']:
            # Reset only the Render settings
            self.reset_OUT_render()
            flam3h_general_utils.flash_message(self.node, f"OUT Render settings: RESET")
            
        elif kwargs['alt']:
            # Copy only the Render Properties of a Flame preset from the Clipboard
            in_flame_utils(self.kwargs).in_to_flam3h_render_properties_only()
            
        else:
            # Reset all render properties
            self.reset_OUT_sensor()
            self.reset_OUT_render()
            self.out_render_curves_set_and_retrieve_defaults(kwargs['node'])
            flam3h_general_utils.flash_message(self.node, f"OUT Render properties: RESET")
        
        if self.node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
            flam3h_general_utils(self.kwargs).util_set_front_viewer()


    def reset_OUT_options(self) -> None:
        """Reset the OUT save options tab parameters.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        options_dict: dict[str, int] = {f3h_tabs.OUT.PRM_HSV_PALETTE_DO: 0, 
                                        f3h_tabs.OUT.PRM_FLAM3H_AFFINE_STYLE: 1, 
                                        f3h_tabs.OUT.PRM_USE_FRACTORIUM_PRM_NAMES: 1, 
                                        f3h_tabs.OUT.PRM_AUTO_ADD_ITER_NUM: 1
                                        }
        
        flam3h_prm_utils.setParms(node, options_dict)


    def reset_OUT(self, mode: int=0) -> None:
        """Reset the OUT flame render properties to their default.</br>

        Args:
            mode(int): Default to: 0(Zero)</br>1 will reset the remainder of the parameters.

        Returns:
            (None):
        """
        node: hou.SopNode = self.node

        self.reset_OUT_options()
        self.reset_OUT_sensor()
        self.reset_OUT_render()
        
        # If we are in sensor viz and we reset, make sure the sensor is framed properly.
        if node.parm(f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR).eval():
            flam3h_general_utils(self.kwargs).util_set_clipping_viewers()
            flam3h_general_utils(self.kwargs).util_set_front_viewer()
            
        # I do not think this is used anymore but I leave it here 
        # until I make a cleanup pass of this code.
        if mode == 0:
            flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_RENDER_PROPERTIES_SENSOR, 0)

            parms_dict: dict = {f3h_tabs.OUT.MSG_PRM_OUT: '', 
                                f3h_tabs.OUT.PRM_RENDER_PROPERTIES_EDIT: 0, }
            flam3h_prm_utils.setParms(node, parms_dict)
        
        # I do not think this is used anymore but I leave it here 
        # until I make a cleanup pass of this code.
        if mode == 2:            
            parms_dict: dict = {f3h_tabs.OUT.PRM_PATH: '', 
                                f3h_tabs.OUT.PRM_HSV_PALETTE_DO: 0, 
                                f3h_tabs.OUT.PRM_PRESETS: str(-1), 
                                f3h_tabs.OUT.PRM_SYS_PRESETS: str(-1), 
                                f3h_tabs.OUT.PRM_FLAME_PRESET_NAME: ''}
            flam3h_prm_utils.setParms(node, parms_dict)


    def out_xf_xaos_to(self) -> tuple[str, ...]:
        """Export in a tuple[str] the xaos TO values to write out.</br>
        
        Args:
            (self):

        Returns:
            (tuple): the xaos TO values to write out.
        """
        val: TA_XAOS_Collect = self.out_xaos_collect(self.node, self.iter_count, self.flam3h_iter_prm_names.xaos)
        fill: list[list[str]] = [np_pad(item, (0,self.iter_count - len(item)), 'constant', constant_values = 1).tolist() for item in val]
        xaos_vactive: list[list[str] | list[Never]] = self.out_xaos_collect_vactive(self.node, fill, self.flam3h_iter_prm_names.main_vactive)
        _join: Callable[[Iterable[str]], str] = ' '.join

        return tuple(_join(x) for x in self.out_xaos_cleanup(self.out_util_round_floats(xaos_vactive)))


    def out_xf_xaos_from(self, mode: int = 0) -> tuple[str, ...]:
        """Export in a tuple[str] the xaos FROM values to write out.</br>
        
        Args:
            mode(int): Default to: 0</br>mode=1 is for writing out flame file</br>while the default mode=0 is for converting between xaos modes only
            
        Returns:
            (tuple): the xaos FROM values transposed into xaos TO values to write out.
        """
        val: TA_XAOS_Collect = self.out_xaos_collect(self.node, self.iter_count, self.flam3h_iter_prm_names.xaos)
        fill: list[NDArray] = [np_pad(item, (0,self.iter_count - len(item)), 'constant', constant_values = 1) for item in val]
        t: list[list[float]] = np_transpose(np_resize(fill, (self.iter_count, self.iter_count))).tolist()
        _join: Callable[[Iterable[str]], str] = ' '.join
        if mode:
            xaos_vactive: list[list[str] | list[Never]] = self.out_xaos_collect_vactive(self.node, t, self.flam3h_iter_prm_names.main_vactive)
            return tuple(_join(x) for x in self.out_xaos_cleanup(self.out_util_round_floats(xaos_vactive)))
        
        return tuple(_join(x) for x in self.out_util_round_floats(t))


    def menu_out_contents_presets_data(self, node: hou.SopNode, xml_file_path: str, xml_is_file: bool) -> TA_Menu:
        """Populate OUT parameter menu items for the SYS and OUT tab.</br>
        
        Args:
            (self):
            node(hou.SopNode): this FLAM3H™ node
            xml_file_path(str): the OUT_PATH parameter string.
            xml_is_valid(bool): wether the xml_file_path file is an existing file. True or False

        Returns:
            (TA_Menu): Return a menu
        """
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            # For the OUT Tab menu presets we are forced to use the class: _xml_tree(...)
            # Instead of the lightweight version class: _xml(...)
            apo_data: _xml_tree = _xml_tree(xml_file_path)
            
            if apo_data.isvalidtree:
                
                enum: bool = node.parm(f3h_tabs.PREFS.PRM_ENUMERATE_MENU).eval()
                
                _menu_func: Callable[[TA_Menu, int, str | list[Never]], None] = (self.menu_out_presets_loop_enum if enum else self.menu_out_presets_loop)
                
                preset_names: list = apo_data.name
                
                menu: TA_Menu = []
                for i, item in enumerate(preset_names):
                    _menu_func(menu, i, item)

                node.setCachedUserData(f3h_cachedUserData.out_presets_menu, menu)
                return menu
            
            flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.out_presets_menu)
            head_tail: tuple[str, str] = os.path.split(xml_file_path)
            if not xml_is_file and os.path.isdir(head_tail[0]):
                return f3h_menus.PRESETS_SAVEONE
            
            elif not xml_is_file:
                return f3h_menus.PRESETS_INVALID
            
            else:
                return f3h_menus.PRESETS_EMPTY
        
        
    def menu_out_contents_presets(self) -> TA_Menu:
        """Rerturn either a cached menu data or rebuild that data on the fly if needed.</br>

        Args:
            (self):

        Returns:
            (TA_Menu): Return a menu
        """
        
        node: hou.SopNode = self.node
        if hou.isUIAvailable() is False: node.updateParmStates()
        
        # Cache parm reads to avoid repeated evaluations
        out_path: str = node.parm(f3h_tabs.OUT.PRM_PATH).eval()
        
        # quick return
        if not out_path:
            return f3h_menus.PRESETS_EMPTY
        
        # This undo's disabler is needed to make the undo work. 
        with hou.undos.disabler(): # type: ignore
            
            data: TA_Menu | None = node.cachedUserData(f3h_cachedUserData.out_presets_menu)
            
            # Double check
            xml_file_path: str = os.path.expandvars(out_path) if out_path else ''
            xml_is_file: bool = os.path.isfile(xml_file_path) if xml_file_path else False
            
            if xml_file_path and not xml_is_file:
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_ISVALID_FILE, 0)
                data = None
            elif xml_file_path and xml_is_file:
                # This caused some pain becasue it is forcing us not to tell the truth sometime
                # but its quick and we added double checks for each file types (Palette or Flame) inside each menus empty presets (CP, IN and OUT)
                flam3h_prm_utils.private_prm_set(node, f3h_tabs.OUT.PVT_PRM_ISVALID_FILE, 1)
                
            if data is not None:
                return data
            
            return self.menu_out_contents_presets_data(node, xml_file_path, xml_is_file)

    
    def out_auto_add_iter_data(self) -> tuple[int, str, int]:
        """Collect data needed by:</br>
        
        * def out_auto_add_iter_num_to_prm()
        * def out_auto_change_iter_num_to_prm()
        
        Args:
            (self):

        Returns:
            (tuple[int, str, int]): A tuple with the needed data
        """
        node: hou.SopNode = self.node
        iter_num: int = node.parm(f3h_tabs.GLB.PRM_ITERATIONS).eval()
        flame_name: str = str(node.parm(f3h_tabs.OUT.PRM_FLAME_PRESET_NAME).eval()).strip()
        autoadd: int = node.parm(f3h_tabs.OUT.PRM_AUTO_ADD_ITER_NUM).eval()
        
        return iter_num, flame_name, autoadd


    def out_auto_add_iter_num_to_prm(self) -> None:
        """Add the iteration number string to the OUT Flame name after you type a name string in.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        iter_num, flame_name, autoadd = self.out_auto_add_iter_data()
        flame_name_new: str = self.out_auto_add_iter_num(iter_num, flame_name, autoadd)
        
        prm = node.parm(f3h_tabs.OUT.PRM_FLAME_PRESET_NAME)
        flam3h_prm_utils.set(node, prm, flame_name_new)


    def out_auto_change_iter_num_to_prm(self, name: str | None = None) -> None:
        """Change the iteration number string to the OUT Flame name when you change FLAM3H™ iterations.</br>
        
        Args:
            (self):
            name(str | None): Default to: None (nothing happen).</br>Handy to automatically set the out preset name when an IN preset name is loaded.
            
        Returns:
            (None):
        """      
        node: hou.SopNode = self.node
        iter_num, flame_name, autoadd = self.out_auto_add_iter_data()
        in_flame_name_auto_file: int = node.parm(f3h_tabs.OUT.PRM_IN_FLAME_NAME_AUTO_FILL).eval()
        if name is not None and in_flame_name_auto_file: flame_name = name
        
        if flame_name:
            
            prm = node.parm(f3h_tabs.OUT.PRM_FLAME_PRESET_NAME)
            prm.lock(False)
            prm.deleteAllKeyframes()
            
            if autoadd:
                flame_name_new: str = self.out_auto_change_iter_num(iter_num, flame_name, autoadd)
                prm.set(flame_name_new)
                
                # Update "iter num on load" if "force iterations on Load" toggle is ON 
                if node.parm(f3h_tabs.IN.PRM_USE_ITER_ON_LOAD).eval():
                    flam3h_prm_utils.set(node, f3h_tabs.IN.PRM_ITER_NUM_ON_LOAD, iter_num)
            else:
                flame_name_new: str = self.out_remove_iter_num(flame_name)
                prm.set(flame_name_new)
                
            # Flash message if needed.
            # I need to come back on this and see exactly when firing the flash message, for now is not bad.
            if flame_name_new:
                flam3h_general_utils.flash_message(node, f"{flame_name_new}")
                
                
    def out_flame_name_inherit_on_load(self) -> None:
        """When this option is toggled ON,</br>
        cause the Flame name parameter to be set to the currently loaded Flame preset name.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """  
        if self.kwargs['parm'].eval():
            
            node: hou.SopNode = self.node
            inisvalidfile: int = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_FILE).eval()
            inisvalidpreset: int = node.parm(f3h_tabs.IN.PVT_PRM_ISVALID_PRESET).eval()
            clipboard: int = node.parm(f3h_tabs.IN.PVT_PRM_CLIPBOARD_TOGGLE).eval()
            xml: str = os.path.expandvars(node.parm(f3h_tabs.IN.PRM_PATH).eval())
            xml_isFile: bool = os.path.isfile(xml) if xml else False
            
            prm = node.parm(f3h_tabs.OUT.PRM_FLAME_PRESET_NAME)
            prm.lock(False)
            prm.deleteAllKeyframes()
            
            # Only if a valid preset has been loaded from a disk file ( not clipboard )
            if xml and xml_isFile and inisvalidfile and inisvalidpreset and not clipboard:
                # Build the apo data
                preset_id: int = int(node.parm(f3h_tabs.IN.PRM_PRESETS).eval())
                apo_data: in_flame_iter_data = in_flame_iter_data(node, xml, preset_id)
                
                if apo_data.isvalidtree:
                    prm.set(apo_data.name[preset_id])
                    # Updated the Flame name iter num if exist and if needed
                    self.out_auto_change_iter_num_to_prm()
                    
            elif inisvalidpreset and clipboard:
                data: str | None = node.userData(f3h_userData.XML_LAST)
                if data is not None:
                    apo_data: in_flame_iter_data = in_flame_iter_data(node, data, 0)
                    if apo_data.isvalidtree:
                        prm.set(apo_data.name[0])
                        # Updated the Flame name iter num if exist and if needed
                        self.out_auto_change_iter_num_to_prm()
                

    def out_flame_properties_build(self, f3r: out_flame_render_properties) -> dict:
        """Return a dictionary with all the flame properties to be written out.</br></br>
        
        Note:</br>
            Any of these properties will not be included into the exported XML flame file if they are: False

        Args:
            (self):
            f3r(out_flame_render_properties): Flame render properties class

        Returns:
            (dict): a dictionary with all the flame properties to written out
        """   
        # If "use Fractorium parametric prm names" OUT option is ON, lets append the EMBER name to the app name
        # so that we can pick up the proper parametric parameter names if we load it back in Houdini.
        if self.node.parm(f3h_tabs.OUT.PRM_USE_FRACTORIUM_PRM_NAMES).eval(): _XML_APP_NAME = f"{xml_keys.XML_APP_NAME_FRACTORIUM}-{xml_keys.XML_APP_NAME_FLAM3H}"
        else: _XML_APP_NAME = xml_keys.XML_APP_NAME_FLAM3H
        
        return {xml_keys.XML_VERSION: f'{_XML_APP_NAME}-{flam3h_general_utils.my_system()}-{__version__}',
                xml_keys.XML_XF_NAME: f3r.flame_name,
                xml_keys.f3h.XML_RIP: f3r.flam3h_sys_rip, # custom to FLAM3H™ only
                xml_keys.f3h.XML_HSV: f3r.flam3h_cp_hsv, # custom to FLAM3H™ only
                xml_keys.f3h.XML_MB_FPS: f3r.flam3h_mb_fps, # custom to FLAM3H™ only
                xml_keys.f3h.XML_MB_SAMPLES: f3r.flam3h_mb_samples, # custom to FLAM3H™ only
                xml_keys.f3h.XML_MB_SHUTTER: f3r.flam3h_mb_shutter, # custom to FLAM3H™ only
                xml_keys.f3h.XML_CP_SAMPLES: f3r.flam3h_cp_samples, # custom to FLAM3H™ only
                xml_keys.f3h.XML_CP_SAMPLES_BASIS: f3r.flam3h_cp_basis, # custom to FLAM3H™ only
                xml_keys.f3h.XML_F3C: f3r.flam3h_prefs_f3c, # custom to FLAM3H™ only
                xml_keys.XML_SIZE: f3r.flame_size, 
                xml_keys.XML_CENTER: f3r.flame_center,
                xml_keys.XML_SCALE: f3r.flame_scale,
                xml_keys.XML_ROTATE: f3r.flame_rotate,
                xml_keys.XML_BG: '0 0 0', # This probably will be made available to the end user at some point, eventually. For now always a black background.
                xml_keys.XML_SUPERSAMPLE: '2',
                xml_keys.XML_FILTER: '0.5',
                xml_keys.XML_QUALITY: f3r.flame_quality,
                xml_keys.XML_BRIGHTNESS: f3r.flame_brightness,
                xml_keys.XML_GAMMA: f3r.flame_gamma,
                xml_keys.XML_GAMMA_THRESHOLD: '0.0423093658828749',
                xml_keys.XML_K2: f3r.flame_k2,
                xml_keys.XML_VIBRANCY: f3r.flame_vibrancy,
                xml_keys.XML_POWER: f3r.flame_highlight,
                xml_keys.XML_RADIUS: '9',
                xml_keys.XML_ESTIMATOR_MINIMUM: '0',
                xml_keys.XML_ESTIMATOR_CURVE: '0.4',
                xml_keys.XML_PALETTE_MODE: f3r.flame_cp_mode,
                xml_keys.XML_INTERPOLATION: 'linear',
                xml_keys.XML_INTERPOLATION_TYPE: 'log'
                }
        

    def out_flam3_compatibility_check_and_msg(self) -> bool:
        """Check if the Flame we want to write out is compatible with the FLAM3 flame format.</br>
        If not, print out details to let us know what is wrong with it.</br>

        Args:
            (self):
            
        Returns:
            (bool): Return True if the Flame is valid or False if not.
        """
        node: hou.SopNode = self.node
        
        # Here we are adding POST VARS and FF PRE VARS even tho they are only one slot,
        # just in case in the future I add more.
        bool_VARS_PRE = bool_VARS = bool_VARS_POST = bool_VARS_PRE_FF = bool_VARS_FF = bool_VARS_POST_FF = False
        
        # Iterators: duplicates check
        #############################################################################
        iter_PRE: dict[str, list[str]] | bool = self.out_collect_var_section_names_dict(node, False, 'PRE')
        iter_VAR: dict[str, list[str]] | bool = self.out_collect_var_section_names_dict(node, False, 'VAR')
        
        iter_count: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        
        iter_VAR_dup: dict[str, list | str] = {}
        if iter_VAR is not False:
            assert isinstance(iter_VAR, dict)
            for iter in range(iter_count):
                key: str = str(iter + 1)
                vars: list[str] | None = iter_VAR.get(key)
                if vars is not None:
                    dup: list | str = self.out_util_vars_duplicate(vars)
                    assert isinstance(dup, list)
                    if dup:
                        iter_VAR_dup[key] = dup
                        if bool_VARS is False: bool_VARS: bool = True
                    
        iter_PRE_dup: dict[str, list | str] = {}
        if iter_PRE is not False:
            assert isinstance(iter_PRE, dict)
            for iter in range(iter_count):
                key: str = str(iter + 1)
                vars: list[str] | None = iter_PRE.get(key)
                if vars is not None:
                    dup: list | str = self.out_util_vars_duplicate(vars)
                    assert isinstance(dup, list)
                    if dup:
                        iter_PRE_dup[key] = dup
                        if bool_VARS_PRE is False: bool_VARS_PRE: bool = True
        
        
        # FF: duplicates check
        #############################################################################
        _FF_VAR_dup: dict[str, list | str] = {}
        _FF_POST_dup: dict[str, list | str] = {}
        
        if node.parm(f3h_tabs.PREFS.PVT_PRM_DOFF).eval():
            key: str = 'FF' # will always be FF
            _FF_VAR: dict[str, list[str]] | bool  = self.out_collect_var_section_names_dict(node, True, 'VAR')
            _FF_POST: dict[str, list[str]] | bool = self.out_collect_var_section_names_dict(node, True, 'POST')
            if _FF_VAR is not False:
                assert isinstance(_FF_VAR, dict)
                vars: list[str] | None = _FF_VAR.get(key)
                if vars is not None:
                    dup: list | str = self.out_util_vars_duplicate(vars)
                    assert isinstance(dup, list)
                    if dup:
                        _FF_VAR_dup[key] = dup
                        bool_VARS_FF: bool = True
                    
            if _FF_POST is not False:
                assert isinstance(_FF_POST, dict)
                vars: list[str] | None = _FF_POST.get(key)
                if vars is not None:
                    dup: list | str = self.out_util_vars_duplicate(vars)
                    assert isinstance(dup, list)
                    if dup:
                        _FF_POST_dup[key] = dup
                        bool_VARS_POST_FF: bool = True
        
        if bool_VARS_PRE or bool_VARS or bool_VARS_POST or bool_VARS_PRE_FF or bool_VARS_FF or bool_VARS_POST_FF:
            
            _MSG_PRE = _MSG_VAR = ''
            if bool_VARS_PRE:
                dup = ''.join(f"\titerator.{key}\n\t\t{', '.join(val)}\n" for key, val in iter_PRE_dup.items())
                assert isinstance(dup, str)
                _MSG_PRE = f"\nPRE\n{dup}"
            
            if bool_VARS:
                dup = ''.join(f"\titerator.{key}\n\t\t{', '.join(val)}\n" for key, val in iter_VAR_dup.items())
                assert isinstance(dup, str)
                _MSG_VAR = f"\nVAR\n{dup}"
                
            _MSG_FF_VAR = _MSG_FF_POST = ''
            if bool_VARS_FF:
                dup = ''.join(f"{', '.join(val)}\n" for val in _FF_VAR_dup.values())
                assert isinstance(dup, str)
                _MSG_FF_VAR = f"\nFF VAR\n\t{dup}"
            
            if bool_VARS_POST_FF:
                dup = ''.join(f"{', '.join(val)}\n" for val in _FF_POST_dup.values())
                assert isinstance(dup, str)
                _MSG_FF_POST = f"\nFF POST\n\t{dup}"
                
            _MSG_INTRO: str = f"You are using the same variation multiple times\ninside the following iterators/FF types (PRE, VAR, POST):\n"
            _MSG_ALL_DUP: str = f"{_MSG_INTRO}{_MSG_PRE}{_MSG_VAR}{_MSG_FF_VAR}{_MSG_FF_POST}"
            
            _MSG_HELP: str  = "\n"
            _MSG_HELP += f"DOC:\n"
            _MSG_HELP += f"\tWhile this is doable within the tool, it is not compatible with FLAM3 file format.\n\tIt require that a variation is used only once per type ( types: PRE, VAR, POST )\n\totherwise you wont be able to save out the same result neither to load it back.\n\tFor example you are not allowed to use two Spherical variations inside an iterator VAR section.\n\n\tYou can however use\n\tone Spherical variation inside the VAR section, one inside the PRE and one inside the POST.\n\n"
            _MSG_HELP += f"TIP:\n"
            _MSG_HELP += f"\tSave the hip file instead if you desire to keep the Flame result as it is now.\n\tFractorium, Apophysis and all other FLAM3 compatible applications obey to the same rule."
            
            _MSG_ALL: str = f"{_MSG_ALL_DUP}{_MSG_HELP}"
            
            _MSG: str = f"{node.name()}: FLAM3 Compatibility -> The FLAM3 format is incompatible with the fractal Flame you are attempting to save."
            flam3h_general_utils.set_status_msg(_MSG, 'WARN')
            if hou.isUIAvailable():
                _MSG_UI = "Duplicates variations of the same type not allowed.\nShow Details to learn more."
                hou.ui.displayMessage(_MSG_UI, buttons=("Got it, thank you",), severity = hou.severityType.ImportantMessage, default_choice = 0, close_choice = -1, help = None, title = "FLAM3H™ Compatibility", details = _MSG_ALL, details_label = None, details_expanded = False) # type: ignore
            flam3h_general_utils.set_status_msg('', 'MSG')
            
            return False
        
        else:
            return True
        
        
    def out_populate_xform_vars_XML(self, 
                                    varsPRM: tuple, 
                                    TYPES_tuple: tuple[str, ...], 
                                    WEIGHTS_tuple: tuple[tuple[str, int], ...], 
                                    element_xform: lxmlET._Element,
                                    MP_IDX: str, 
                                    FUNC: Callable) -> list[str]:
        """Set this iterator variations:
        * types parameters
        * weights parameters and their parametric parameters
        
        inside the xform (lxmlET._Element) to be written out into the XML file.
        
        It will also return a list of used variations in the provided iterator/xform.
        
        Args:
            varsPRM(tuple): FLAM3H™ variation's types and their parametric parameters names.
            TYPES_tuple(tuple[str, ...]): FLAM3H™ variation's types parameters names.
            WEIGHTS_tuple(tuple[tuple[str, int], ...]): FLAM3H™ variation's weights parameters names.
            XFORM(lxmlET._Element): The current xform (lxmlET._Element) to populate.
            MP_IDX(str): Current multiparameter index
            FUNC(Callable): Callable definition to convert variation's names between VAR, PRE and POST: in_flame_utils.in_util_make_NULL, in_flame_utils.in_util_make_PRE, in_flame_utils.in_util_make_POST

        Returns:
            (list[str]): List of used variation in this iterator/xform
        """
        node: hou.SopNode = self.node
        names: list = []
        for idx, prm in enumerate(WEIGHTS_tuple):
            prm_w: float = node.parm(f"{prm[0]}{MP_IDX}").eval()
            if prm_w != 0:
                v_type: int = node.parm(f"{TYPES_tuple[idx]}{MP_IDX}").eval()
                v_name: str = in_flame_utils.in_get_dict_key_from_value(VARS_FLAM3_DICT_IDX, v_type)
                names.append(v_name)
                element_xform.set(FUNC(v_name), self.out_util_round_float(prm_w))
                vars_prm: tuple = varsPRM[v_type]
                if vars_prm[-1]:
                    f3h_prm: tuple = varsPRM[v_type][1:-1]

                    # If OUT Tab -> USE_FRACTORIUM_PRM_NAMES toggle is ON
                    # make sure to use the parametric variation's parameters names that Fractorium expect.
                    apo_prm: tuple = flam3h_varsPRM_APO().varsPRM[v_type]
                    if node.parm(f3h_tabs.OUT.PRM_USE_FRACTORIUM_PRM_NAMES).eval():
                        out_prm: tuple = in_flame_utils.in_prm_name_exceptions(v_type, xml_keys.XML_APP_NAME_FRACTORIUM, apo_prm)[1:-1]
                    else:
                        out_prm: tuple = apo_prm[1:-1]
                        
                    for id, p in enumerate(out_prm):
                        if f3h_prm[id][-1]:
                            for i in range(len(p)): # for i, n in enumerate(p):
                                vals: tuple[float, ...] = node.parmTuple(f"{f3h_prm[id][0]}{MP_IDX}").eval()
                                element_xform.set(FUNC(p[i]), self.out_util_round_float(vals[i]))
                        else:
                            val: float = node.parm(f"{f3h_prm[id][0]}{MP_IDX}").eval()
                            element_xform.set(FUNC(p[0]), self.out_util_round_float(val))
                            
        return names


    def out_build_XML(self, flame: lxmlET._Element) -> bool:
        """Build the XML Flame data to be then written out.</br>

        Args:
            (self):
            flame(lxmlET._Element): The root of either the flame to be written out or the flame file to append the new flame to.

        Returns:
            (bool): return True if the Flame is a compatible FLAM3 flame or False if not.
        """
        # Build Flame data and render properties
        f3d = out_flame_xforms_data(self.kwargs)
        f3r = out_flame_render_properties(self.kwargs)
        
        # SET Flame render properties
        for key, value in self.out_flame_properties_build(f3r).items():
            if value is not False:
                flame.set(key, value)

        # SET xforms
        name_PRE_BLUR: str = ""
        names_VARS: list[list[str]] = []
        names_VARS_PRE: list = [] # this is a: list[list[str]] but I can not cast it yet because I am doing dirty things down the line
        names_VARS_POST: list[list[str]] = []
        xml_xf_names: tuple[str, ...] = self.out_build_xf_names(f3d)
        
        for iter in range(f3d.iter_count):
            
            mp_idx = str(int(iter + 1))
            
            if int(f3d.xf_vactive[iter]):
                
                xf: lxmlET._Element = lxmlET.SubElement(flame, xml_keys.XML_XF)
                xf.tag = xml_keys.XML_XF
                xf.set(xml_keys.XML_XF_NAME, xml_xf_names[iter])
                xf.set(xml_keys.XML_XF_WEIGHT, f3d.xf_weight[iter])
                xf.set(xml_keys.XML_XF_COLOR, f3d.xf_color[iter])
                xf.set(xml_keys.XML_XF_SYMMETRY, f3d.xf_symmetry[iter])
                xf.set(xml_keys.XML_XF_COLOR_SPEED, f3d.xf_color_speed[iter])
                if f3d.xf_pre_blur[iter]:
                    name_PRE_BLUR = xml_keys.XML_XF_PB
                    xf.set(xml_keys.XML_XF_PB, f3d.xf_pre_blur[iter])
                    
                xf.set(xml_keys.XML_PRE_AFFINE, f3d.xf_preaffine[iter])
                angle_pre: str | list[Never] = f3d.xf_f3h_preaffine_angle[iter]
                if f3d.f3h_affine and isinstance(angle_pre, str) and float(angle_pre) != 0:
                    xf.set(xml_keys.f3h.XML_PRE_AFFINE, f3d.xf_f3h_preaffine[iter])
                    xf.set(xml_keys.f3h.XML_PRE_AFFINE_ANGLE, angle_pre)
                    
                if f3d.xf_postaffine[iter]:
                    xf.set(xml_keys.XML_POST_AFFINE, f3d.xf_postaffine[iter])
                    # This look like will never be a list[Never] but its not causing any issues and not a bad idea to check if it is a str anyway.
                    angle_post: str | list[Never] = f3d.xf_f3h_postaffine_angle[iter]
                    if f3d.f3h_affine and isinstance(angle_post, str) and float(angle_post) != 0:
                        xf.set(xml_keys.f3h.XML_POST_AFFINE, f3d.xf_f3h_postaffine[iter])
                        xf.set(xml_keys.f3h.XML_POST_AFFINE_ANGLE, angle_post)
                        
                if f3d.xf_xaos[iter]:
                    xf.set(xml_keys.XML_XF_XAOS, f3d.xf_xaos[iter])
                    
                xf.set(xml_keys.XML_XF_OPACITY, f3d.xf_opacity[iter])
                f3h_iter: flam3h_iterator = flam3h_iterator()
                names_VARS.append(self.out_populate_xform_vars_XML(flam3h_varsPRM().varsPRM, f3h_iter.sec_varsT, f3h_iter.sec_varsW, xf, mp_idx, in_flame_utils.in_util_make_NULL))
                names_VARS_PRE.append(self.out_populate_xform_vars_XML(flam3h_varsPRM().varsPRM, f3h_iter.sec_prevarsT, f3h_iter.sec_prevarsW[1:], xf, mp_idx, in_flame_utils.in_util_make_PRE))
                names_VARS_POST.append(self.out_populate_xform_vars_XML(flam3h_varsPRM().varsPRM, f3h_iter.sec_postvarsT, f3h_iter.sec_postvarsW, xf, mp_idx, in_flame_utils.in_util_make_POST))
        
        # SET finalxform (FF)
        names_VARS_FF: list[str] = []
        names_VARS_PRE_FF: list[str] = []
        names_VARS_POST_FF: list[str] = []
        
        if f3d.flam3h_do_FF:
            finalxf: lxmlET._Element = lxmlET.SubElement(flame, xml_keys.XML_FF)
            finalxf.tag = xml_keys.XML_FF
            finalxf.set(xml_keys.XML_XF_NAME, f3d.finalxf_name)
            finalxf.set(xml_keys.XML_XF_COLOR, '0')
            finalxf.set(xml_keys.XML_XF_VAR_COLOR, '1')
            finalxf.set(xml_keys.XML_XF_COLOR_SPEED, '0')
            finalxf.set(xml_keys.XML_XF_SYMMETRY, '1')

            finalxf.set(xml_keys.XML_PRE_AFFINE, f3d.finalxf_preaffine)
            if f3d.f3h_affine and float(f3d.finalxf_f3h_preaffine_angle) != 0:
                finalxf.set(xml_keys.f3h.XML_PRE_AFFINE, f3d.finalxf_f3h_preaffine)
                finalxf.set(xml_keys.f3h.XML_PRE_AFFINE_ANGLE, f3d.finalxf_f3h_preaffine_angle)
                
            if f3d.finalxf_postaffine:
                finalxf.set(xml_keys.XML_POST_AFFINE, f3d.finalxf_postaffine)
                if f3d.f3h_affine and float(f3d.finalxf_f3h_postaffine_angle) != 0:
                    finalxf.set(xml_keys.f3h.XML_POST_AFFINE, f3d.finalxf_f3h_postaffine)
                    finalxf.set(xml_keys.f3h.XML_POST_AFFINE_ANGLE, f3d.finalxf_f3h_postaffine_angle)
                    
            f3h_iter_FF: flam3h_iterator_FF = flam3h_iterator_FF()
            names_VARS_FF = self.out_populate_xform_vars_XML(flam3h_varsPRM_FF(f"{f3h_ffPrmPrx.PRM}").varsPRM_FF(), f3h_iter_FF.sec_varsT_FF, f3h_iter_FF.sec_varsW_FF, finalxf, '', in_flame_utils.in_util_make_NULL)
            names_VARS_PRE_FF = self.out_populate_xform_vars_XML(flam3h_varsPRM_FF(f"{f3h_ffPrmPrx.PRM_PP}").varsPRM_FF(), f3h_iter_FF.sec_prevarsT_FF, f3h_iter_FF.sec_prevarsW_FF, finalxf, '', in_flame_utils.in_util_make_PRE)
            names_VARS_POST_FF = self.out_populate_xform_vars_XML(flam3h_varsPRM_FF(f"{f3h_ffPrmPrx.PRM_PP}").varsPRM_FF(), f3h_iter_FF.sec_postvarsT_FF, f3h_iter_FF.sec_postvarsW_FF, finalxf, '', in_flame_utils.in_util_make_POST)
        
        # SET palette
        palette: lxmlET._Element = lxmlET.SubElement(flame, xml_keys.XML_PALETTE)
        palette.tag = xml_keys.XML_PALETTE
        palette.set(xml_keys.XML_PALETTE_COUNT, self.out_palette_keys_count(self.palette_plus_do, len(self.palette.keys()), 0, False)) # When saving a Flame out, we always use a 256 color palette unless the OUT tab option "save palette 256+" is ON
        palette.set(xml_keys.XML_PALETTE_FORMAT, f3h_tabs.CP.DEFAULT_MSG_COLOR_FORMAT)
        palette.text = f3d.palette_hex

        # SET unique used 'plugins' and 'new linear'
        names_VARS_flatten_unique: list[str] = in_flame_utils.in_util_vars_flatten_unique_sorted(names_VARS + [names_VARS_FF], in_flame_utils.in_util_make_NULL)
        names_VARS_PRE_flatten_unique: list[str] = in_flame_utils.in_util_vars_flatten_unique_sorted(names_VARS_PRE + [names_VARS_PRE_FF] + list(map(lambda x: in_flame_utils.in_util_make_VAR([x]) if x else x, [name_PRE_BLUR])), in_flame_utils.in_util_make_PRE)
        names_VARS_POST_flatten_unique: list[str] = in_flame_utils.in_util_vars_flatten_unique_sorted(names_VARS_POST + [names_VARS_POST_FF], in_flame_utils.in_util_make_POST)
        flame.set(xml_keys.XML_PLUGINS, i_cleandoc(' '.join(names_VARS_PRE_flatten_unique + names_VARS_flatten_unique + names_VARS_POST_flatten_unique)))
        flame.set(xml_keys.XML_NEW_LINEAR, '1')
        
        # SET CC Curves
        cc: dict[str, str] = {  xml_keys.XML_CC_CURVES: f3r.flame_render_curves,
                                xml_keys.XML_CC_CURVE_OVERALL: f3r.flame_overall_curve,
                                xml_keys.XML_CC_CURVE_RED: f3r.flame_red_curve,
                                xml_keys.XML_CC_CURVE_GREEN: f3r.flame_green_curve,
                                xml_keys.XML_CC_CURVE_BLUE: f3r.flame_blue_curve
                                }
        for key, value in cc.items(): flame.set(key, value)
        
        # return if this flame is a valid 'flam3'
        return self.out_flam3_compatibility_check_and_msg()


    def out_userData_XML_last_loaded(self, data_name: str = f3h_userData.XML_LAST, flame_name: str | None = None) -> None:
        """Store the loaded Flame preset into the FLAM3H™ node data storage.</br>
        This definition run a full save out preset(a snapshot of the curernt status of the FLAM3H™ parameters).</br>
        
        This is being added to have some sort of history/backup some how.</br>
        Will probably never be used but it is something more to have in any case.</br></br>
        This data is cleared every time:
        * a FLAM3H™ node is being created
        * when FLAM3H™ is being reset to the default Sierpinsky triangle
        * its iterator's count is set to 0(Zero).

        Args:
            (self):
            data_name(str): Default to: f3h_userData.XML_LAST</br>The name of the node user data to store the flame preset into.
            flame_name(str | None): Default to: None</br>If a flame name is provided it will use it, </br>otherwise it will either use the one set into the OUT flame name parameter or if this last is empty it will generate one based on today'sdate and time.
            
        Returns:
            (None):
        """ 
        node: hou.SopNode = self.node
        
        root: lxmlET._Element = lxmlET.Element(xml_keys.XML_NAME)
        if flame_name is None:
            if self.out_build_XML(root):
                self._out_pretty_print(root)
                flame: str = lxmlET.tostring(root, encoding="unicode")
                # Store the loaded Flame preset into the FLAM3H™ node data storage
                node.setUserData(data_name, flame)
                
        else:
            prm = node.parm(f3h_tabs.OUT.PRM_FLAME_PRESET_NAME)
            prm.lock(False)
            prm.deleteAllKeyframes()
            
            # Lets check if the OUT flame name parameter has a name already set and store it.
            out_flame_name: str = prm.eval()
            # Let's use the passed flame_name instead
            prm.set(flame_name)
            if self.out_build_XML(root):
                self._out_pretty_print(root)
                flame: str = lxmlET.tostring(root, encoding="unicode")
                # Store the loaded Flame preset into the FLAM3H™ node data storage
                node.setUserData(data_name, flame)
            # Restore whatever flame name was there if any (even if it was empty)
            prm.set(out_flame_name)
            
            
    def out_new_XML(self, outpath: str) -> None:
        """Write out a new XML flame file with only the current FLAM3H™ flame preset.</br>

        Args:
           (self):
            outpath(str): Current OUT flame full file path.
            
        Returns:
            (none):
        """   
        node: hou.SopNode = self.node
        
        root: lxmlET._Element = lxmlET.Element(xml_keys.XML_ROOT)
        flame: lxmlET._Element = lxmlET.SubElement(root, xml_keys.XML_NAME)
        flame.tag = xml_keys.XML_NAME
        
        if self.out_build_XML(flame):
            self._out_pretty_print(root)
            tree: lxmlET._ElementTree = lxmlET.ElementTree(root)
            tree.write(outpath)
            
            prm = node.parm(f3h_tabs.OUT.PRM_FLAME_PRESET_NAME)
            flam3h_prm_utils.set(node, prm, '')
            
            _MSG: str = f"{self.node.name()}: SAVE Flame New: Completed"
            flam3h_general_utils.set_status_msg(_MSG, 'IMP')
            flam3h_general_utils.flash_message(node, f"Flame SAVED")


    def out_new_XML_clipboard(self) -> None:
        """Write out a new XML flame file with only the current FLAM3H™ flame preset into the clipboard.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """ 
        node: hou.SopNode = self.node
        
        root: lxmlET._Element = lxmlET.Element(xml_keys.XML_NAME)
        
        if self.out_build_XML(root):
            self._out_pretty_print(root)
            flame: str = lxmlET.tostring(root, encoding="unicode")
            hou.ui.copyTextToClipboard(flame) # type: ignore
            
            prm = node.parm(f3h_tabs.OUT.PRM_FLAME_PRESET_NAME)
            flam3h_prm_utils.set(node, prm, '')
            
            _MSG: str = f"{self.node.name()}: SAVE Flame Clipboard: Completed"
            flam3h_general_utils.set_status_msg(_MSG, 'IMP')
            flam3h_general_utils.flash_message(node, f"Flame SAVED to the Clipboard")
            
            
    def out_preset_XML_clipboard(self) -> None:
        """Copy the OUT tab selected flame preset into the clipboard.</br>

        Args:
            (self):
            
        Returns:
            (None):
        """ 
        
        node: hou.SopNode = self.node
        
        _FLAM3H_INIT_DATA: tuple[str | None, int] = self.out_to_flam3h_init_data_quick(node)
        xml, preset_id = _FLAM3H_INIT_DATA

        if xml is not None and _xml_tree(xml).isvalidtree:

            # OUT flame preset data
            apo_data: in_flame_iter_data = in_flame_iter_data(node, xml, preset_id)
            name: str = apo_data.name[preset_id]
            
            # If there are xforms/iterators
            if apo_data.xforms is not None:
                
                assert apo_data.flame is not None
                flame: str = lxmlET.tostring(apo_data.flame[preset_id], encoding="unicode")
                hou.ui.copyTextToClipboard(flame) # type: ignore
                
                _MSG: str = f"{self.node.name()}: SAVE Flame Clipboard: Completed"
                flam3h_general_utils.set_status_msg(f"{_MSG} -> {name}", 'IMP')
                flam3h_general_utils.flash_message(node, f"Flame SAVED to the Clipboard")
                
            else:
                _MSG: str = f"ZERO xforms"
                flam3h_general_utils.set_status_msg(f"Name: {name}  ->  {_MSG} - SAVE SKIPPED", 'WARN')
                flam3h_general_utils.flash_message(node, f"{_MSG}")
                
        else:
            _MSG: str = f"Load a valid OUT flame file first"
            flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'WARN')
            flam3h_general_utils.flash_message(node, f"{_MSG}")


    def out_append_XML(self, root: lxmlET._Element, out_path: str) -> None:
        """Append a XML flame file to the current OUT flame lib file.</br>

        Args:
            (self):
            root(lxmlET._Element): Current OUT flame lib file data XML root.
            out_path(str): Current OUT flame full file path.

        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        
        flame: lxmlET._Element = lxmlET.SubElement(root, xml_keys.XML_NAME)
        flame.tag = xml_keys.XML_NAME
        
        if self.out_build_XML(flame):
            self._out_pretty_print(root)
            tree: lxmlET._ElementTree = lxmlET.ElementTree(root)
            tree.write(out_path)

            prm = node.parm(f3h_tabs.OUT.PRM_FLAME_PRESET_NAME)
            flam3h_prm_utils.set(node, prm, '')
            
            _MSG: str = f"{self.node.name()}: SAVE Flame Append: Completed"
            flam3h_general_utils.set_status_msg(_MSG, 'IMP')
            flam3h_general_utils.flash_message(node, f"Flame SAVED: Append")


    def out_XML(self) -> None:
        """Write out the XML Flame file.</br>
        It allow for writing out a new file or append to the current XML flame file.</br>
        
        Args:
            (self):
            
        Returns:
            (None):
        """
        node: hou.SopNode = self.node
        # Force this data to be rebuilt
        # This is needed to help to updates the menus from time to time so to pick up sneaky changes to the loaded files
        # (ex. the user perform hand made modifications like renaming a Preset and such).
        flam3h_iterator_utils(self.kwargs).destroy_all_menus_data(node)
        # Check and Update this data
        flam3h_iterator_utils(self.kwargs).update_xml_last_loaded(False)
        
        # if there is at least one iterator
        iterators_num: int = node.parm(f3h_tabs.PRM_ITERATORS_COUNT).eval()
        if iterators_num:
            
            kwargs: dict = self.kwargs
            
            out_path: str = os.path.expandvars(node.parm(f3h_tabs.OUT.PRM_PATH).eval())
            out_path_checked: str | bool = self.out_check_outpath(node, out_path, f3h_tabs.OUT.DEFAULT_FILE_EXT, f3h_tabs.OUT.DEFAULT_AUTO_NAME)
            
            # Write to the clipboard
            if kwargs['alt']:
                self.out_new_XML_clipboard()
                
            # Otherwise if the output path is valid
            elif out_path_checked is not False:
                assert isinstance(out_path_checked, str)
                
                if kwargs['shift']:
                    flam3h_general_utils.util_open_file_explorer(out_path_checked)
                    
                else:

                    if flam3h_general_utils.isLOCK(out_path_checked):
                        ui_text: str = f"This Flame library is Locked."
                        ALL_msg: str = f"This Flame library is Locked and you can not modify this file.\n\nTo Lock a Flame lib file just rename it using:\n\"{FLAM3H_LIB_LOCK}\" as the start of the filename.\n\nOnce you are happy with a Flame library you built, you can rename the file to start with: \"{FLAM3H_LIB_LOCK}\"\nto prevent any further modifications to it. For example if you have a lib file call: \"my_grandJulia.flame\"\nyou can rename it to: \"{FLAM3H_LIB_LOCK}_my_grandJulia.flame\" to keep it safe."
                        _MSG: str = "FLAME library file -> is LOCKED"
                        # Print to Houdini's status bar
                        flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'WARN')
                        flam3h_general_utils.flash_message(node, _MSG)
                        
                        # Pop up message window
                        if hou.isUIAvailable():
                            hou.ui.displayMessage(ui_text, buttons=("Got it, thank you",), severity = hou.severityType.ImportantMessage, default_choice = 0, close_choice = -1, help = None, title = "FLAM3H™ Lib Lock", details = ALL_msg, details_label = None, details_expanded = False) # type: ignore
                        # Clear up Houdini's status bar msg
                        flam3h_general_utils.set_status_msg('', 'MSG')
                        
                    else:
                        
                        flam3h_prm_utils.set(node, f3h_tabs.OUT.PRM_PATH, out_path_checked)
                        
                        exist: bool = os.path.exists(out_path_checked)
                        apo_data: in_flame = in_flame(node, out_path_checked)
                        _CHK = True
                        
                        if kwargs["ctrl"]:
                            
                            if exist:
                                if apo_data.isvalidtree:
                                    self.out_new_XML(out_path_checked)
                                    # Clear OUT presets menu filepath cache (this is done to force update the preset menu)
                                    flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.out_presets_filepath)
                                else:
                                    _CHK = False
                            else:
                                self.out_new_XML(out_path_checked)
                                # Clear OUT presets menu filepath cache (this is done to force update the preset menu)
                                flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.out_presets_filepath)
                            
                        else:
                            
                            if exist:
                                if apo_data.isvalidtree:
                                    self.out_append_XML(apo_data.root, out_path_checked)
                                    # Clear OUT presets menu filepath cache (this is done to force update the preset menu)
                                    flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.out_presets_filepath)
                                else:
                                    _CHK = False
                            else:
                                self.out_new_XML(out_path_checked)
                                # Clear OUT presets menu filepath cache (this is done to force update the preset menu)
                                flam3h_iterator_utils.destroy_cachedUserData(node, f3h_cachedUserData.out_presets_filepath)
                                
                        if not _CHK:
                            _MSG: str = "OUT File not a FLAME file"
                            flam3h_general_utils.set_status_msg(f"{node.name()}: {_MSG}", 'WARN')
                            flam3h_general_utils.flash_message(node, _MSG)
                                
                        # We forced the presets menus to update at the start of this definition, lets skip the destroy menus part on this one
                        flam3h_general_utils(kwargs).flam3h_init_presets_OUT_PRESETS(False)

            else:
                
                if kwargs['shift']:
                    # If there is NOT a valid dir or filepath already, open a file chooser to pick or define one
                    _START_DIR: str | None = flam3h_general_utils.select_file_start_dir(node, f3h_tabs.OUT.PRM_PATH)
                    # Open a floating file chooser
                    filepath: str = hou.ui.selectFile(start_directory=_START_DIR, title="FLAM3H™ Save a *.flame file", collapse_sequences=False, file_type=hou.fileType.Any, pattern="*.flame", default_value=None, multiple_select=False, image_chooser=None, chooser_mode=hou.fileChooserMode.Write, width=0, height=0)  # type: ignore
                    filepath_expandvars: str = os.path.expandvars(filepath)
                    dir: str = os.path.dirname(filepath_expandvars)
                    if os.path.isdir(dir):
                        flam3h_prm_utils.set(node, f3h_tabs.OUT.PRM_PATH, filepath_expandvars)
                        # The following definition use the default arg's
                        flam3h_general_utils(self.kwargs).flam3h_init_presets_OUT_PRESETS()
                    
                    else:
                        # This will probably never evaluate now that a file chooser has been added, but just in case.
                        _MSG: str = f"{node.name()}: SAVE Flame: Select a valid output file or a valid filename to create first."
                        flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                        flam3h_general_utils.flash_message(node, f"OUT: Select a valid output file")
                        
                else:
                    _MSG: str = f"{node.name()}: SAVE Flame: Select a valid output file or a valid filename to create first."
                    flam3h_general_utils.set_status_msg(_MSG, 'WARN')
                    flam3h_general_utils.flash_message(node, f"OUT: Select a valid output file")


    '''
    The following definitions will prep all the data into proper strings to be then written into the XML flame/xform data keys/entries.
    The name of each is self explanatory of the data they will prep and two different classes will be used to hold all this data:
    
    OUT FLAME RENDER PROPERTIES:
    class out_flame_render_properties(out_flame_utils):
    
    OUT FLAME XFORMS DATA:
    class out_flame_xforms_data(out_flame_utils):
    
    This way they can be called elsewere anytime so to have this data always at hand.
    '''
    
    def __out_flame_data(self, prm_name: str = '') -> str:
        """Prepare the OUT render data FLAM3H™ parameters into proper strings to be written out.</br></br>
        This will deal with tuple value (flame_size, flame_center, etc)</br>
        as well with float values (flame_quality, flame_rotate, etc).</br>

        Args:
            (self):
            prm_name(str): Default to: ''</br>The name of the FLAM3H™ parameter to be prep into a string for writing out.

        Returns:
            (str): The FLAM3H™ parameter prepped into a string for writing out into the Flame preset file.
        """    
        
        node: hou.SopNode = self.node
        if prm_name:
            
            prm: hou.Parm | hou.ParmTuple | None = node.parm(prm_name)
            if prm is None:
                prm = node.parmTuple(prm_name)
                
            if prm is not None:
                
                if isinstance(prm, hou.ParmTuple):
                    
                    try:
                        _out_util_round_float: Callable[[float], str] = self.out_util_round_float
                        return ' '.join([str(_out_util_round_float(float(val))) for val in prm.eval()])
                    
                    except ValueError:
                        print(f"Warning:\n{node.name()}: parameter tuple name: \"{prm_name}\" not a valid value or string value tuple. Please pass in a valid FLAM3H™ parameter tuple name.\n")
                        return ''
                
                else:
                    
                    try:
                        return self.out_util_round_float(float(prm.eval()))
                    
                    except ValueError:
                        print(f"Warning:\n{node.name()}: parameter name: \"{prm_name}\" not a valid value or string value. Please pass in a valid FLAM3H™ parameter name.\n")
                        return ''
                
            else:
                print(f"Warning:\n{node.name()}: Please pass in a valid FLAM3H™ parameter name.\n")
                return ''
                
        else:
            print(f"Warning:\n{node.name()}: Please pass in a valid FLAM3H™ parameter name and not an empty string.\n")
            return ''


    def __out_flame_name(self, prm_name: str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_XF_NAME)) -> str:
        """Prepare the Flame name string for the XML Flame name key.</br>
        It will either use an automated one if no Flame name is provided or use the one provided by the user.</br></br>
        
        It will also auto add the iterations number to the string name if requested ("add iterations to Flame name" toggle ON)

        Args:
            (self):
            prm_name(str | None = XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_XF_NAME)): Default to: XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_XF_NAME)</br>The FLAM3H™ Flame name parameter name.

        Returns:
            (str): The FLAM3H™ parameter prepped into a string for writing out into the Flame preset file.
        """    
        flame_name: str = self.node.parm(prm_name).eval()
        autoadd: int = self.node.parm(f3h_tabs.OUT.PRM_AUTO_ADD_ITER_NUM).eval()
        
        if not flame_name:
            return self.out_flame_default_name(self.node, autoadd)
        
        # otherwise get that name and use it
        iter_num: int = self.node.parm(f3h_tabs.GLB.PRM_ITERATIONS).eval()
        return self.out_auto_add_iter_num(iter_num, flame_name, autoadd)
        
        
    def __out_xf_data(self, prm_name: str) -> tuple[str, ...]:
        """Prepare the xform/iterator single value parameters into a proper string to be written out.</br>

        Args:
            (self):
            prm_name(str): The name of the FLAM3H™ parameter to be prep into a string for writing out.

        Returns:
            (str): The FLAM3H™ parameter prepped into a string for writing out into the Flame preset file.
        """    
        _out_util_round_float: Callable[[float], str] = self.out_util_round_float
        val: list[str] = [str(_out_util_round_float(self.node.parm(f"{prm_name}_{iter}").eval())) for iter in range(1, self.iter_count + 1)]
        return tuple(val)
    
    
    def __out_xf_data_color_speed(self) -> tuple[str, ...]:
        """Prepare the xform/iterator color speed into a proper string to be written out.</br>
        This is specifically for Fractorium as it is the one using this conversion of values.</br>

        Args:
            (self):

        Returns:
            (str): The FLAM3H™ parameter prepped into a string for writing out into the Flame preset file.
        """    
        _shader_speed_name: str = flam3h_iterator_prm_names().shader_speed
        _out_util_round_float: Callable[[float], str] = self.out_util_round_float
        val: list[str] = [str(_out_util_round_float((1.0-self.node.parm(f"{_shader_speed_name}_{iter}").eval())/2.0)) for iter in range(1, self.iter_count + 1)]
        return tuple(val)
    

    def __out_xf_name(self) -> tuple[str, ...]:
        """Prepare each xform/iterator names/notes parameters for writing out.</br>

        Args:
            (self):

        Returns:
            (tuple): tuple of all the FLAM3H™ names/notes prepped into strings for writing out into the Flame preset file.
        """    
        val: list[str] = [str(self.node.parm(f"{self.flam3h_iter_prm_names.main_note}_{iter}").eval()).strip() for iter in range(1, self._iter_count + 1)]
        return tuple(val)
    
    
    def __out_finalxf_name(self) -> str:
        """Prepare the FF/finalXform name/note parameter for writing out.</br>

        Args:
            (self):

        Returns:
            (str): The FLAM3H™ FF name/note prepped into strings for writing out into the Flame preset file.
        """    
        FF_name: str = self.node.parm(f"{f3h_ffPrmPrx.PRM}{self.flam3h_iter_prm_names.main_note}").eval().strip()
        if not FF_name:
            return "iterator_FF"
        
        return FF_name

    
    def __out_xf_pre_blur(self) -> tuple[str, ...]:
        """Prepare each xform/iterator pre_blur parameters for writing out.</br>

        Args:
            (self):

        Returns:
            (tuple): tuple of all the FLAM3H™ xforms/iterators pre_blur parameters prepped into strings for writing out into the Flame preset file.
        """   
        val: list[str] = [str( self.node.parm(f"{self.flam3h_iter_prm_names.prevar_weight_blur}_{iter}").eval() ) if self.node.parm(f"{self.flam3h_iter_prm_names.prevar_weight_blur}_{iter}").eval() > 0 else '' for iter in range(1, self.iter_count + 1)]
        return tuple(val)


    def __out_xf_xaos(self) -> tuple[str, ...]:
        """Prepare each xform/iterator xaos parameters for writing out.</br>

        Args:
            (self):

        Returns:
            (tuple): tuple of all the FLAM3H™ xforms/iterators xaos parameters prepped into strings for writing out into the Flame preset file.
        """   
        if self.xm:
            return self.out_xf_xaos_from(1)
        
        return self.out_xf_xaos_to()


    def __out_xf_preaffine(self) -> TA_OUT_Pre_Affine:
        """Prepare each xform/iterator pre_affine parameters for writing out.</br>
        This will prep both flam3_affine style and F3H_affine style.</br>
        In case of the F3H_affine style it will prep the Rotation angle parameter as well.</br>

        Args:
            (self):

        Returns:
            (TA_OUT_Pre_Affine): tuple[tuple[flam3_affine], tuple[F3H_affine], tuple[F3H Rotation angle]]. tuple of all the FLAM3H™ xforms/iterators pre_affine parameters prepped into strings for writing out into the Flame preset file.
        """   
        val: list[list[str]] = []
        f3h_val: list[list[str]] = []
        f3h_angleDeg: list[str] = []
        for iter in range(self.iter_count):
            iter_num: int = iter + 1
            collect: TA_Affine = self.get_iter_affine_pre(iterator_num=iter_num)
            angleDeg: float = self.get_iter_affine_pre_rot(iterator_num=iter_num)
            f3h_angleDeg.append(str(round(angleDeg, xml_keys.f3h.DEFAULT_ROUND_DECIMAL_COUNT)))
            flatten: list[float] = [item for sublist in self.out_affine_rot(collect, angleDeg) for item in sublist]
            f3h_flatten: list[float] = [item for sublist in collect for item in sublist]
            val.append([str(x) for x in flatten])
            f3h_val.append([str(x) for x in f3h_flatten])
            
        _join: Callable[[Iterable[str]], str] = ' '.join
        return tuple(_join(x) for x in self.out_util_round_floats(val)), tuple(_join(x) for x in self.out_util_round_floats(f3h_val)), tuple(f3h_angleDeg)
    
    
    def __out_xf_postaffine(self) -> TA_OUT_Post_Affine:
        """Prepare each xform/iterator post_affine parameters for writing out.</br>
        This will prep both flam3_affine style and F3H_affine style.</br>
        In case of the F3H_affine style it will prep the Rotation angle parameter as well.</br>

        Args:
            (self):

        Returns:
            (TA_OUT_Post_Affine): tuple[tuple[str: flam3_affine], tuple[str: F3H_affine], tuple[str: F3H Rotation angle]]. tuple of all the FLAM3H™ xforms/iterators post_affine parameters prepped into strings for writing out into the Flame preset file.
        """   
        val: list[list[str] | list[Never]] = []
        f3h_val: list[list[str] | list[Never]] = []
        f3h_angleDeg: list[str | list[Never]] = []
        for iter_num in range(1, self.iter_count + 1):
            if self.node.parm(f"{self.flam3h_iter_prm_names.postaffine_do}_{iter_num}").eval():
                collect: TA_Affine = self.get_iter_affine_post(iterator_num=iter_num)
                angleDeg: float = self.get_iter_affine_post_rot(iterator_num=iter_num)
                if f3h_affineDefaults.DEFAULT_IDENT != [item for sublist in collect for item in sublist] or angleDeg != 0:
                    f3h_angleDeg.append(str(round(angleDeg, xml_keys.f3h.DEFAULT_ROUND_DECIMAL_COUNT)))
                    flatten: list[float] = [item for sublist in self.out_affine_rot(collect, angleDeg) for item in sublist]
                    f3h_flatten: list[float] = [item for sublist in collect for item in sublist]
                    val.append([str(x) for x in flatten])
                    f3h_val.append([str(x) for x in f3h_flatten])
                else:
                    val.append([])
                    f3h_val.append([])
                    f3h_angleDeg.append([])
            else:
                val.append([])
                f3h_val.append([])
                f3h_angleDeg.append([])

        _join: Callable[[Iterable[str]], str] = ' '.join
        return tuple(_join(x) for x in self.out_util_round_floats(val)), tuple(_join(x) for x in self.out_util_round_floats(f3h_val)), tuple(f3h_angleDeg)


    def __out_finalxf_preaffine(self) -> TA_OUT_Affine_FF:
        """Prepare each FF/finalXform pre_affine parameters for writing out.</br>
        This will prep both flam3_affine style and F3H_affine style.</br>
        In case of the F3H_affine style it will prep the Rotation angle parameter as well.</br>

        Args:
            (self):

        Returns:
            (TA_OUT_Affine_FF): tuple[str: flam3_affine, str: F3H_affine, str: F3H Rotation angle]. tuple of strings for all the FLAM3H™ FF/finalXform pre_affine parameters prepped into strings for writing out into the Flame preset file.
        """   
        collect: TA_Affine = self.get_FF_affine_pre()
        angleDeg: float = self.get_FF_affine_pre_rot()
        f3h_angleDeg: str = str(angleDeg)
        f3h_affine: TA_STR_ListUnflattened = self.out_util_round_floats(collect)
        if angleDeg != 0.0:
            affine: TA_STR_ListUnflattened = self.out_util_round_floats(self.out_affine_rot(collect, angleDeg))
        else:
            affine: TA_STR_ListUnflattened = f3h_affine
        flatten: list[str] = [item for sublist in affine for item in sublist]
        f3h_flatten: list[str] = [item for sublist in f3h_affine for item in sublist]
        
        return ' '.join(flatten), ' '.join(f3h_flatten), f3h_angleDeg
    
    
    def __out_finalxf_postaffine(self) -> TA_OUT_Affine_FF:
        """Prepare each FF/finalXform post_affine parameters for writing out.</br>
        This will prep both flam3_affine style and F3H_affine style.</br>
        In case of the F3H_affine style it will prep the Rotation angle parameter as well.</br>

        Args:
            (self):

        Returns:
            (TA_OUT_Affine_FF): tuple[str: flam3_affine, str: F3H_affine, str: F3H Rotation angle]. tuple of strings for all the FLAM3H™ FF/finalXform post_affine parameters prepped into strings for writing out into the Flame preset file.
        """  
        if self.node.parm(f"{f3h_ffPrmPrx.PRM}{self.flam3h_iter_prm_names.postaffine_do}").eval():
            collect: TA_Affine = self.get_FF_affine_post()
            angleDeg: float = self.get_FF_affine_post_rot()
            if f3h_affineDefaults.DEFAULT_IDENT != [item for sublist in collect for item in sublist] or angleDeg != 0:
                f3h_angleDeg: str = str(angleDeg)
                f3h_affine: TA_STR_ListUnflattened = self.out_util_round_floats(collect)
                if angleDeg != 0.0:
                    affine: TA_STR_ListUnflattened = self.out_util_round_floats(self.out_affine_rot(collect, angleDeg))
                else:
                    affine: TA_STR_ListUnflattened = f3h_affine
                flatten: list[str] = [item for sublist in affine for item in sublist]
                f3h_flatten: list[str] = [item for sublist in f3h_affine for item in sublist]
                
                return ' '.join(flatten), ' '.join(f3h_flatten), f3h_angleDeg
            
            return '', '', ''
        
        
        return '', '', ''
    
    
    def __out_palette_hex(self) -> str:
        """Prepare the FLAM3H™ palette ramp parameter to be written out into the Flame preset file.</br>

        Args:
            (self):

        Returns:
            (str): The FLAM3H™ palette prepped into a string and converted into hex values.
        """  
        _PALETTE_KEYS_OUT = self.out_palette_keys_count(self.palette_plus_do, len(self.palette.keys()), 0)
        POSs: list[int | float] = list(it_islice(it_count(0, 1.0/(int(_PALETTE_KEYS_OUT)-1)), int(_PALETTE_KEYS_OUT)))
        _rgb_to_hex: Callable[[tuple[float, ...]], str] = flam3h_palette_utils.rgb_to_hex
        HEXs: list[str] = [_rgb_to_hex(tuple(self.palette.lookup(p))) for p in POSs]
        n: int = 8
        hex_grp: TA_STR_ListUnflattened = [HEXs[i:i + n] for i in range(0, len(HEXs), n)]
        _join: Callable[[Iterable[str]], str] = ''.join
        hex_join: list = [f"      {_join(grp)}\n" for grp in hex_grp] # 6 times \s
        
        return f"\n{''.join(hex_join)}    " # 4 times \s
    
    
    def __out_flame_palette_mode(self) -> str:
        """Prepare the FLAM3H™ palette mode to be written out into the Flame preset file.</br>
        This is specifically for Fractorium, it uses 2(two) modes: 'linear' and 'step'.</br></br>
        Everything else will fallback on:
        * linear
        
        Args:
            (self):

        Returns:
            (str): The FLAM3H™ palette mode for this Flame prepped into a string.
        """  
        if self.flam3h_cp_basis:
            
            match self.flam3h_cp_basis:
                
                case 0:
                    return 'linear'
                
                case 1:
                    return 'step' # 'constant'(1) in FLAM3H™
                
                case _:
                    return 'linear'
                
        else:
            return 'linear'
        
    
    # custom to FLAM3H™ only
    def __out_flame_data_flam3h_hsv(self, prm_name: str = f3h_tabs.CP.PRM_RAMP_HSV_VAL_NAME) -> str | bool:
        """Prepare the FLAM3H™ palette HSV parameter to be written out into the Flame preset file.</br>

        Args:
            (self):
            prm_name(str): Defailt to: CP_RAMP_HSV_VAL_NAME</br>The name of the FLAM3H™ parameter to be prep into a string for writing out.

        Returns:
            (str): The FLAM3H™ palette HSV parameter prepped into a string.
        """  
        if prm_name == f3h_tabs.CP.PRM_RAMP_HSV_VAL_NAME:
            # This is only for OUT ramp HSV vals.
            # If we are saving out a flame with the HSV ramp, 
            # we do not want to export the HSV values in the XML file anymore
            # so to not overimpose a color correction once we load it back.
            if self.palette_hsv_do:
                return False
            
            # Here we go ahead since we know the prm CP_RAMP_HSV_VAL_NAME is a tuple
            prm: tuple[float, float, float] = self.node.parmTuple(prm_name).eval()
            # If the HSV values are at their defaults, do not export them into the XML file
            if prm[0] == prm[1] == prm[2] == 1:
                return False
            
            return ' '.join([self.out_util_round_float(x) for x in prm])
        
        print(f"Warning:\n{self.node.name()}: parameter name: \"{prm_name}\" not found. Please pass in a valid FLAM3H™ ramp hsv parameter name.\n")
        return False
        
        
    # custom to FLAM3H™ only
    def __out_flame_data_flam3h_mb_val(self, prm_name: str = '') -> str | bool:
        """Prepare the FLAM3H™ motion blur single val parameter to be written out into the Flame preset file.</br>

        Args:
            (self):
            prm_name(str): The name of the FLAM3H™ motion blur parameter to be prep into a string for writing out.

        Returns:
            (str): The FLAM3H™ motion blur single val parameter prepped into a string.
        """  
        if self.flam3h_mb_do and prm_name:
            
            try:
                return self.out_util_round_float(float(self.node.parm(prm_name).eval()))
            
            except ValueError:
                print(f"Warning:\n{self.node.name()}: Motion Blur parameter name: \"{prm_name}\" not found. Please pass in a valid FLAM3H™ Motion Blur val parameter name.\n")
                return False
            
        
        return False
        
        
    # custom to FLAM3H™ only
    def __out_flame_data_flam3h_toggle(self, toggle: bool) -> str:
        """Prepare a FLAM3H™ toggle value to be written out into the Flame preset file.</br>

        Args:
            (self):
            toggle(bool): This data to be passed in is collected ahead of time inside class "out_flame_utils".

        Returns:
            (str): The FLAM3H™ toggle prepped into a string.
        """  
        return str(toggle)
    
    
    # custom to FLAM3H™ only
    def __out_flame_palette_lookup_samples(self) -> str | bool:
        """Prepare the FLAM3H™ lookup samples to be written out into the Flame preset file.</br>
        It will check if palette 256+ is active and if so if the number of palette color keys are enough to use higher samples or not.</br>
        If plaette 256+ toggle is off, it will check if the user is using a lookup sample value different from default and store it if so.
        
        Args:
            (self):

        Returns:
            (str): The FLAM3H™ lookup samples for this Flame prepped into a string.
        """  
        if self.palette_plus_do:
            keys: str = out_flame_utils(self.kwargs).out_palette_keys_count(self.palette_plus_do, len(self.palette.keys()), 0, False)
            if self.flam3h_cp_lookup_samples > int(keys): keys: str = str(self.flam3h_cp_lookup_samples)
            
            if int(keys) == 256:
                return False
            
            return keys
        
        else:
            if self.flam3h_cp_lookup_samples == 256:
                return False
            
            return str(self.flam3h_cp_lookup_samples)
            
            
    # custom to FLAM3H™ only
    def __out_flame_palette_basis(self) -> str | bool:
        """Prepare the FLAM3H™ lookup samples interpolation to be written out into the Flame preset file.</br>
        
        Args:
            (self):

        Returns:
            (str): The FLAM3H™ lookup samples interpolation for this Flame prepped into a string.
        """  
        if self.flam3h_cp_basis:
            return str(self.flam3h_cp_basis)
        
        return False # if linear(0) basis, do not export


# OUT FLAME RENDER PROPERTIES start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class out_flame_render_properties(out_flame_utils):
    """
    Args:
        out_flame_utils ([class]): [inherit properties methods from the out_flame_utils class]
    """  

    __slots__ = ("_flame_name", "_flame_size", "_flame_center", "_flame_scale", "_flame_rotate", "_flame_quality", "_flame_brightness", "_flame_gamma", "_flame_k2", "_flame_vibrancy", "_flame_highlight", 
                 "_flame_render_curves", "_flame_overall_curve", "_flame_red_curve", "_flame_green_curve", "_flame_blue_curve", 
                 "_flame_cp_mode", 
                 "_flam3h_sys_rip", "_flam3h_cp_hsv", "_flam3h_mb_fps", "_flam3h_mb_samples", "_flam3h_mb_shutter", "_flam3h_cp_samples", "_flam3h_cp_samples_basis", "_flam3h_prefs_f3c")

    def __init__(self, kwargs: dict) -> None:
        """
        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """ 
        super().__init__(kwargs)
        
        self._flame_name: str = self._out_flame_utils__out_flame_name() # type: ignore
        self._flame_size: str = self._out_flame_utils__out_flame_data(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_SIZE)) # type: ignore
        self._flame_center: str = self._out_flame_utils__out_flame_data(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CENTER)) # type: ignore
        self._flame_scale: str = self._out_flame_utils__out_flame_data(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_SCALE)) # type: ignore
        self._flame_rotate: str = self._out_flame_utils__out_flame_data(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_ROTATE)) # type: ignore
        self._flame_quality: str = self._out_flame_utils__out_flame_data(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_QUALITY)) # type: ignore
        self._flame_brightness: str = self._out_flame_utils__out_flame_data(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_BRIGHTNESS)) # type: ignore
        self._flame_gamma: str = self._out_flame_utils__out_flame_data(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_GAMMA)) # type: ignore
        self._flame_k2: str = self._out_flame_utils__out_flame_data(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_K2)) # type: ignore
        self._flame_vibrancy: str = self._out_flame_utils__out_flame_data(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_VIBRANCY)) # type: ignore
        self._flame_highlight: str = self._out_flame_utils__out_flame_data(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_POWER)) # type: ignore
        
        # OUT render curves
        # We can directly get the data from the FLAM3H™ UI parameters since they have been checked on creation already.
        self._flame_render_curves: str = self.node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVES)).eval()
        self._flame_overall_curve: str = self.node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_OVERALL)).eval()
        self._flame_red_curve: str = self.node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_RED)).eval()
        self._flame_green_curve: str = self.node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_GREEN)).eval()
        self._flame_blue_curve: str = self.node.parm(XML_RENDER_HOUDINI_DICT.get(xml_keys.XML_CC_CURVE_BLUE)).eval()
        
        # Fractorium palette mkode
        self._flame_cp_mode: str = self._out_flame_utils__out_flame_palette_mode() # type: ignore
        
        # custom to FLAM3H™ only
        self._flam3h_sys_rip: str = self._out_flame_utils__out_flame_data_flam3h_toggle(self._flam3h_rip) # type: ignore
        self._flam3h_cp_hsv: str | bool = self._out_flame_utils__out_flame_data_flam3h_hsv() # type: ignore
        self._flam3h_mb_fps: str | bool = self._out_flame_utils__out_flame_data_flam3h_mb_val(f3h_tabs.MB.PRM_FPS) # type: ignore
        self._flam3h_mb_samples: str | bool = self._out_flame_utils__out_flame_data_flam3h_mb_val(f3h_tabs.MB.PRM_SAMPLES) # type: ignore
        self._flam3h_mb_shutter: str | bool = self._out_flame_utils__out_flame_data_flam3h_mb_val(f3h_tabs.MB.PRM_SHUTTER) # type: ignore
        self._flam3h_cp_samples: str | bool = self._out_flame_utils__out_flame_palette_lookup_samples() # type: ignore
        self._flam3h_cp_basis: str | bool = self._out_flame_utils__out_flame_palette_basis() # type: ignore
        self._flam3h_prefs_f3c: str = self._out_flame_utils__out_flame_data_flam3h_toggle(self._flam3h_f3c) # type: ignore
        

    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @property
    def flame_name(self) -> str:
        return self._flame_name
    
    @property
    def flame_size(self) -> str:
        return self._flame_size
    
    @property
    def flame_center(self) -> str:
        return self._flame_center
    
    @property
    def flame_scale(self) -> str:
        return self._flame_scale
    
    @property
    def flame_rotate(self) -> str:
        return self._flame_rotate
    
    @property
    def flame_quality(self) -> str:
        return self._flame_quality
    
    @property
    def flame_brightness(self) -> str:
        return self._flame_brightness
    
    @property
    def flame_gamma(self) -> str:
        return self._flame_gamma
    
    @property
    def flame_k2(self) -> str:
        return self._flame_k2
    
    @property
    def flame_vibrancy(self) -> str:
        return self._flame_vibrancy
    
    @property
    def flame_highlight(self) -> str:
        return self._flame_highlight
    
    # OUT render curves (Fractorium)
    
    @property
    def flame_render_curves(self) -> str:
        return self._flame_render_curves
    
    @property
    def flame_overall_curve(self) -> str:
        return self._flame_overall_curve
    
    @property
    def flame_red_curve(self) -> str:
        return self._flame_red_curve
    
    @property
    def flame_green_curve(self) -> str:
        return self._flame_green_curve
    
    @property
    def flame_blue_curve(self) -> str:
        return self._flame_blue_curve
    
    # OUT palette mode (Fractorium)
    
    @property
    def flame_cp_mode(self) -> str:
        return self._flame_cp_mode
    
    # custom to FLAM3H™ only
    
    @property
    def flam3h_sys_rip(self) -> str:
        return self._flam3h_sys_rip
    
    @property
    def flam3h_cp_hsv(self) -> str | bool:
        return self._flam3h_cp_hsv
    
    @property
    def flam3h_mb_fps(self) -> str | bool:
        return self._flam3h_mb_fps
    
    @property
    def flam3h_mb_samples(self) -> str | bool:
        return self._flam3h_mb_samples
    
    @property
    def flam3h_mb_shutter(self) -> str | bool:
        return self._flam3h_mb_shutter
    
    @property
    def flam3h_cp_samples(self) -> str | bool:
        return self._flam3h_cp_samples
    
    @property
    def flam3h_cp_basis(self) -> str | bool:
        return self._flam3h_cp_basis
    
    @property
    def flam3h_prefs_f3c(self) -> str:
        return self._flam3h_prefs_f3c


# OUT FLAME XFORMS DATA start here
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class out_flame_xforms_data(out_flame_utils):
    """
    Args:
        out_flame_utils ([class]): [inherit properties methods from the out_flame_utils class]
    """  
    
    __slots__ = ("_xf_name", "_xf_vactive", "_xf_weight", "_xf_xaos", 
                 "_xf_color", "_xf_symmetry", "_xf_color_speed", "_xf_opacity", 
                 "_xf_pre_blur", 
                 "_xf_preaffine", "_xf_f3h_preaffine", "_xf_f3h_preaffine_angle", "_xf_postaffine", "_xf_f3h_postaffine", "_xf_f3h_postaffine_angle", 
                 "_finalxf_name", "_finalxf_preaffine", "_finalxf_f3h_preaffine", "_finalxf_f3h_preaffine_angle", "_finalxf_postaffine", "_finalxf_f3h_postaffine", "_finalxf_f3h_postaffine_angle", 
                 "_palette_hex",)
    
    def __init__(self, kwargs: dict) -> None:
        """
        Args:
            kwargs(dict): this FLAM3H™ node houdini kwargs.
            
        Returns:
            (None):
        """ 
        super().__init__(kwargs)
        
        # FLAM3 data
        self._xf_name: tuple[str, ...] = self._out_flame_utils__out_xf_name() # type: ignore
        self._xf_vactive: tuple[str, ...] = self._out_flame_utils__out_xf_data(self.flam3h_iter_prm_names.main_vactive) # type: ignore
        self._xf_weight: tuple[str, ...] = self._out_flame_utils__out_xf_data(self.flam3h_iter_prm_names.main_weight) # type: ignore
        self._xf_xaos: tuple[str, ...] = self._out_flame_utils__out_xf_xaos() # type: ignore
        
        self._xf_color: tuple[str, ...] = self._out_flame_utils__out_xf_data(self.flam3h_iter_prm_names.shader_color) # type: ignore
        self._xf_symmetry: tuple[str, ...] = self._out_flame_utils__out_xf_data(self.flam3h_iter_prm_names.shader_speed) # type: ignore
        self._xf_color_speed: tuple[str, ...] = self._out_flame_utils__out_xf_data_color_speed() # type: ignore
        self._xf_opacity: tuple[str, ...] = self._out_flame_utils__out_xf_data(self.flam3h_iter_prm_names.shader_alpha) # type: ignore
        
        self._xf_pre_blur: tuple[str, ...] = self._out_flame_utils__out_xf_pre_blur() # type: ignore
        
        self._xf_preaffine: tuple[str, ...] = self._out_flame_utils__out_xf_preaffine()[0] # type: ignore
        self._xf_f3h_preaffine: tuple[str, ...] = self._out_flame_utils__out_xf_preaffine()[1] # type: ignore
        self._xf_f3h_preaffine_angle: tuple[str, ...] = self._out_flame_utils__out_xf_preaffine()[2] # type: ignore
        self._xf_postaffine: tuple[str, ...] = self._out_flame_utils__out_xf_postaffine()[0] # type: ignore
        self._xf_f3h_postaffine: tuple[str | list[Never], ...] = self._out_flame_utils__out_xf_postaffine()[1] # type: ignore
        self._xf_f3h_postaffine_angle: tuple[str | list[Never], ...] = self._out_flame_utils__out_xf_postaffine()[2] # type: ignore
        
        self._finalxf_name: str = self._out_flame_utils__out_finalxf_name() # type: ignore
        self._finalxf_preaffine: str = self._out_flame_utils__out_finalxf_preaffine()[0] # type: ignore
        self._finalxf_f3h_preaffine: str = self._out_flame_utils__out_finalxf_preaffine()[1] # type: ignore
        self._finalxf_f3h_preaffine_angle: str = self._out_flame_utils__out_finalxf_preaffine()[2] # type: ignore
        self._finalxf_postaffine: str = self._out_flame_utils__out_finalxf_postaffine()[0] # type: ignore
        self._finalxf_f3h_postaffine: str = self._out_flame_utils__out_finalxf_postaffine()[1] # type: ignore
        self._finalxf_f3h_postaffine_angle: str = self._out_flame_utils__out_finalxf_postaffine()[2] # type: ignore
        
        self._palette_hex: str = self._out_flame_utils__out_palette_hex() # type: ignore


    # CLASS: PROPERTIES
    ##########################################
    ##########################################

    @property
    def xf_name(self) -> tuple[str, ...]:
        return self._xf_name
    
    @property
    def xf_vactive(self) -> tuple[str, ...]:
        return self._xf_vactive
    
    @property
    def xf_weight(self) -> tuple[str, ...]:
        return self._xf_weight
    
    @property
    def xf_xaos(self) -> tuple[str, ...]:
        return self._xf_xaos
    
    @property
    def xf_pre_blur(self) -> tuple[str, ...]:
        return self._xf_pre_blur
    
    @property
    def xf_color(self) -> tuple[str, ...]:
        return self._xf_color
    
    @property
    def xf_symmetry(self) -> tuple[str, ...]:
        return self._xf_symmetry
    
    @property
    def xf_color_speed(self) -> tuple[str, ...]:
        return self._xf_color_speed
    
    @property
    def xf_opacity(self) -> tuple[str, ...]:
        return self._xf_opacity
    
    @property
    def xf_preaffine(self) -> tuple[str, ...]:
        return self._xf_preaffine
    
    @property
    def xf_f3h_preaffine(self) -> tuple[str, ...]:
        return self._xf_f3h_preaffine
    
    @property
    def xf_f3h_preaffine_angle(self) -> tuple[str, ...]:
        return self._xf_f3h_preaffine_angle
    
    @property
    def xf_postaffine(self) -> tuple[str, ...]:
        return self._xf_postaffine
    
    @property
    def xf_f3h_postaffine(self) -> tuple[str | list[Never], ...]:
        return self._xf_f3h_postaffine
    
    @property
    def xf_f3h_postaffine_angle(self) -> tuple[str | list[Never], ...]:
        return self._xf_f3h_postaffine_angle
    
    @property
    def finalxf_name(self) -> str:
        return self._finalxf_name
    
    @property
    def finalxf_preaffine(self) -> str:
        return self._finalxf_preaffine
    
    @property
    def finalxf_f3h_preaffine(self) -> str:
        return self._finalxf_f3h_preaffine
    
    @property
    def finalxf_f3h_preaffine_angle(self) -> str:
        return self._finalxf_f3h_preaffine_angle
    
    @property
    def finalxf_postaffine(self) -> str:
        return self._finalxf_postaffine
    
    @property
    def finalxf_f3h_postaffine(self) -> str:
        return self._finalxf_f3h_postaffine
    
    @property
    def finalxf_f3h_postaffine_angle(self) -> str:
        return self._finalxf_f3h_postaffine_angle
    
    @property
    def palette_hex(self) -> str:
        return self._palette_hex


# PYSIDE start here (panels and such)
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
##########################################


class SvgIcon(QtWidgets.QWidget):
    """A QWidget for displaying an SVG image.</br></br>

    This widget wraps a QSvgRenderer to render SVG content inside a QWidget.</br>
    It safely handles invalid SVG data or incorrect types.</br>
    
    """
    def __init__(self, svg_bytes: QtCore.QByteArray, parent=None):
        super().__init__(parent)
        
        try:
            self.renderer: QSvgRenderer | None = QSvgRenderer(svg_bytes)
            if not self.renderer.isValid():
                self.renderer = None
                print("Warning: SVG data is invalid!")
                
        except TypeError:
            self.renderer = None
            print("Warning: SVG data is invalid!")

        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)

        if parent is not None and isinstance(parent, QtWidgets.QWidget):
            self.setSizePolicy(parent.sizePolicy())
        else:
            self.setSizePolicy( QtWidgets.QSizePolicy.Preferred,
                                QtWidgets.QSizePolicy.Preferred)
            print("Warning: SVG parent is not a QWidget!")
            
    
    def paintEvent(self, event: QtGui.QPaintEvent):
        if self.renderer and self.renderer.isValid():
            painter = QPainter(self)
            self.renderer.render(painter, self.rect())
            

class pyside_master_app_names:
    """Pyside app names to use with PS_CLS being the default app name.</br>
    
    """
    PS_CLS: Final[str] = "_f3h_ps_cls" # Default app name
    PS_CLS_ABOUT: Final[str] = "_f3h_ps_cls_about"
    
    
class pyside_master_base_proto(Protocol):
    """the protocol to check which pyside_master classes agree with it.
    
    """ 
    def null(self) -> str: ...


class pyside_utils:
    """
class pyside_utils

@STATICMETHODS
* pyside_panels_safe_launch(ps_cls: Type[pyside_master_base_proto], 
                                    app_name: str = pyside_master_app_names.PS_CLS, 
                                    run: bool = True, 
                                    *args, 
                                    **kwargs
                                    ) -> None:

"""
    
    @staticmethod
    def pyside_panels_safe_launch(ps_cls: Type[pyside_master_base_proto], 
                                  app_name: str = pyside_master_app_names.PS_CLS, 
                                  run: bool = True, 
                                  *args, 
                                  **kwargs
                                  ) -> None:
        """Safely run a pyside panel,</br>
        additionally there is the option to only remove an already exisiting one.</br>

        Args:
            ps_cls(Type[pyside_master_base_proto]): Any of the classes that agree to the pyside_master_base_proto protocol.
            app_name(str): Default to: "_ps_cls"</br>The app name.
            run(str): Default to: True</br>When False, it will close/exit the app with the <b>varname</b>.
            args: Any args to pass to the <b>ps_cls</b> if any.</br>
            kwargs: Any kwargs to pass to the <b>ps_cls</b> if any, following a list:</br><b>parent</b>=None (usually untouched)</br><b>ps_app_name</b>=pyside_master_app_names.PS_CLS (Never to be set as it will always be set to: <b>app_name</b> internally)</br><b>f3h_node</b>=None (This FLAM3H™ node)</br><b>app_info</b>=APP_INFO (The main info message string)</br><b>links</b>=False (When True it will display FLAM3H™ related web links)</br><b>auto_close_ms</b>=5000 (Timer in millisecond. Default to 5 seconds)</br><b>fade_in_ms</b>=None (Fade in time in millisecond. Default to 0(Zero))</br><b>fade_out_ms</b>=None (Fade ot time in millisecond. Default to 0(Zero))</br><b>splash_screen</b>=False (When True it will force the banner image to be load even if some chackes fail, just for the splash screen)</br>
            
        Returns:
            (None):
        """ 
        
        if hasattr(builtins, app_name):
            try:
                getattr(builtins, app_name).close()
                delattr(builtins, app_name) # probably not needed anymore but just in case
            except AttributeError:
                pass
            
        if __pyside_version__ is not None:
            
            if hou.isUIAvailable() and run:
                
                ps_app_name: str | None = kwargs.get("ps_app_name")
                if ps_app_name is None and app_name != pyside_master_app_names.PS_CLS:
                    kwargs["ps_app_name"] = app_name
                    
                h_version: int = flam3h_general_utils.houdini_version(2)
                if __pyside_version__ == 6:
                    if h_version > 205:
                        setattr(builtins, app_name, ps_cls(*args, **kwargs))
                        getattr(builtins, app_name).show()
                        
                elif __pyside_version__ == 2:
                    if h_version == 205:
                        setattr(builtins, app_name, ps_cls(*args, **kwargs))
                        getattr(builtins, app_name).show()
                    
        else:
            _MSG: str = """
WARNING: This \"PySide\" and/or \"Qt\" versions are not supported just yet.
Supported and tested versions are:\n
FLAM3H™ H20.5 - PySide2 version: 5.15.15
FLAM3H™ H20.5 - Qt version: 5.15.2
FLAM3H™ H21.0 - PySide6 version: 6.5.3
FLAM3H™ H21.0 - Qt version: 6.5.3
"""
            print(f"{_MSG}\n")


class pyside_master:
    """Ideally this class will contain all pyside classes for FLAM3H™ panels and such.</br>
    For now there is just one, its a start...
    
    """ 
    
    class F3H_msg_panel(QtWidgets.QWidget):
        """A default PySide meassage panel.</br></br>

        Can be used in different scenarios to display a short message nicely.</br></br>
        
        It features auto close timer, fade in, fade out.</br>
        and allow drawing Svg files on top of banner images as well.</br></br>
        
        Everything is properly scaled to keep the right size and proportions</br>
        across different screen sizes (4K, HD, ...) and few more features.</br></br>
        
        It is a work in progress and it will likely grow in the future.</br>
        
        """

        APP_NAME: str = "FLAM3H™"
        
        APP_INFO: str = (
            "compiling cvex nodes\n"
        )

        APP_COPYRIGHT: str = (
            "\n"
            f"v{__version__} indie {flam3h_scripts.flam3h_compatible_h_versions_msg(nodetype.hdaModule().__h_versions__, False, True)}, {__license__} - {__copyright__} ( made in Italy )"
        )
        
        # milliseconds
        FADE_IN_DURATION_MS: int = 0
        FADE_OUT_DURATION_MS: int = 0
        
        BG_COLOR: str = "#f4f6f8"
        TEXT_COLOR: str = "#2b2b2b"
        
        BASE_WINDOW_WIDTH: int = 512
        BASE_WINDOW_HEIGHT: int = 472
        BASE_DRAG_POSITION: QtCore.QPoint | None = None
        
        BASE_BANNER_HEIGHT: int = 300
        
        BASE_SVG_ICON_SIZE: int = 96
        
        IMG_PIXMAP: QtGui.QPixmap | None = None
        IMG_PIXMAP_SECTION_NAME: str = f3h_HDAsections.HDA_SECTION_IMG_BANNER
        
        SVG_ICON: SvgIcon | None = None
        SVG_ICON_W_SECTION_NAME: str = f3h_HDAsections.HDA_SECTION_SVG_LOGO_WHITE
        SVG_ICON_R_SECTION_NAME: str = f3h_HDAsections.HDA_SECTION_SVG_LOGO_RED
        
        NODETYPE: hou.SopNodeType = nodetype

        def __init__(   self, 
                        parent=None, 
                        f3h_node: hou.SopNode | None = None, 
                        app_info: str = APP_INFO, 
                        ps_app_name: str = pyside_master_app_names.PS_CLS, 
                        links: bool = False, 
                        auto_close_ms: int = 5000, 
                        fade_in_ms: int | None = None, 
                        fade_out_ms: int | None = None,
                        splash_screen: bool = False, 
                     ):
            super().__init__(parent)
            
            app: QtCore.QCoreApplication | None = QtWidgets.QApplication.instance()
            if app:
                
                self.ps_app_name = ps_app_name if ps_app_name else pyside_master_app_names.PS_CLS
                
                # DPI scaling
                screen: QtGui.QScreen = app.primaryScreen()
                self.dpi_scale: float = screen.logicalDotsPerInch() / 96.0

                self.window_width: int = int(self.BASE_WINDOW_WIDTH * self.dpi_scale)
                self.window_height: int = int(self.BASE_WINDOW_HEIGHT * self.dpi_scale)
                self.banner_height: int = int(self.BASE_BANNER_HEIGHT * self.dpi_scale)
                self.svg_icon_size: int = int(self.BASE_SVG_ICON_SIZE * self.dpi_scale)
                
                self.f3h_node: hou.SopNode | None = f3h_node if f3h_node is not None and f3h_node.type().nameWithCategory() == F3H_NODE_TYPE_NAME_CATEGORY else None
                self.h_valid: int | None = f3h_node.parm(f3h_tabs.PREFS.PVT_PRM_H_VALID).eval() if f3h_node is not None else None
                self.splash_screen = splash_screen
                
                # Check if the user want fade in and/or fade out (Disabled by default)
                if fade_in_ms is not None and isinstance(fade_in_ms, int | float): self.FADE_IN_DURATION_MS = int(fade_in_ms)
                if fade_out_ms is not None and isinstance(fade_out_ms, int | float): self.FADE_OUT_DURATION_MS = int(fade_out_ms)
                
                self.font_os: QtGui.QFont = app.font()

                # Add FLAM3H™ weblinks
                self.LINKS: bool = links
                # in case of a custom message, this must be a one liner ending with a newline(\n). Meant for short descriptive messages.
                # Check: APP_INFO variable for an example as it is the default message
                self.INFO = '' if self.LINKS else app_info if app_info else "\n"

                # Frameless + always on top
                self.setWindowFlags(QtCore.Qt.FramelessWindowHint | QtCore.Qt.WindowStaysOnTopHint)
                self.setFixedSize(self.window_width, self.window_height)
                
                if (self.f3h_node is not None and self.h_valid) or self.splash_screen: self._load_image_pixmap()
                self._center_window()
                self._build_ui()

                # Fade in animation
                self._start_fade_in()

                # Auto close with fade out
                if isinstance(auto_close_ms, int | float) and int(auto_close_ms) > 0:
                    fade_out_start: int = max(0, int(auto_close_ms) - self.FADE_OUT_DURATION_MS)
                    QtCore.QTimer.singleShot(fade_out_start, lambda: self._start_fade_out(self.FADE_OUT_DURATION_MS))


        # PROTOCOL
        def null(self) -> str: ...
        
            
        # LOAD BANNER IMG
        def _load_image_pixmap(self) -> None:
            try:
                section_img: hou.HDASection = self.NODETYPE.definition().sections()[self.IMG_PIXMAP_SECTION_NAME]
            except KeyError:
                print(f"Warning: Banner image: HDASection[{self.IMG_PIXMAP_SECTION_NAME}] not found!")
            else:
                # PIXMAP LOAD
                self.IMG_PIXMAP = QtGui.QPixmap()
                self.IMG_PIXMAP.loadFromData(QtCore.QByteArray(section_img.binaryContents()))
                
                
        # LOAD SVG ICON
        def _load_svg_icon(self) -> None:
            svg_icon_name: str = self.SVG_ICON_W_SECTION_NAME
            try:
                if self.h_valid or self.splash_screen:
                    section_svg: hou.HDASection = self.NODETYPE.definition().sections()[self.SVG_ICON_W_SECTION_NAME]
                else:
                    section_svg: hou.HDASection = self.NODETYPE.definition().sections()[self.SVG_ICON_R_SECTION_NAME]
                    
            except KeyError:
                svg_icon_name = self.SVG_ICON_R_SECTION_NAME
                print(f"Warning: SVG icon: HDASection[{svg_icon_name}] not found!")
                
            else:
                svg_bytes: QtCore.QByteArray = QtCore.QByteArray(section_svg.binaryContents())
                self.SVG_ICON = SvgIcon(svg_bytes, parent=self.banner_container)
                self.SVG_ICON.resize(self.svg_icon_size, self.svg_icon_size)
            
            
        # CENTER WINDOW
        def _center_window(self) -> None:
            
            try:
                main_win: QtWidgets.QWidget = hou.qt.mainWindow()
                houdini_geom: QtCore.QRect = main_win.frameGeometry()
                
                best_screen: QtGui.QScreen | None = None
                max_area: int = 0
                for screen in QtWidgets.QApplication.screens():
                    intersect: QtCore.QRect = houdini_geom.intersected(screen.availableGeometry())
                    area: int = intersect.width() * intersect.height()
                    if area > max_area:
                        max_area = area
                        best_screen = screen

                if best_screen is None:
                    best_screen = QtWidgets.QApplication.primaryScreen()

                geom: QtCore.QRect = best_screen.availableGeometry()
                x: int = geom.x() + (geom.width() - self.width()) // 2
                y: int = geom.y() + (geom.height() - self.height()) // 2
                self.move(x, y)
                
            except Exception:
                geom: QtCore.QRect = QtWidgets.QApplication.primaryScreen().availableGeometry()
                x: int = (geom.width() - self.width()) // 2
                y: int = (geom.height() - self.height()) // 2
                self.move(x, y)


        # BUILD UI
        def _build_ui(self) -> None:
            
            self.setStyleSheet(f"""
                QWidget {{
                    background-color: {self.BG_COLOR};
                }}
                QLabel {{
                    color: {self.TEXT_COLOR};
                }}
            """)

            main_layout: QtWidgets.QVBoxLayout = QtWidgets.QVBoxLayout(self)
            main_layout.setContentsMargins(0, 0, 0, 0)
            main_layout.setSpacing(int(10 * self.dpi_scale))
            main_layout.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignCenter)

            # Banner
            self.banner_container: QtWidgets.QWidget = QtWidgets.QWidget()
            self.banner_container.setFixedSize(self.window_width, self.banner_height)
            self.banner_container.setStyleSheet("background: black;") # transparent
            main_layout.addWidget(self.banner_container)

            self.image_label: QtWidgets.QLabel = QtWidgets.QLabel(self.banner_container)
            self.image_label.setGeometry(0, 0, self.window_width, self.banner_height)
            self.image_label.setAlignment(QtCore.Qt.AlignCenter)
            self._update_banner()

            # Svg
            self._load_svg_icon()
            self._position_svg_icon()

            # Init font, dn't needed but just in case!
            if self.font_os is None:
                # in my case being on windows
                self.font_os = QtGui.QFont("Segoe UI")


            # Title
            title_label: QtWidgets.QLabel = QtWidgets.QLabel(self.APP_NAME, self)
            title_label.setAlignment(QtCore.Qt.AlignCenter)
            self.font_os.setPointSize(22)
            self.font_os.setBold(True)
            title_label.setFont(self.font_os)
            main_layout.addWidget(title_label)
            
            # Info
            info_label: QtWidgets.QLabel = QtWidgets.QLabel(self.INFO, self)
            info_label.setAlignment(QtCore.Qt.AlignCenter)
            self.font_os.setPointSize(16)
            self.font_os.setBold(False)
            info_label.setFont(self.font_os)
            info_label.setWordWrap(True)
            main_layout.addWidget(info_label)
            
            # Clickable links
            if self.LINKS:
                links_label: QtWidgets.QLabel = QtWidgets.QLabel(self.INFO, self)
                links_label.setAlignment(QtCore.Qt.AlignCenter)
                self.font_os.setPointSize(10)
                self.font_os.setBold(False)
                links_label.setFont(self.font_os)
                links_label.setWordWrap(True)
                links_label.setTextFormat(QtCore.Qt.RichText)
                links_label.setTextInteractionFlags(QtCore.Qt.TextBrowserInteraction)
                links_label.setOpenExternalLinks(True)
                links_label.setText(f"""
                <html>
                    <body>
                    <a href="https://www.alexnardini.net">Website</a>
                    <a href="https://www.instagram.com/alexnardini/">Instagram</a>
                    <a href="https://www.youtube.com/@alexnardiniITALY/videos">Youtube</a>
                    <a href="https://github.com/alexnardini/FLAM3_for_SideFX_Houdini">Github</a>
                    </body>
                </html>
                """)
                main_layout.addWidget(links_label)
            
            # Copyright
            copyright_label: QtWidgets.QLabel = QtWidgets.QLabel(self.APP_COPYRIGHT, self)
            copyright_label.setAlignment(QtCore.Qt.AlignCenter)
            self.font_os.setPointSize(10)
            copyright_label.setFont(self.font_os)
            copyright_label.setWordWrap(True)
            main_layout.addWidget(copyright_label)

            main_layout.addStretch()
            
            
        def _start_fade_in(self) -> None:
            # Fade in animation
            self.setWindowOpacity(0)
            self.fade_in_anim: QtCore.QPropertyAnimation = QtCore.QPropertyAnimation(self, b"windowOpacity")
            self.fade_in_anim.setDuration(self.FADE_IN_DURATION_MS)
            self.fade_in_anim.setStartValue(0)
            self.fade_in_anim.setEndValue(1)
            self.fade_in_anim.start()
            

        # BANNER UPDATE: SCALE + CROP
        def _update_banner(self) -> None:
            if self.IMG_PIXMAP:
                try:
                    w: int = self.banner_container.width()
                    h: int = self.banner_container.height()
                    scaled: QtGui.QPixmap = self.IMG_PIXMAP.scaled(w, h, QtCore.Qt.KeepAspectRatioByExpanding, QtCore.Qt.SmoothTransformation)
                    x_offset: int = (scaled.width() - w) // 2
                    y_offset: int = (scaled.height() - h) // 2
                    cropped: QtGui.QPixmap = scaled.copy(x_offset, y_offset, w, h)
                    self.image_label.setPixmap(cropped)
                    
                except Exception as e:
                    print("Failed to update banner:", e)
                    
            else:
                if (self.f3h_node is not None and self.h_valid) or self.splash_screen:
                    self.image_label.setText("🎨")
                    font = self.font_os
                    font.setPointSize(72)
                    self.image_label.setFont(font)
                    self.image_label.setAlignment(QtCore.Qt.AlignCenter)


        # SVG POSITION
        def _position_svg_icon(self) -> None:
            if self.SVG_ICON:
                x: int = (self.banner_container.width() - self.SVG_ICON.width()) // 2
                y: int = (self.banner_container.height() - self.SVG_ICON.height()) // 2
                self.SVG_ICON.move(x, y)
                
                
        # FADE OUT ANIMATION
        def _start_fade_out(self, fade_out_duration_ms) -> None:
            self.fade_out_anim: QtCore.QPropertyAnimation = QtCore.QPropertyAnimation(self, b"windowOpacity")
            self.fade_out_anim.setDuration(fade_out_duration_ms)
            self.fade_out_anim.setStartValue(1)
            self.fade_out_anim.setEndValue(0)
            self.fade_out_anim.finished.connect(self._exit)
            self.fade_out_anim.start()
                
            
        # PYSIDE: RESIZE EVENT
        def resizeEvent(self, event: QtGui.QResizeEvent) -> None:
            super().resizeEvent(event)
            self._position_svg_icon()
            self._update_banner()


        # PYSIDE: DRAG SUPPORT MOUSE PRESS EVENT
        def mousePressEvent(self, event: QtGui.QMouseEvent) -> None:
            if event.button() == QtCore.Qt.LeftButton:
                
                if __pyside_version__ == 6:
                    self.BASE_DRAG_POSITION = event.globalPosition().toPoint()
                elif __pyside_version__ == 2:
                    self.BASE_DRAG_POSITION = event.globalPos()


        # PYSIDE: DRAG SUPPORT MOUSE MOVE EVENT
        def mouseMoveEvent(self, event: QtGui.QMouseEvent) -> None:
            if event.buttons() == QtCore.Qt.LeftButton and self.BASE_DRAG_POSITION:
                
                if __pyside_version__ == 6:
                    delta = event.globalPosition().toPoint() - self.BASE_DRAG_POSITION
                elif __pyside_version__ == 2:
                    delta = event.globalPos() - self.BASE_DRAG_POSITION
                    
                self.move(self.x() + delta.x(), self.y() + delta.y())
                
                if __pyside_version__ == 6:
                    self.BASE_DRAG_POSITION = event.globalPosition().toPoint()
                elif __pyside_version__ == 2:
                    self.BASE_DRAG_POSITION = event.globalPos()
                
                
        # PYSIDE: CLOSE EVENT
        def closeEvent(self, event: QtGui.QCloseEvent) -> None:
            try:
                delattr(builtins, self.ps_app_name)
            except AttributeError:
                pass
            
            event.accept()
            

        # EXIT
        def _exit(self) -> None:
            self.close()
