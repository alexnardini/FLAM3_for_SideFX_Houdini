/*  
 /  Tested on:  Houdini 19.x
 /              Houdini 19.5
 /              Houdini 20.x
 /              Houdini 20.5
 /
 /  Title:      FLAM3H. SideFX Houdini FLAM3: 2D
 /  Author:     Alessandro Nardini
 /  date:       October 2020, Last revised February 2024
 /
 /  info:       Based on the original: "The Fractal Flame Algorithm"
 /  Authors:    Scott Draves, Erik Reckase
 /
 /  Paper:      https://flam3.com/flame_draves.pdf
 /  Date:       September 2003, Last revised November 2008
 /
 /  Github:     https://github.com/scottdraves/flam3
 /  Date:       December 2002, Last revised May 2015
 /
 /  Name:       TFFAUICOLLECT "CVEX"
 /
 /  Comment:    UI FLAM3H viewport TAG infos collection.
*/


#pragma opname  "TFFAuicollect"
#pragma oplabel "TFFAuicollect"
#pragma opmininputs 1
#pragma opmaxinputs 3


// TAG GENOME
struct gemtag{

    // ITERATORS
    string sIDX[];
    int    RES, p1t[], p2t[], v1t[], v2t[], v3t[], v4t[], P1t[];
    float  pbw[], p1w[], p2w[], v1w[], v2w[], v3w[], v4w[], P1w[];
    
    void gemtagBuild(){

        // SYS
        sIDX = detail(2, "sIDX");
        RES = detail(2, "RES");
        // WEIGHTS
        pbw = detail(2, "pbw");
        p1w = detail(2, "p1w");
        p2w = detail(2, "p2w");
        v1w = detail(2, "v1w");
        v2w = detail(2, "v2w");
        v3w = detail(2, "v3w");
        v4w = detail(2, "v4w");
        P1w = detail(2, "P1w");
        // TYPES
        p1t = detail(2, "p1t");
        p2t = detail(2, "p2t");
        v1t = detail(2, "v1t");
        v2t = detail(2, "v2t");
        v3t = detail(2, "v3t");
        v4t = detail(2, "v4t");
        P1t = detail(2, "P1t");
    }
}


// TAG GENOME
struct gemtagff{

    // FF
    int    fp1t, fv1t, fv2t, fP1t, fP2t;
    float  fp1w, fv1w, fv2w, fP1w, fP2w; 

    void gemtagffBuild(const int FF){

        if(FF){
            // WEIGHTS
            fp1w = detail(2, "fp1w");
            fv1w = detail(2, "fv1w");
            fv2w = detail(2, "fv2w");
            fP1w = detail(2, "fP1w");
            fP2w = detail(2, "fP2w");
            // TYPES
            fp1t = detail(2, "fp1t");
            fv1t = detail(2, "fv1t");
            fv2t = detail(2, "fv2t");
            fP1t = detail(2, "fP1t");
            fP2t = detail(2, "fP2t");
        }
    }

}


void
_TFFAuicollect(string _bound_VARTYPE[]; int _bound_XS){

    string T[];
    string Ts[] = { "linear", 
                    "sinusoidal",
                    "spherical",
                    "swirl",
                    "horseshoe",
                    "polar",
                    "handkerchief",
                    "heart",
                    "disc",
                    "spiral",
                    "hiperbolic",
                    "diamond",
                    "ex",
                    "julia",
                    "bent",
                    "waves",
                    "fisheye",
                    "popcorn",
                    "exponential",
                    "power",
                    "cosine",
                    "rings",
                    "fan",
                    "bubble",
                    "cylinder",
                    "eyefish",
                    "blur",
                    "curl",
                    "ngon",
                    "pdj",
                    "blob",
                    "juliaN",
                    "juliaScope",
                    "gaussian_blur",
                    "fan2",
                    "rings2",
                    "rectangles",
                    "radialblur",
                    "pie",
                    "arch",
                    "tangent",
                    "square",
                    "rays",
                    "blade",
                    "secant2",
                    "twintrian",
                    "cross",
                    "disc2",
                    "supershape",
                    "flower",
                    "conic",
                    "parabola",
                    "bent2",
                    "bipolar",
                    "boarders",
                    "butterfly",
                    "cell",
                    "cpow",
                    "edisc",
                    "elliptic",
                    "noise",
                    "escher",
                    "foci",
                    "lazysusan",
                    "loonie",
                    "pre blur",
                    "modulus",
                    "oscope",
                    "polar2",
                    "popcorn2",
                    "scry",
                    "separation",
                    "split",
                    "splits",
                    "stripes",
                    "wedge",
                    "wedge julia",
                    "wedge sph",
                    "whorl",
                    "waves2",
                    "exp",
                    "log",
                    "sin",
                    "cos",
                    "tan",
                    "sec",
                    "csc",
                    "cot",
                    "sinh",
                    "cosh",
                    "tanh",
                    "sech",
                    "csch",
                    "coth",
                    "auger",
                    "flux",
                    "mobius",
                    "curve",
                    "perspective",
                    "bwraps",
                    "hemisphere",
                    "polynomial",
                    "crop",
                    "unpolar",
                    "glynnia",
                    "point_symmetry" };


    // SYS
    int FF, RIP, MB, F3C, iter, inum, xaos_chk, xaos_mode;
    FF   = chi("doff");
    RIP  = chi("rip");
    MB   = chi("domb");
    iter = chi("iter");
    // From Fractorium: flam3 comptibility (f3c). Check inside variations.h to see both versions of each.
    // The behavior of the:
    // cos, cosh, cot, coth, csc, csch, sec, sech, sin, sinh, tan and tanh variations
    // are different in flam3/Apophysis versus Chaotica.
    //      Checked:    use the Apophysis behavior.
    //      Unchecked:  use the Chaotica behavior.
    F3C = chi("f3c");

    inum = chi("flamefunc");
    xaos_chk = detail(1, "XS");
    xaos_mode = chi("xm");

    // GEM TAG
    gemtag GEMTAG;
    GEMTAG->gemtagBuild();
    string sIDX[]; /* CAST */ sIDX=GEMTAG.sIDX;
    int    RES, p1t[], p2t[], v1t[], v2t[], v3t[], v4t[], P1t[]; /* CAST */ RES=GEMTAG.RES; p1t=GEMTAG.p1t; p2t=GEMTAG.p2t; v1t=GEMTAG.v1t; v2t=GEMTAG.v2t; v3t=GEMTAG.v3t; v4t=GEMTAG.v4t; P1t=GEMTAG.P1t;
    float  pbw[], p1w[], p2w[], v1w[], v2w[], v3w[], v4w[], P1w[]; /* CAST */ pbw=GEMTAG.pbw; p1w=GEMTAG.p1w; p2w=GEMTAG.p2w; v1w=GEMTAG.v1w; v2w=GEMTAG.v2w; v3w=GEMTAG.v3w; v4w=GEMTAG.v4w; P1w=GEMTAG.P1w;
    // GEM TAG tmp
    float ppbw, ppw1, ppw2, w1, w2, w3, w4, Pw1;
    // GEM FF TAG
    gemtagff GEMTAGFF;
    GEMTAGFF->gemtagffBuild(FF);
    int    fp1t, fv1t, fv2t, fP1t, fP2t; /* CAST */ fp1t=GEMTAGFF.fp1t; fv1t=GEMTAGFF.fv1t; fv2t=GEMTAGFF.fv2t; fP1t=GEMTAGFF.fP1t; fP2t=GEMTAGFF.fP2t;
    float  fp1w, fv1w, fv2w, fP1w, fP2w; /* CAST */ fp1w=GEMTAGFF.fp1w; fv1w=GEMTAGFF.fv1w; fv2w=GEMTAGFF.fv2w; fP1w=GEMTAGFF.fP1w; fP2w=GEMTAGFF.fP2w;

    append(T, concat("[", itoa(iter), "]"));
    if(xaos_chk){
        if(!xaos_mode) append(T, concat("[", "Xt", "]"));   // xaos TO
        else append(T, concat("[", "fX", "]"));             // xaos FROM
    }

    if(RIP) append(T, "RIP");
    if(F3C) append(T, "F3C");
    if(MB) append(T, "MB");

    for(int i=0; i<RES; ++i){

        string ITERNUM, VAR, W, PP[], PB, V1, V2, V3, V4, P1;
        ITERNUM = concat("(", sIDX[i], ")");

        w1 = v1w[i];
        if(w1!=0) V1 = Ts[v1t[i]]+":";
        else V1 = ":";
        w2 = v2w[i];
        if(w2!=0) V2 = Ts[v2t[i]]+":";
        else V2 = ":";
        w3 = v3w[i];
        if(w3!=0) V3 = Ts[v3t[i]]+":";
        else V3 = ":";
        w4 = v4w[i];
        if(w4!=0) V4 = Ts[v4t[i]]+":";
        else V4 = ":";
        float w_total = w1+w2+w3+w4;
        
        // Pre blur
        ppbw = pbw[i];
        if(ppbw>0){ if(w_total != 0) PB="*"; }
        // Pre var 1
        ppw1 = p1w[i];
        if(ppw1>0){ if(w_total != 0) append(PP, Ts[p1t[i]]); }
        // Pre var 2
        ppw2 = p2w[i];
        if(ppw2>0){ if(w_total != 0) append(PP, Ts[p2t[i]]); }
        // Build pre vars tag string
        string p_build;
        if(len(PP)==1) p_build = concat( "[ ", PP[0], " ]:");
        else if(len(PP)>1) p_build = concat( "[ ", join(PP, ", "), " ]:");
        else p_build = "";
        // Post var
        Pw1 = P1w[i];
        if(Pw1>0) { if(w_total != 0) P1 = concat( "[ ", Ts[P1t[i]], " ]:"); }
        // Iterator weight
        if(w_total != 0) W = sprintf( "%g", chf(concat("iw_", sIDX[i]))); else W = "";
        
        // Reformat iterator weight string floats
        string out[] = {};
        string SPLIT[] = split(W, ".");
        if(len(SPLIT)>1){
            int count = 1;
            foreach(string s; SPLIT){ append(out, s[:(6/count)]); count++; }
        }
        else out = SPLIT;
        W = join(out, ".");
        VAR = concat(PB, ITERNUM, p_build, V1, V2, V3, V4, P1, W);

        append(T, VAR);
        PP = {};
    }

    if(FF){

        string VAR, FV1, FV2, Fp[], FP[];
        if(fv1w!=0) FV1 = Ts[fv1t]+":";
        else FV1 = ":";
        if(fv2w!=0) FV2 = Ts[fv2t]+":";
        else FV2 = ":";
        float fw_total = fv1w+fv2w;
        // Pre var 01
        if(fp1w>0){ if(fw_total != 0) append(Fp, Ts[fp1t]); }
        string Fp_build;
        if(len(Fp)==1) Fp_build = concat( "[ ", Fp[0], " ]:");
        else if(len(Fp)>1) Fp_build = concat( "[", join(Fp, ", "), "]:");
        else Fp_build = "";
        // Post var 1
        if(fP1w>0){ if(fw_total != 0) append(FP, Ts[fP1t]); }
        // Post var 2
        if(fP2w>0){ if(fw_total != 0) append(FP, Ts[fP2t]); }
        // Build post vars tag string
        string FP_build;
        if(len(FP)==1) FP_build = concat( "[ ", FP[0], " ]");
        else if(len(FP)>1) FP_build = concat( "[ ", join(FP, ", "), " ]");
        else FP_build = "";

        VAR = concat(Fp_build, FV1, FV2, FP_build);
        append(T, toupper(VAR));
        }
        
    _bound_VARTYPE = T;
    _bound_XS = xaos_chk;
}

cvex
TFFAuicollect( export string VARTYPE[] = {};
               export int XS = 0; )
{
    _TFFAuicollect(VARTYPE, XS);
}
