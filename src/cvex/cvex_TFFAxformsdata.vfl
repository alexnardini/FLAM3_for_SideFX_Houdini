/*  
 /  Tested on:  Houdini 19.x
 /              Houdini 19.5
 /              Houdini 20.x
 /              Houdini 20.5
 /
 /  Title:      FLAM3H. SideFX Houdini FLAM3: 2D
 /  Author:     Alessandro Nardini
 /  date:       December 2024, Last revised December 2024
 /
 /  info:       Based on the original: "The Fractal Flame Algorithm"
 /  Authors:    Scott Draves, Erik Reckase
 /
 /  Paper:      https://flam3.com/flame_draves.pdf
 /  Date:       September 2003, Last revised November 2008
 /
 /  Github:     https://github.com/scottdraves/flam3
 /  Date:       December 2002, Last revised May 2015
 /
 /  Name:       XFORMS DATA "CVEX"
 /
 /  Comment:    Collect all data for the xforms handles.
*/


#pragma opname  "TFFAxformsdata"
#pragma oplabel "TFFAxformsdata"
#pragma opmininputs 1
#pragma opmaxinputs 1

#include <functions.h>

void
_TFFAxformsdata(string _bound_sIDX[]; int _bound_POST[], _bound_RES; vector2 _bound_X[], _bound_Y[], _bound_O[], _bound_PX[], _bound_PY[], _bound_PO[]; vector _bound_COL[])
{

    // INIT
    int inum = chi("../../flamefunc");
    int va[], POST[];
    string sIDX[];
    
    // ALL ACTIVE XFORMS/ITERATORS
    for(int i=0; i<inum; ++i){
        
        string iIDX = itoa(i+1);
        append(va, chi(concat("../../vactive_", iIDX)));
        int post = chi(concat("../../dopost_",  iIDX));
        float IWcheck = chf(concat("../../iw_", iIDX));
        if(IWcheck==0) va[i]=0;
        if(!va[i]) continue;
        append(sIDX, iIDX);
        append(POST, post);
    }

    // INIT
    int res = len(sIDX);
    vector2 x[], y[], o[], px[], py[], po[];
    resize(x, res); y=o=px=py=po=x;
    float _a;
    vector color = {1, 0, 0}; // Always start from ZERO hue
    vector new[] = {};
    vector2 _x, _y;
    matrix2 _m2;
    string  idx;
    
    for(int i=0; i<res; ++i){

        idx=sIDX[i];

        // PRE AFFINE
        _x = chu(concat("../../x_", idx));
        _y = chu(concat("../../y_", idx));
        _a = chf(concat("../../ang_", idx));
        if(_a!=0){
            affineRot(_m2, _x, _y, -radians(_a));
            _x = set(_m2.xx, _m2.xy);
            _y = set(_m2.yx, _m2.yy);
        }
        x[i] = _x; y[i] = _y;
        o[i] = chu(concat("../../o_", idx));
        // POST AFFINE
        int PPL = chi(concat("../../dopost_", idx));
        if(PPL){
            _x = chu(concat("../../px_", idx));
            _y = chu(concat("../../py_", idx));
            _a = chf(concat("../../pang_", idx));
            if(_a!=0){
                affineRot(_m2, _x, _y, -radians(_a));
                _x = set(_m2.xx, _m2.xy);
                _y = set(_m2.yx, _m2.yy);
            }
            px[i] = _x; py[i] = _y;
            po[i] = chu(concat("../../po_", idx));
        }

        // COLOR
        float h = rand(atoi(idx));
        vector hsv = rgbtohsv(color);
        hsv[0] = h;
        append(new, hsvtorgb(hsv));
    }

    // OUT SYS
    _bound_sIDX = sIDX;
    _bound_POST = POST;
    _bound_RES  = len(sIDX);
    // OUT Affine
    _bound_X = x;
    _bound_Y = y;
    _bound_O = o;
    _bound_PX = px;
    _bound_PY = py;
    _bound_PO = po;
    // OUT COLOR
    _bound_COL = new;
}

cvex
TFFAxformsdata( export string sIDX[] = {};
                export int POST[] = {};
                export int RES = 0;
                export vector2 X[] = {};
                export vector2 Y[] = {};
                export vector2 O[] = {};
                export vector2 PX[] = {};
                export vector2 PY[] = {};
                export vector2 PO[] = {};
                export vector  COL[] = {};)
{
    _TFFAxformsdata(sIDX, POST, RES, X, Y, O, PX, PY, PO, COL);
}
