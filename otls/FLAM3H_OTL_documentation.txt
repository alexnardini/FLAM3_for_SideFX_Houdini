#icon: opdef:.?FLAM3H_DOC_icon.svg
#type: node
#context: sop
#namespace: FLAM3
#internal: FLAM3H
#version: 1.1.80 - Gold

"""The Fractal Flame Algorithm: FLAM3 ( vcc compiler: SideFX Houdini v20.0.506 )"""


:box:
    #display: rounded white


== Welcome to FLAM3 for SideFX Houdini ==
( _H19.x and H20.x only_ )

_*A bit of history* ( from wikipedia )_:

[Scott Draves|Wp:Scott_Draves]
[The Fractal Flame Algorithm|Wp:Fractal_Flame]
[Electric Sheep|Wp:Electric_Sheep]
[IFS|Wp:Iterated_function_system]
[Fractal Art|Wp:Fractal_art]
[Apophysis|Wp:Apophysis_(software)]

_*Preface*_:

The inception of this implementation dates back to 2020, during COVID-19. 
At first, it was just a straightforward point wrangle exercise to experiment with some of the formulas from the fractal flame algorithm.
I didn't know much about the subject at the time, but as I began experimenting with some of the free and open-source fractal flame editors like Apophysis and Fractorium, I grew to love the field and gradually persuaded myself that I could port the entire algorithm and functionalities using Houdini out of the box.
Undoubtedly, it required some time to comprehend everything completely, but as I was also learning how to create fractal art, It slowly shaped into the proper form.

These days, this tool has all the features found in other third-party programs, plus a bunch more exclusive to this implementation.
Additionally, when combined with Houdini's procedural paradigm and toolsets, fractal flames reach previously unheard-of levels of possibilities.

_Slimy paint - author: Alessandro Nardini_
[Image:opdef:.?FLAM3H_DOC_intro.jpg]
_A huge special thanks and lots of gratitude toward my family who kept up with me for so long while I was inside the fractal Flame bubble!_

_*Implementation of the original "The Fractal Flame Algorithm": [FLAM3|https://github.com/scottdraves/flam3]*_

_*Github repository I used a lot as reference: "Fractorium" from Matt Feemster: [FRACTORIUM|https://bitbucket.org/mfeemster/fractorium/src/master/]*_

:box:
    #display: rounded white



@intro

_Individuals and fractal flames are alike. Each one has its own personality, having gone through their own unique set of events that have helped shape who they are today._
_Consider the various formulas that make up fractal flames as different brushes or life event brushes._
_Each of these events can be identified by their patterns of self-similarity; while some have a bigger influence on the final forms and colors than others, all of them contribute to the composition as a whole._
_This is akin to a person's genome, or DNA._
_Together, all of these variables contribute to the interesting nature of the fractal flame discipline, with its seemingly endless possibilities, effects, and patterns._

FLAM3H, as the name suggests, is the implementation of _the fractal flame algorithm_ inside SideFX Houdini. There have been different revisions of the same algorithm in the past years, this is the implementation of FLAM3.

Fractal art is not easy at all. For this reason, it is suggested that you possess prior experience with this art form, may that be with Apophysis, Fractorium or really any other fractal flame editor out there. This implementation was influenced by Apophysis, particularly in the fast/quick workflow design, but it has been biased in its underlying code toward Fractorium.

There is a very large, kind, and talented community out there that you can tap into and gather lots of information from to learn how to do fractal art.

Generally speaking, and based on my own learning experiences, FLAM3H can complete every tutorial you can find for any of the existing fractal flame editors out there. The majority of tutorials you can find are for Apophysis, the first program to use the algorithm with a graphical user interface. It rose to prominence as the most widely used fractal Flame editor and will always occupy a special place in the fractal art history.

Here a few at hand:

_*[DevianArt - Apophysis tutorial: Splits Elliptic|https://www.deviantart.com/satania/art/Tutorial-Splits-elliptic-150422119]*_

_*[DevianArt - Apophysis tutorial: Spherical bubbles|https://www.deviantart.com/fiery-fire/art/Apo-Tuto-Spherical-Bubbles-127911026]*_

_*[DevianArt - Apophysis tutorial: Bipolar shapes|https://www.deviantart.com/satania/art/Tutorial-Bipolar-Shapes-213391274]*_

_*[DevianArt - Apophysis tutorial: Double wedge|https://www.deviantart.com/teundenouden/art/Double-Wedge-Tutorial-810709969]*_

_*[DevianArt - Apophysis tutorial: Hemispherical|https://www.deviantart.com/c-91/art/Hemispherical-Apophysis-Tutorial-663954258]*_


A considerable amount of effort has been allocated to ensure that, assuming that the same variations are utilized within FLAM3H and that they remain within its limitations, a one-to-one match result is consistently obtained.

Being inside Houdini has its advantages, just think of the possibilities of utilizing his procedural paradigm and tool sets to animate your fractal flames. It also makes it very easy to build a pipeline around this tool using Houdini’s Python HOM libraries.


@Platforms

:platform:Windows
    This HDA and all its Python code has been extensively tested on Windows.

    
_The following platforms should function flawlessly, though I didn't get a chance to test every feature, so some may not function as intended._
    
:platform:Mac

:platform:Linux



@parameters FLAM3H Tabs parameters

    
== Global parameters == (GLOBAL)
    
~~~
:box:
    #display: inverted teal

    *GLOBAL*
    Here, you will define the quality of the fractal Flame algorithm solution.

density:
    #id: GLOBAL
    Number of points to use. For high-quality fractals, start from 20M up to 500M and more, depending on the type of fractal flame you end up with. As a general rule, the more, the better.
    * Must strike a balance between processing speed and quality.

    
density presets mini menu:
    #id: GLOBAL
    Will allow you to select a density value quickly from some presets.
    
Reset density:
    #id: Global
    [Smallicon:opdef:.?iconStarSwapSVG.svg]
    
    Reset density to its default: 500k
        
    
iterations:
    #id: GLOBAL
    Number of iterations to use.
    
    You must experiment with the number of iterations and always go as low as possible to save on execution time.
    You went too low when the fractal Flame start to turn *_blocky_*, which happens when it crosses its own minimum.
    
    It is advised that occasionally you bump up this number a little to see if there is anything you are overlooking.
    For instance, certain Flames can seem completely different with higher number of iterations.
    
    _But generally speaking, for many fratcal Flames shapes:_
    
    - You do not need many iterations to get some good fractal Flames going, between 10 and 24 is usually more than you need while keeping execution speed acceptable.
    - If you increase the iterator weight, use xaos to build containers, or use some kind of variation, you will require a higher number to resolve and show you the proper result.
    
    Almost all the fractal Flames showcased inside FLAM3H's Instagram account
    use a maximum of 64 iterations, with a few exceptions reaching 96 and, in rare cases, 128/256 and more.
    
    Some flames require a truly high number of iterations to resolve properly.
    
    Listed below are presets from Chaotica software that were converted to FLAM3H.
    They were chosen because some of them are very expensive to solve and because they make use of variations I've already implemented.

    Some of them take thousands of iterations to produce the desired results, while others take only a few hundred:
    
    _*[ieddaka gnarl: 1280 iterations|https://github.com/alexnardini/FLAM3_for_SideFX_Houdini/blob/main/img/ChaoticaToFLAM3HOUDINI_00.jpg]*_
    
    _*[blue modulus: 512 iterations|https://github.com/alexnardini/FLAM3_for_SideFX_Houdini/blob/main/img/ChaoticaToFLAM3HOUDINI_01.jpg]*_
    
    _*[lazyswirls: 512 iterations|https://github.com/alexnardini/FLAM3_for_SideFX_Houdini/blob/main/img/ChaoticaToFLAM3HOUDINI_02.jpg]*_
    
    _*[majestic: 64 iterations|https://github.com/alexnardini/FLAM3_for_SideFX_Houdini/blob/main/img/ChaoticaToFLAM3HOUDINI_03.jpg]*_
    
    
    You can create some beautiful fractal Flames with just a few iterations. Below are some examples I did myself:
    
    _*[Knot clusters: 6 iterations|https://github-production-user-asset-6210df.s3.amazonaws.com/42110232/270743580-f3c891ed-21c6-474e-89fa-62020149d821.jpg]*_
    
    _*[Dancing stars: 12 iterations|https://github-production-user-asset-6210df.s3.amazonaws.com/42110232/270014121-b68b27d9-ebb7-4580-ad5f-9d114f2585f7.jpg]*_

    TIP:
        When: *Auto add iter num to Flame name* toggle is ON inside the OUT Tab,
        changing the iteration's parameter will update the flame name, if any have been typed.
        
        

:box:
    #display: rounded white

== SYS parameters == (SYS)

~~~
:box:
    #display: inverted teal

    *SYS:* _System utilities._
    
    Tools available to enhance and speed up the workflow.
    
    I keep changing and adding functionalities, it is still a work in progress, but thus far, this most recent configuration has been successful.

:box:
    #display: rounded white
    
    == SYS: Utils == (SYSUTILS)
    
FLAM3H documentation:
    #id: SYS
    [Smallicon:opdef:.?icon_TagOSVG.svg]
    
    Display this documentation.
    
FF:
    #id: SYS
    Enable and disable [finalXform|#FF] transform/iterator.
    
    
RIP:
    #id: SYS
    Remove invalid points. *INF*, *NAN*, *Zero Opacity* and *out-of-bounds* points.

    After the algorithm transforms the points, it is possible for some of those points to shoot to infinity.
    Turn this on while rendering ( particularly for a sequence ) to correct any failed or black frames that may appear.
    
    NOTE:
        If rendering a flame seems unusually slow, it's probably because certain points wind up being really far from the zero world.
        Those points will be eliminated if this option is turned ON.


:box:
    #display: rounded white
    
    == SYS: Tag == (SYSTAG)
[Image:opdef:.?FLAM3H_DOC_tag.svg]
_The above tag reference's image shows a flame with two iterators ( the second one being disabled ) with the FF._

TAG:
    #id: SYS
    [Smallicon:opdef:.?icon_TagOBlueSVG.svg]
    
    Enable/disable vieport TAG infos.
    
    _Since it is helpful to review the fractal Flame being worked on, this should always be turned on. For every iterator, the weight is also shown._
    
    * The iteration number will be the very first number inside square brackets.
    * [Xaos|#FLAMEITERXAOS] (_when active_) will be next inside square brackets. Read the xaos documentation to know more about it.
    * Xaos TO will be: *Xt*
    * Xaos FROM wil be: *fX*
    * [F3C|#PREFSGENERAL] when the preference's option "flam3 compatibility" is ON.
    * [Motion blur|#MB] (_when active_) will be next inside square brackets.
    * [Iterator variations|#FLAMEITERVARS] are lowercase.
    * [FF variations|#FFVARS] are UPPER CASE.
    * "*pre_blur*" will be indicated witn an asterisk * at the beginning of each iterator and before all variations.
    * PRE variations will be inside square brackets at the beginning of each iterator, or FF.
    * POST variations will be inside square brackets at the end of each iterator, or FF
    * The [iterator's weight|#FLAMEITER] value will be the last in each iterator.
    * The colons *:* indicate how many variation slots are still available ( 4 in case of an iterator VAR section, plus a last colon *:* as a separator from the iterator's weight).
    * If an iterator is disabled, it will be displayed as: " *::::::::::* "
    
    TIP:
        The Tag icon will change when:
        
        - [Smallicon:opdef:.?icon_TagOBlueSVG.svg]: when the Tag is ON ( _default_ ).
        - [Smallicon:opdef:.?icon_TagOBlueSVG_disabled.svg]: when the Tag is OFF.
        - [Smallicon:opdef:.?icon_TagORedSVG.svg]: when the OUT Camera sensor viz mode is ON.
        - [Smallicon:opdef:.?icon_TagOSVG.svg]: when iterator's count is zero and when Xaos is active but you cross the 20 iterators limit. ( _only in the viewport Tag_ )
        
        When in OUT Camera sensor mode, the Tag icon will turn red to allow to exit the mode also when inside a different tab other than the OUT tab.
        Once clicked, it will exit the mode and back to being the default Tag blue icon.
         
TAG size:
    #id: SYS
    Set different viewport TAG sizes.
    
    
:box:
    #display: rounded white
    
    == SYS: Sierpiński triangle == (SYSDEFAULT)
    
loaddef:
    #id: SYS
    [Smallicon:opdef:.?iconSierpinskyDefSVG.svg]
    
    Load/reset to default Sierpiński triangle preset.
    
:box:
    #display: rounded white
    
    == SYS: Color palette == (SYSCP)
    
CP Presets mini menu:
    #id: SYS
    Select a preset from the [CP Tab|#CP] JSON file that is presently open and load it.
    This is being introduced since it is convenient to switch palette without constantly entering the CP Tab.
    
    TIP:
        To populate this menu, load a palette *.json file first inside the CP Tab.
        
    
CP Preset reload:
    #id: SYS
    [Smallicon:opdef:.?iconPrideSVG.svg]
    
    Reload the selected CP palette preset. 
    
:box:
    #display: rounded white
    
    == SYS: IN Presets == (SYSIN)
    
IN Presets mini menu:
    #id: SYS
    Select a preset from the [IN Tab|#INF] Flame file that is presently open and load it.
    This is being introduced since it is convenient to switch flame presets without constantly entering the IN Tab.
    
    TIP:
        To populate this menu, load a valid *.flame file first inside the IN Tab.
    
IN Preset reload:
    #id: SYS
    [Smallicon:opdef:.?iconWhiteSVG.svg]
    
    - ((LMB)) If there is a selected IN preset, it will reload it.
    - ((ALT)) + ((LMB)) to paste a flame from the clipboard.

    The render properties of a flame preset loaded from the clipboard will be automatically copied into the OUT render properties on load.

    TIP:
        - Loading a flame from the clipboard is useful when going back and forth with a third-part application like for example: Fractorium.
        - In Fractorium, you can alter the flame, copy it into the clipboard, and then load it from the clipboard inside FLAM3H to see the changes.
    
:box:
    #display: rounded white
    
    == SYS: OUT Flame presets == (SYSOUT)
    
OUT Presets mini menu:
    #id: SYS
    This menu is simply provided as information only.

    If there are any Flames in the chosen output file, they will be displayed.
    This menu will refresh once you add a new Flame to it.
    It will always be set to the last Flame’s name you saved.
    
    TIP:
        To populate this menu, load a valid *.flame file first inside the OUT Tab.
        
        
    NOTE:
        Saving Flames from this icon, will always use a default name that uses the current date and time.
        In case you'd like to give your flames a proper name, you can do so from inside the OUT Tab.
    
OUT Save:
    #id: SYS
    [Smallicon:opdef:.?iconWhiteStarSVG.svg]
    
    - ((LMB)) to save this flame inside the selected OUT file, if any. If the selected file exists and already contains some Flames in it, it will append the current one.
    - ((CTRL)) + ((LMB)) to erase the content of the file and overwrite it with only this Flame.
    - ((SHIFT)) + ((LMB)) will open the file explorer to the file location.
    - ((ALT)) + ((LMB)) to copy this flame into the clipboard.

    If the selected file does not exist, it will be created.

    If the selected file is not a valid Flame file type, nothing will happen.
    


:box:
    #display: rounded white

== FLAME: iterators parameters == (FLAME)
    
~~~
:box:
    #display: inverted teal

    *FLAME:* _Flame xforms/iterators._
    
    This is where you'll spend the majority of your time, along with the *FF* Tab.
    
    Here you will create your fractal Flame logic.
    Since every parameter has the same name inside, if you have ever used Apophysis, Fractorium, or other fractal Flame editors, you will almost immediately feel at home.
    The logic you will operate with will be the same.
    
:box:
    #display: rounded white
    
    == Number of iterators ( Add/Remove ) ==
    
number of iterators:
    #id: FLAME
    
    Number of iterators to use.
    This is equivalent to the number of triangle handles you have inside the popular fractal Flame editors out there.
    
    Every iterator acts as a container for functions, the algorithm will mix or shuffle them based on your logic.
    
    NOTE:
        The order of the iterators does not matter at all.
        For this reason, it is suggested to create them one after the other, sequentially.
    
:box:
    #display: rounded white
    
    == Iterator == (FLAMEITER)

note:
    #id: FLAME
    A name for this iterator.
    
    NOTE:
        The text you write here will be stored with the flame file and also shown inside Apophysis and Fractorium as the iterator's name.
    
copy/paste:
    #id: FLAME
    [Smallicon:opdef:.?iconStarSwapRedSVG.svg]

    All the necessary methods for copy/paste iterator's data are contained in this icon. This icon allows you to mark an iterator for being copied, and then copy the data from the marked iterator into another iterator number — even if it is located inside a separate FLAM3H node.
    When you paste the data, it wil copy everything from the marked iterator but not Xaos. Once an iterator has been marked, you can use the mini menu next to the icon to copy individual sections from the marked iterator, including Xaos.
    
    When you mark an iterator, you establish a live connection with it and the data will be copied from it only when you ((CTRL)) + ((LMB)) from inside another iterator either on the same FLAM3H node or on a different one.
    This way you can keep the iterator marked while working and paste again its data somewhere else after making additional changes to its contents.

    Below are the different options on how you can use this icon:
    
    - ((LMB)) to mark this iterator for being copied. If already marked, it will unmark it.
    - ((CTRL)) + ((LMB)) to copy the values from the marked iterator into this iterator.
    - ((SHIFT)) + ((LMB)) to unmark this FLAM3H node marked iterator for being copied.
    
A tip:
    #id: FLAME
    [Smallicon:opdef:.?iconStarSwapBluSVG.svg]
    
    Show active iterator informations and tips.
    
A:
    #id: FLAME
    Enable/Disable this iterator.
    
    TIP:
        If an iterator is disabled, it won't be included when saving the Flame out into a flame file.
        In case you still want to include the inactive iterator in the file, set its weight to zero instead.
    
W:
    #id: FLAME
    The Weight of this iterator. Calculate the likelihood that this iterator will be selected during the Chaos game. You may require more iterations to correctly resolve the shapes of the fractal Flame you are working on if an iterator weight is higher than the others.
    
:box:
    #display: rounded white

    == Iterator: Xaos == (FLAMEITERXAOS)
    
xaos:
    #id: FLAME
    
    _From Fractorium help page._
    
    *What is Xaos ?*
    
    Xaos provides more fine-grained control over the selection of xforms on each iteration.
    It is expressed as a probability modifier for each xform in relation to every other xform.

    The default state is for all elements to have a value of 1, which means that xaos is not used.
    When any element is changed to something other than 1, xaos is in effect.

    Xaos specifies how likely a xform is to be chosen based on the previous xform that was chosen.
    Alternatively, this can also be expressed as the probability modifier of the next chosen xform based on the currently chosen one.
    These two methods of stating xaos are known as “from” and “to”.
        
    
    [Image:opdef:.?FLAM3H_DOC_xaos_pathsSVG.svg]
    _The above image shows five iterators with one variation each and how they are connected to each other through a hypothetical Xaos setting._
        

    
    The default mode is xaos TO. You can change it to use xaos FROM mode instead in the preferences tab.
    
    _xaos TO and xaos FROM are at their core each other's reflections. This means they are the same data, but one is the transpose of the other._
    
    _A matrix transpose is a matrix flipped along its diagonal. Think of it as looking at the same matrix from 2 opposite points of view._
    
    Looking from an iterator's point of view:
    - When in xaos_TO mode, you will think: *to* wich iterator am I allowed to send the points I just executed?
    - When in xaos_FROM mode, you will think: *from* wich iterator am I allowed to receive points before I execute them myself?
    - Note _that the same concept applies also to the iterator itself, this means the question will be: can I execute a point after I already executed it myself? ( like the yellow iterator with the *Curl* variation in the above diagram/image. )_
    

        
    *How to set xaos in FLAM3H*:
        
    - To set XAOS for a flame with 4 iterators, use the "*xaos:*" keyword followed by each iterator's weight values separated by a colon: *xaos:1:2:3:4*.
    - When the auto space xaos weights option is ON ( it is OFF by default ), the xaos keyword will look like this: "*xaos :*". The important information here is that you always need a colon "*:*" after the word "*xaos*" to make it work.
    - If no set or when using a short descriptive note, FLAM3H will assume all XAOS values are 1.0, the equivalent of: *xaos:1:1:1:1*
    - If you set only iterator 1 and iterator 2, FLAM3H will always fill in the rest with a value of 1.0. *xaos:0:0* will be interpreted as *xaos:0:0:1:1*
    - When turning iterators ON and OFF and removing or adding them, FLAM3H will internally remove and reformat XAOS values to account for missing iterators. It is fully automatic.
    
    *Xaos command options*:
    
    - If you type a non-numeric character in any of the xaos's weights, FLAM3H will undo to what you had before.
    - If you dnt use the "*_xaos_*" keywork at the beginning of the string, the entire xaos string will be reset to all weights with value: *`1`*
    - If you just type a number, the entire xaos string will be reset to all weights set to that number.
    - If you just type a floating point number, the entire xaos string will be reset to all weights set to the integer part of that number. ( _ex: 123.876 will become -> 123_ )
    - If you type a negative number, it will be reset to a value of:  *`1`*

    TIP:
        #display: orange
    
        XAOS is off by default, and FLAM3H will activate it automatically
        only when needed. (ex: when one of its weights is set to a value different from the others, ex: *xaos:3:3:3:2.9* ).
        
    NOTE:
        When saving out flame files, XAOS FROM mode will internally be converted into XAOS TO on save and reloaded as XAOS TO.
        
auto space xaos weights / xaos information tips:
    #id: FLAME
    [Smallicon:opdef:.?iconStarSwapRedOutlineSVG.svg]
    
    Activate/Deactivate auto space xaos weights option.
    
    - ((LMB)) will space the xaos weights for easy read and count ( ON/OFF )
    
    - ((CTRL)) + ((LMB)) to show Xaos information and tips.
    
    You can also click this icon to force xaos to update in case any invalid characters are left by mistake inside the iterator xaos string.

 
:box:
    #display: rounded white

    == Iterator: Shader == (FLAMEITERSHADER)

location:
    #id: FLAME
    The color location in the ramp *{0:1}*.
    
speed:
    #id: FLAME
    Speed of color blending between iterations. Values above 0 attract the selected color while values below 0 will repel it.
    
opacity:
    #id: FLAME
    This iterator's opacity. It will be fully opaque at opacity 1 and completely transparent at opacity 0. It can also be used to adjust the prominence of different portions of your fractal Flame, independent of the iterator's weight.
    
    TIP:
        When an iterator's opacity is *`0.0`* ( *ZERO* ), you can activate the SYS Tab *RIP* option to get rid of those points ( since *opacity* = *`@pscale`* (*`@widths`* in Solaris ) you dnt need them anymore).
:box:
    #display: rounded white

    == Iterator: Variations == (FLAMEITERVARS)
    
    TIP:
        Each iterator allows up to 8 variations ( pre-blur var, 2 Pre vars, 4 Vars plus 1 Post var) to be used.
        
        Variation names that end with an asterisk(*) are dependent, while those that end with three dots(...) are parametric.
        
        When using parametric variations, their parameters in the VAR Tab will be shared between all of them.
        This means that if you use 2 pre Mobius, 4 Mobius and 1 post Mobius, they will all share the same *`re:abcd`* and *`im:abcd`* parameters.
     
pre_blur:
    #id: FLAME
    Enable pre_blur variation.
    
    Pre_blur variation in this implementation is hard-coded inside the chaos game to be as fast as it can possibly be.
    It will always be the first pre-variation the algorithm runs.
    
    TIP:
        When authoring your Flame in Fractorium or Apophysis, if you are planning to load them inside FLAM3H
        remeber that the variation "pre_gaussian_blur" will be remapped to "pre_blur" on Flame load by default.
        
        You can change this beahavior and load the "pre_gaussian_blur" variation instead, if any, inside the IN Tab.
    
pre tab:
    #id: FLAME
    PRE variations for the selected iterator.
    
    The order of the PRE variations matter; for example, if you do Pie first and then Spherical, the outcomes will differ from the other way around.

    
swap pre vars:
    #id: FLAME
    [Smallicon:opdef:.?iconStarSwapOutlineSVG.svg]
    
    ((LMB)) swap the order of the PRE Variations and their weights. 
    
    ((CTRL)) + ((LMB)) swap only the variation names.
    
    
var tab:
    #id: FLAME
    Variations for the selected iterator.
    
    TIP:
        #display: orange
    
        Laying down a new FLAM3H node and activating the Final Flame transform with the default Sierpiński triangle (*FF*) will allow you to experiment with the variations and see what happens.
        Don't forget to play around with the affine coefficients a bit to see what you can obtain.

Post tab:
    #id: FLAME
    POST Variation for the selected iterator.
    
    For speed purpose only one post variation is allowed at the moment.
        
w:
    #id: FLAME
    The weight of the selected variation. Zero will be inactive, and 1 will be 100%.
    Can be set higher than 1 and negative too.
    * If more than one variation is active, remember that, as a general rule, it is suggested ( not mandatory ) to have the sum of all weights equal to 1.
    
    TIP:
        #display: orange
        
        In order to lower the cost of the computation, it is preferable to set a variation weight to zero rather than retaining it at extremely low values if their impact is negligible.
        The variation will be fully disregarded at zero.

:box:
    #display: rounded white

    == Iterator: Affine == (FLAMEITERAFFINE)
    
        
post:
    #id: FLAME
    Enable post affine.
    
pre affine:
    #id: FLAME
    Affine transformation's coefficients for the current iterator ( xform ).
    
    NOTE:
        A linear transformation cannot be used to translate a set of points. 
        
        To translate a set of points, we need to use an *_affine transformation_*. 
        An _affine transformation_ multiplies a vector by a matrix, just as in a linear transformation, 
        and then adds a vector to the result ( the *`O`*._`xy`_ component ). 
        This added *`vector2`* carries out the translation. 
        By applying an _affine transformation_ to an image on the screen, we can do everything a linear transformation can do, 
        and also have the ability to move the image up or down and left or right.

    Each iterator( xform ) has an affine transform that is always applied on every iteration.
    This is known as the pre affine becasue it is applied before the variations.

    - With *`X`*._`xy`_ and *`Y`*._`xy`_ you will apply rotation and scale/shear while with *`O`*._`xy`_ you will apply translation/offset.
    - They compose a 2x3 matrix ( *`X`*._`xy`_, *`Y`*._`xy`_, *`O`*._`xy`_ ).
    - The rotation parameter will take the values of *`X`*._`xy`_, *`Y`*._`xy`_, *`O`*._`xy`_ and rotate them ( *`O`*._`xy`_ being the pivot).
    
    There are two ways you can use the affine:
    # Use *`X`*._`xy`_, *`Y`*._`xy`_, *`O`*._`xy`_ for everything ( translation, rotation and scale/shear ).
    
    # Use the rotation parameter in combination with: *`X`*._`x`_ and *`Y`*._`y`_ for scale, *`X`*._`y`_ and *`Y`*._`x`_ for share and *`O`*._`xy`_ for translation.
    
    NOTE:
        The resulting affine coefficients after the rotation parameter is applied are not updated in the UI but passed directly internally to the algorithm.
        
pre affine reset:
    #id: FLAME
    [Smallicon:opdef:.?iconStarSwapOutlineSVG.svg]
    
    Reset this iterator's pre affine to their default values.
    
    - ((LMB)) to reset all affine values.
    - ((SHIFT)) + ((LMB)) to reset only the affine X and Y values.
    - ((CTRL)) + ((LMB)) to reset only the affine O value.
    - ((ALT)) + ((LMB)) to reset only the affine Rotation angle value.
    
        
        
POST affine:
    #id: FLAME
    Post affine coefficients for the current variations. Those are applied after the variations.
    * See above affine description for more informations.
    
post affine reset:
    #id: FLAME
    [Smallicon:opdef:.?iconStarSwapOutlineSVG.svg]
    
    Reset this iterator's post affine to their default values.
    
    - ((LMB)) to reset all affine values.
    - ((SHIFT)) + ((LMB)) to reset only the affine X and Y values.
    - ((CTRL)) + ((LMB)) to reset only the affine O value.
    - ((ALT)) + ((LMB)) to reset only the affine Rotation angle value.
    
:box:
    #display: rounded white

    == Iterator: Parametric's VARS == (FLAMEITERPRMVARS)

VARS Tab:
    #id: FLAME
    If a parametric variation is selected, its parameters will populate this Tab.
    
    



:box:
    #display: rounded white

== FF: finalXform parameters == (FF)
    
~~~
:box:
    #display: inverted teal

    *FF:* _Final Flame transform._
    
    Iterators like Final Flame (FF) or finalXform function like camera lenses.
    It allows for a great deal of creative experimentation by taking the combined result of all the iterators inside the FLAME Tab and applying further modifications to that result.


:box:
    #display: rounded white

    == FF == (FFMAIN)
        
FF: note:
    #id: FF
    A name for this FF iterator.
    
    NOTE:
        The text you write here will be stored with the flame file and will also appear inside Apophysis and Fractorium as the name of the finalxform iterator.
    
FF: copy/paste:
    #id: FF
    [Smallicon:opdef:.?iconStarSwapRedSVG.svg]

    All the necessary methods for copy/paste FF's data are contained in this icon. This icon allows you to mark a FLAM3H node's FF for being copied, and then copy the data from the marked FF into a separate FLAM3H node.
    Once the FF has been marked, you can use the mini menu next to the icon to copy individual sections from the marked FF.
    
    When you mark an FF, you establish a live connection with it and the data will be copied from it only when you ((CTRL)) + ((LMB)) from inside another FLAM3H node' FF.
    This way you can keep the FF marked while working and paste again its data somewhere else after making additional changes to its contents.

    Below are the different options on how you can use this icon:
    
    - ((LMB)) to mark this FF for being copied. If already marked, it will unmark it.
    - ((CTRL)) + ((LMB)) to copy the values from the marked FLAM3H node's FF into this FLAM3H node's FF.
    - ((SHIFT)) + ((LMB)) to unmark this FF for being copied.
    
    
:box:
    #display: rounded white

    == FF: Variations == (FFVARS)
    
    TIP:
        FF iterator allow up to 5 variations ( 1 Pre var, 2 Vars plus 2 Post vars ) to be used.
        
        Variation's name that end with an asterisk(*) are dependent while if they end with 3 dots(...) are parametric.
    
FF pre tab:
    #id: FF
    PRE variation for the FF iterator.
    
    This is applyed before the variations. It is the very first transformation when used.
    * When using a parametric variation, its parameters will populate the *FF: PP VARS* Tab.
    
    
FF var tab:
    #id: FF
    Variations for the FF iterator.
    
    * When using parametric variations, their parameters will populate the *FF: VARS* Tab.

FF Post tab:
    #id: FF
    POST Variations for the FF iterator.
    
    These are applyed after the variations. They are the very last transformation.
    * When using parametric variations, their parameters will populate the *FF: PP VARS* Tab.
    
    The order of the POST variations matter; for example, if you do Pie first and then Spherical, the outcomes will differ from the other way around.
    

swap FF Post vars:
    #id: FLAME
    [Smallicon:opdef:.?iconStarSwapOutlineSVG.svg]
    
    ((LMB)) swap the order of the POST Variations and their weights. 
    
    ((CTRL)) + ((LMB)) swap only the variation names.

    
FF: w:
    #id: FF
    The weight of the selected variation. ZERO will be inactive, 1 will be 100%.
    Can be set higher than 1 and negative too.
    
    TIP:
        #display: orange
        In order to lower the cost of the computation, it is preferable to set a variation weight to zero rather than retaining it at extremely low values if their impact is negligible.
        The variation will be fully disregarded at zero.


    
:box:
    #display: rounded white

    == FF: Affine == (FFAFFINE)
        
FF: post:
    #id: FF
    Enable post affine.
    
FF: pre affine:
    #id: FF
    Affine coefficients for the current FF iterator ( FF - finalxform ). Those are applied before the variations.

    - *See the above iterator's affine description for more information*.
    
FF pre affine reset:
    #id: FF
    [Smallicon:opdef:.?iconStarSwapOutlineSVG.svg]
    
    Reset the FF pre affine to their default values.
    
    - ((LMB)) to reset all affine values.
    - ((SHIFT)) + ((LMB)) to reset only the affine X and Y values.
    - ((CTRL)) + ((LMB)) to reset only the affine O value.
    - ((ALT)) + ((LMB)) to reset only the affine Rotation angle value.
    
FF: POST affine:
    #id: FF
    Post affine coefficients for the current variations. Those are applied after the variations.
    
    - *See the above iterator's affine description for more information*.
    
FF post affine reset:
    #id: FF
    [Smallicon:opdef:.?iconStarSwapOutlineSVG.svg]
    
    Reset the FF post affine to their default values.
    
    - ((LMB)) to reset all affine values.
    - ((SHIFT)) + ((LMB)) to reset only the affine X and Y values.
    - ((CTRL)) + ((LMB)) to reset only the affine O value.
    - ((ALT)) + ((LMB)) to reset only the affine Rotation angle value.
        
:box:
    #display: rounded white

    == FF: Parametric's VARS == (FFPRMVARS)
    
FF: VARS Tab:
    #id: FF
    If a parametric variation is selected, its parameters will populate this Tab.
    
FF: PP VARS Tab:
    #id: FF
    If a *PRE* or *POST* parametric variation is selected, its parameters will populate this Tab.
    




:box:
    #display: rounded white

== CP: Color palette parameters == (CP)
    
~~~
:box:
    #display: inverted teal

    *CP:* _Flame fractal color palette._
    
    The palette colors used in a successful fractal Flame are crucial.
    In addition to playing with the shader parameters for each iterator, fractal Flames can be transformed into something truly unique by trying out various color schemes.
   
:box:
    #display: rounded white
    
    == CP: Palette ramps == (CPRAMPS)
    
HSV:
    #id: PALETTE
    
    Hue/Saturation/Value of the palette's colors.
    
    HSV values are exported into the XML on Flame save when used.
    
HSV reset:
    #id: PALETTE
    [Smallicon:opdef:.?iconStarSwapSVG.svg]
    
    Reset the HSV to their default values.
    
palette:
    #id: PALETTE
    the actual color palette.
    
palette reset:
    #id: PALETTE
    [Smallicon:opdef:.?iconStarSwapSVG.svg]
    
    Reset the palette to its default values.
    
:box:
    #display: rounded white
    
    == CP: Load/Save file == (CPLOAD)
    
JSON file:
    #id: PALETTE
    
    Load an already-created json palette library file or select the name of a new one to create.
    
    TIP:
        Once you are happy with a palette library you built, you can rename the file to start with: "*F3H_LOCK*"
        to prevent any further modifications to it. For example, if you have a lib file called "*my_rainbows_colors.json*"
        you can rename it to: "*F3H_LOCK_my_rainbows_colors.json*" to keep it safe.
    
:box:
    #display: rounded white
    
    == CP: Save == (CPSAVE)
        
Save Palette:
    #id: PALETTE
    
    [Smallicon:opdef:.?iconWhiteStarSVG.svg]
    
    ((LMB)) to save the current palette into the selected OUT file.
    
    - If the selected file does not exist, it will be created.
    - If the selected file already contains some palettes, it will append the current one.
    - ((CTRL)) + ((LMB)) to erase the content of the file and overwrite it with only the current palette.
    - ((SHIFT)) + ((LMB)) will open the file explorer to the file location.

    _If the selected file is not a valid Palette JSON file type, nothing will happen._
    
    TIP:
        *Once you click save*:
        
        - If you select a location and a filename without an extension, it will automatically add the _*.json*_ extension to them.
        - If you do not provide a file name at all, it will generate one for you based on today's date and current time, assuming you have a valid location selected.
        - If nothing is selected (ex: JSON file empty or invalid ), nothing will happen.
        
    NOTE:
        - When saving out a palette file, it will try to downsample the usual 256 color count standard.
        - However, when saving out flames files, it will always sample the palette as a 256-color palette standard.
    
Palette name ( preset ):
    #id: PALETTE
    Write a name to give to the selected palette when saving it.
    If no name is provided, an automated name composed of today's date and current time will be used instead.
    
:box:
    #display: rounded white
    
    == CP: Presets == (CPPRESETS)
        
LIB contents ( presets ):
    #id: PALETTE
    When you load a json palette file, use this menu to display all the palettes included in the loaded file and select one to load.
    
Reload preset ( presets ):
    #id: PALETTE
    [Smallicon:opdef:.?iconPrideSVG.svg]
    
    Reload the selected palette preset.
    
:box:
    #display: rounded white

    == CP: Options == (CPOPTIONS)
    
save palette HSV:
    #id: PALETTE
    OFF by default. When saving out a palette, use the non-color-corrected ramp and save the HSV values along with it if used ( different from default values ).Check this option to save the the color-corrected HSV ramp instead. This option will clamp the palette colors on save to 0-255 and you should use this only when you want to export the desired colors to be loaded inside Fratorium or Apophysis or other fractal flame editors out there.
    
    



:box:
    #display: rounded white

== MB: Motion Blur parameters == (MB)
    
~~~
:box:
    #display: inverted teal

    *MB:* _Flame fractal moton blur._
    
    When animating your fractal flame, turning this on will compute a proper temporal motion blur.
    

:box:
    #display: rounded white

    == MB == (MBPRM)

on:
    #id: MB
    Enable motion blur.
    
    Motion blur values are exported into the XML on Flame save when turned on.
    
    TIP:
        #display: orange
        
        If you animate any of the available parameters using expressions,
        remember to always use *`@Time`* and not *`$F`* so the tool will be able to interpolate through time properly.

:box:
    #display: rounded white

    == MB: Settings == (MBSETTINGS)

fps:
    #id: MB
    desired Frames per second.
    
samples:
    #id: MB
    Motion blur samples.
    
shutter offset:
    #id: MB
    Shutter time.

:box:
    #display: rounded white

    == MB: Viz == (MBVIZ)
    
viz mb:
    #id: MB
    Visualize motion blur using color. (Set the viewport background to black for better viewing )
    
    NOTE:
        When rendering, keep in mind to turn this off to avoid superimposing a darker color.
        




:box:
    #display: rounded white

== IN: input parameters == (IN)
            
~~~
:box:
    #display: inverted teal

    *IN: Load* _*.flame file created with Apophysis, Fractorium and others._
    
    A *.flame file is an XML-formatted type of file.


:box:
    #display: rounded white

    == IN == (INF)

IN file ( *.flame type ):
    #id: IN
    
    Load *.flame files authored with Apophysis, Fractorium and other flam3-compatible applications.
    
    The only restrictions are:
    
    - The flames contained in the file must use the same variations included inside FLAM3H. 
    - A maximum of 4 VARS plus PRE_BLUR plus 2 PRE and 1 POST variations for each iterator are allowed. 
    ( for a total of 8 vars per iterator ). If it finds more on load, it will just discard the extra one.
    - For FF ( FinalXForm ) you have 1 PRE, 2 VARS plus 2 POST available. If it finds more on load, it will just discard the extra one.
    
    NOTE:
        FLAM3H does not deal with any image color correction curves that are present inside Fractorium for example.
        Every time you load a Flame authored with Fractorium, those curves' values will be discarded and internally reset to their default values. ( no color correction at all )
    
Reload:
    #id: IN
    [Smallicon:opdef:.?iconWhiteSVG.svg]
    
    - ((LMB)) If there is a selected IN preset, it will reload it.
    - ((ALT)) + ((LMB)) to paste a flame from the clipboard.

    When loading a flame preset from the clipboard, its render properties will be automatically copied into the OUT render propperties on load.
    
    TIP:
        - Loading a flame from the clipboard is useful when going back and forth with a third-part application like for example: Fractorium.
        - In Fractorium, you can alter the flame, copy it into the clipboard, and then load it from the clipboard inside FLAM3H to see the changes.
    
Presets:
    #id: IN
    Every *.flame file can contain multiple flames.
    As many entries as there are flames in the file you are loading will be added to this preset menu.
    Each entry will display the flame's name.
    
Iterations on Load (int):
    #id: IN
    Set a number of iterations to use every time you load a flame from a *.flame file.
    This will override the internal default value of 64 iterations.
    
    TIP:
        If "*auto add iter num to Flame name*" OUT Tab option is *OFF*:
    
        The iteration number you want your fractal flame to use when you load it back into FLAM3H can be baked into the preset name you choose for it.
        For instance, the Flame preset "*My_Awesome_GrandJulia*" will be loaded with 64 iterations by default.
        However, all settings will be overridden if you add the iteration number to the preset name after a double colon, as in "*My_Awesome_GrandJulia::16*".
        and load it with an iteration count of 16.
        
        Therefore, do some tests before saving it, and choose the ideal iteration number to incorporate into the preset name.
        
        If you like, you can manually edit the created XML/Flame file and change the *flame-> "name"* key afterwards.
    
Force iterations on Load:
    #id: IN
    When *.flame files are loaded, FLAM3H immediately sets the iteration number to 64, which seems like a reasonable count to resolve the majority of them rather effectively.
    However, if you need to act quickly, you can use this number to override the iterations set on load.
    
:box:
    #display: rounded white

    == IN: load options == (INOPTIONS)
    
remap "pre_gaussian_blur":
    #id: prefs
    On Flame load, the "pre_gaussian_blur" variation will be remapped to the "pre_blur" variation.
    
    ON by default since the chaos game in this implementation has the "pre_blur" variation hard coded to be as quick as possible.
    
    If you'd rather want to use "pre_gaussian_blur" and have it behave as a pre variation (not cumulative/additive), turn it OFF.
    
    NOTE:
        *You need to reload the current Flame preset for this change to take place*.
        
        
Reload preset with remap "pre_gaussian_blur" changes:
    #id: prefs
    [Smallicon:opdef:.?iconStarSwapOutlineSVG.svg]
    
    - ((LMB)) will switch ON/OFF this toggle and reload the currenlty selected IN preset right after using the new settings.
    - ((ALT)) + ((LMB)) to preform the same operation as above but loading a flame from the Clipboard instead.

    
Copy render properties on Load:
    #id: IN
    [Smallicon:opdef:.?iconStarSwapSVG.svg]
    
    OFF by default. If on, it will automatically copy the render properties into the OUT render properties every time you load a Flame preset.
    
    NOTE:
        *You need to reload the current Flame preset for this change to take place*.
        
Reload preset with "Copy render properties on Load" changes:
    #id: prefs
    [Smallicon:opdef:.?iconStarSwapSVG.svg]
    
    Clicking this icon will switch ON/OFF this toggle and reload the currenlty selected IN preset right after using the new settings.

    
:box:
    #display: rounded white

    == IN: Preset infos == (INPRESETINFOS)
    
infos Tab:
    #id: IN
    Display information about the loaded Flame preset.
    
:box:
    #display: rounded white

    == IN: Preset render properties == (INPRESETRND)
    
Render infos:
    #id: IN
    Give details on the render settings for the loaded Flame preset.
    These characteristics are unique to the renderer of the program from which the loaded Flame was created or saved.
    Some of the characteristics are unique to the Fractorium application, which has served as my point of reference.
    
Copy/Paste render properties:
    #id: IN
    [Smallicon:opdef:.?iconStarSwapRedSVG.svg]
    
    When you click this icon, those render properties will be copied and pasted into the render properties of the OUT tab.
    When you save it out and load it back into, say, Fractorium, you can be sure that your Flame will match the visual parameters of the Flame you just loaded.

    When loading a flame preset from the clipboard, its render properties will be automatically copied into the OUT render propperties on load and this icon will become disabled.
    
    NOTE:
        Any image color correcting curves, such as those found in Fractorium, are not handled by FLAM3H. These curves will be overwritten with their default values each time you save a flame from FLAM3H. (no color correction)

        This means that if you save a Flame out again from FLAM3H after loading a Flame created with Fractorium that makes use of its color correcting curves, those curves will be lost.
        

    


:box:
    #display: rounded white

== OUT: output parameters == (OUT)
    
~~~
:box:
    #display: inverted teal

    *OUT: Save* _*.flame file type to be loaded back inside Apophysis, Fractorium and others._
 
    Inside here, you can export your fractal flame into an XML format. ( standard *.flame file format )
    and reload it inside FLAM3H or inside Apophysis, Fractorium and others.
    
    The flame file format does not support animations, but only static frames, so to speak.
    If you animated your fractal flame, save the hip file from Houdini instead.
    

_The following is an example of what the Sierpinski triangle preset looks like once saved :_
    
{{{
#!xml
<flames>
  <flame version="FLAM3H-WIN-1.1.58" name="Sierpiński triangle" flam3h_rip="0" flam3h_f3c="1" size="1024 1024" center="0 0" scale="400" rotate="0" background="0 0 0" supersample="2" filter="0.5" quality="1000" brightness="3" gamma="2.5" gamma_threshold="0.0423093658828749" logscale_k2="0" vibrancy="0.333333" highlight_power="1" estimator_radius="9" estimator_minimum="0" estimator_curve="0.4" palette_mode="linear" interpolation="linear" interpolation_type="log" plugins="linear" new_linear="1">
    <xform name="iterator_1" weight="0.5" color="0" symmetry="-0.5" coefs="0.5 0 0 0.5 0 0.51225" opacity="1" linear="1"/>
    <xform name="iterator_2" weight="0.5" color="0.5" symmetry="-0.5" coefs="0.5 0 0 0.5 -0.29575 0" opacity="1" linear="1"/>
    <xform name="iterator_3" weight="0.5" color="1" symmetry="-0.5" coefs="0.5 0 0 0.5 0.29575 0" opacity="1" linear="1"/>
    <palette count="256" format="RGB">
      FF0000FD0200FB0400F90600F70800F50A00F30C00F10E00
      EF1000ED1200EB1400E91600E71800E51A00E31C00E11E00
      DF2000DD2200DB2400D92600D72800D52A00D32C00D12E00
      CF3000CD3200CB3400C93600C73800C53A00C33C00C13E00
      BF4000BD4200BB4400B94600B74800B54A00B34C00B14E00
      AF5000AD5200AB5400A95600A75800A55A00A35C00A15E00
      9F60009D62009B6400996600976800956A00936C00916E00
      8F70008D72008B7400897600877800857A00837C00817E00
      7F80007D82007B8400798600778800758A00738C00718E00
      6F90006D92006B9400699600679800659A00639C00619E00
      5FA0005DA2005BA40059A60057A80055AA0053AC0051AE00
      4FB0004DB2004BB40049B60047B80045BA0043BC0041BE00
      3FC0003DC2003BC40039C60037C80035CA0033CC0031CE00
      2FD0002DD2002BD40029D60027D80025DA0023DC0021DE00
      1FE0001DE2001BE40019E60017E80015EA0013EC0011EE00
      0FF0000DF2000BF40009F60007F80005FA0003FC0001FE00
      00FE0100FC0300FA0500F80700F60900F40B00F20D00F00F
      00EE1100EC1300EA1500E81700E61900E41B00E21D00E01F
      00DE2100DC2300DA2500D82700D62900D42B00D22D00D02F
      00CE3100CC3300CA3500C83700C63900C43B00C23D00C03F
      00BE4100BC4300BA4500B84700B64900B44B00B24D00B04F
      00AE5100AC5300AA5500A85700A65900A45B00A25D00A05F
      009E61009C63009A6500986700966900946B00926D00906F
      008E71008C73008A7500887700867900847B00827D00807F
      007E81007C83007A8500788700768900748B00728D00708F
      006E91006C93006A9500689700669900649B00629D00609F
      005EA1005CA3005AA50058A70056A90054AB0052AD0050AF
      004EB1004CB3004AB50048B70046B90044BB0042BD0040BF
      003EC1003CC3003AC50038C70036C90034CB0032CD0030CF
      002ED1002CD3002AD50028D70026D90024DB0022DD0020DF
      001EE1001CE3001AE50018E70016E90014EB0012ED0010EF
      000EF1000CF3000AF50008F70006F90004FB0002FD0000FF
    </palette>
  </flame>
</flames>
}}}

    
TIP:
    FLAM3H allows you to save your flames in the standard *.flame file format 
    so that you can load them back inside any other applications like Fractorium, Apophysis and others.
    
    You must abide by some rules imposed by the original Flame file format.
    
    Not using multiple instances of the same variation in any of the accessible sections (PRE, VAR, or POST) is the most crucial thing to keep in mind.
    
    For instance, you cannot utilize two Mobius variations inside an iterator's PRE or VAR sections.
    But you can use 1 Mobius in the PRE vars, 1 Mobius in the VAR, and 1 Mobius in the POST.
    
    FLAM3H, by design, will allow you to be more flexible with your Flame construction choises and allow
    you to bend this rule, enabling the use of the same variation multiple times within the same section ( _Chaotica style_ ), but you won't be able to save out
    the result in the standard flame file format. *Save the hip file instead in those cases*.

:box:
    #display: rounded white

    == OUT == (OUTF)
    
OUT file ( *.flame type ):
    #id: OUT
    
    Select a file name to save your Flame into.
    If the selected file does not exist, it will be created.
    
    TIP:
        When you have finished creating a FLAM3H library, you can rename the file to begin with "*F3H_LOCK*" to prevent any future alterations.
        You can rename a lib file, for instance, called "*my_grandJulia.flame*" to "*F3H_LOCK_my_grandJulia.flame*" to keep it secure.
        
    
Save Flame:
    #id: OUT
    [Smallicon:opdef:.?iconWhiteStarSVG.svg]
    
    - ((LMB)) to save this flame inside the selected OUT file, if any. If the selected file exists and already contains some Flames in it, it will append the current one.
    - ((CTRL)) + ((LMB)) to erase the content of the file and overwrite it with only this Flame.
    - ((SHIFT)) + ((LMB)) will open the file explorer to the file location.
    - ((ALT)) + ((LMB)) to copy this flame into the clipboard.

    - If the selected file does not exist, it will be created.
    - If the selected file is not a valid Flame file type, nothing will happen.
    
    TIP:
        *Once you click save*:
        
        - If you select a location and a filename without an extension, it will automatically add the _*.flame*_ extension to them.
        - If you do not provide a file name at all, it will generate one for you based on today's date and current time, assuming you have a valid location selected.
        - If nothing is selected (ex: OUT file empty or invalid ), nothing will happen.
        
    NOTE:
        Keep in mind that you can only utilize a variation once in each of the available variations' sections. 
        While this is doable within the tool, it is not compatible with the FLAM3 file format as it requires that a variation be used only once per type ( PRE, VAR, POST )
        or you won't be able to save the same result.
        Save the hip file instead.
        
        This is true also for applications like Apophysis and Fractorium as they obey the same rule.
    
Flame name ( preset ):
    #id: OUT
    Write a name to give to the selected flame when saving it out.
    If no name is provided, an automated name composed of today's date and current time will be used instead.
    
    TIP:
        If "*auto add iter num to Flame name*" is *OFF*:
    
        The iteration number you want your fractal flame to use when you load it back into FLAM3H can be baked into the preset name you choose for it.
        For instance, the Flame preset "*My_Awesome_GrandJulia*" will be loaded with 64 iterations by default.
        However, if the iteration number is added to the preset name after a double colon, as in "*My_Awesome_GrandJulia::16*," it will override all settings and load the preset with 16 as the iteration numbers.
        
        Therefore, do some tests before saving it, and choose the ideal iteration number to incorporate into the preset name.
        
        If you like, you can manually edit the created XML/Flame file and change the *flame-> "name"* key afterwards.
    
Flame name tip:
    #id: OUT
    [Smallicon:opdef:.?iconStarSwapBluSVG.svg]
    
    Show Flame name's informations and tips.
    
OUT file contents ( info ):
    #id: OUT
    This menu is simply provided as information.
    If there are any Flames in the chosen output file, they will be displayed.
    This menu will refresh once you add a new Flame to it.
    It will always be set to the last Flame’s name you saved.
    
:box:
    #display: rounded white

    == OUT: save options == (OUTOPTIONS)
        
Save palette HSV (cc):
    #id: OUT
    OFF by default, as FLAM3H will save the HSV values into the XML file and set those once you load it back.
    If enabled, all color adjustments you may have made to the flame's palette will be preserved using the HSV ramp instead.
    This is helpful if you want to maintain the color-corrected palette when you load the saved Flame into a different program, such as Fractorium or Apophysis.
    
Auto add iter num to Flame name:
    #id: OUT
    ON by default. It will automatically append the iteration number to the flame name you enter.
    It will also autocorrect the flame name string based on internally defined rules.
    
    TIP:
        When on, and once you type in a flame name, changing the iteration number will update the flame name too.
        
use Fractorium parametric prm names:
    #id: OUT

    OFF by default. To export the parameter names for parametric variations to the one that Fractorium uses, check this toggle ON when saving out a flame.

    *_This is only useful if you use Mobius or Oscilloscope ( oscope ) parametric variations and want to load the flame inside Fractorium as it uses diferent paramtric paramter's names for these_*.

    :disclosure:Technical note
    
        When saving a flame out with this option on, the xml appliction key will change from:
        
        {{{
        #!xml
        <flames>
          <flame version="FLAM3H-WIN-1.1.58" ... >
              ...
        }}}
        
        to:
        
        {{{
        #!xml
        <flames>
          <flame version="EMBER-FLAM3H-WIN-1.1.58" ... >
              ...
        }}}
        
        Note the " _EMBER_ " prefix added to the FLAM3H version name.
        
        This way once we load it back FLAM3H will remap those parameteric variations parameter's names to the proper one.

:box:
    #display: rounded white

    == OUT Edit: Render properties == (OUTEDIT)

    
Edit render properties:
    #id: OUT
    Allow the editing of the render properties for the host application you will load the saved Flame file into.
    Fractorium is the suggested one, followed by Apophysis.
    
    Those properties are specific to the renderer of the application you will load the saved flame into.
    Some of the properties are specific to Fractorium applications, which has been my point of reference.
    
    They will control how the saved fractal flame will render inside other applications like Fractorium and Apophysis.
    They are their renderer settings, and they will be exported into the XML file.

    
    NOTE:
        Any image color correcting curves, such as those found in Fractorium, are not handled by FLAM3H.
        These curves will be overwritten with their default values each time you save a flame from FLAM3H. (no color correction)
        
        This means that if you save a Flame out again from FLAM3H after loading a Flame created with Fractorium that makes use of its color correcting curves, those curves will be lost.
        
    
Reset render properties:
    #id: OUT
    [Smallicon:opdef:.?iconStarSwapOutlineSVG.svg]
    
    - ((LMB)) to reset all OUT render properties.
    - ((CTRL)) + ((LMB)) to reset only the OUT Camera sensor properties.
    - ((SHIFT)) + ((LMB)) to reset only the OUT Render settings properties.
    
    
:box:
    #display: rounded white

    == OUT Edit: Camera sensor == (OUTEDITCAMSENSOR)
    
SHOW sensor viz:
    #id: OUT
    [Smallicon:opdef:.?icon_TagORedSVG.svg]
    
    Activate FLAM3H Camera sensor visualization.
    
    All the render settings required by third-party programs such as Apophysis and Fractorium are stored together with the fractal flames when they are saved from FLAM3H.
    A portion of the render parameters deal with the camera and how the fractal flame you just saved is framed.
    The FLAM3H camera sensor will precisely display the image framing.

    _This is meant to be used only when you intend to load the saved fractal flame into third-party programs and you desire to setup the fractal flame image framing in Houdini first. Below a screenshot as an example:_

    _*[FLAM3H to Apophysis, camera sensor framing|https://github-production-user-asset-6210df.s3.amazonaws.com/42110232/281850238-27f1d534-f6a7-4519-990d-373f3290cc5b.jpg]*_

    When multiple FLAM3H node are present in the scene, FLAM3H ensures that, upon entering the Camera Sensor viz mode, there will only ever be one active Camera Sensor viz mode at any given time. This keeps the current viewport from jumping when concurrently stashed viewports are restored and saved at the same time.
    
    TIP:
        When in OUT Camera sensor mode, the SYS tab Tag icon will turn red to allow to exit the mode also when inside a different tab other than the OUT tab.
    
Resolution:
    #id: OUT
    The image resolution.
    
    
Resolution presets menu:
    #id: OUT
    Select a resolution out of some pre made presets.
    
    
Copy/Paste render properties:
    #id: IN
    [Smallicon:opdef:.?iconStarSwapRedSVG.svg]
    
    When you load a flame file in the IN tab, this icon will become available.
    
    When you click this icon, the currently loaded IN flame preset render properties will be copied and pasted here.
    When you save it out and load it back into, say, Fractorium, you can be sure that your Flame will match the visual parameters of the Flame you just loaded.

    The render properties of a flame preset loaded from the clipboard will be automatically copied into the OUT render properties on load, disabling this icon.
    
    NOTE:
        Any image color correcting curves, such as those found in Fractorium, are not handled by FLAM3H. These curves will be overwritten with their default values each time you save a flame from FLAM3H. (no color correction)

        This means that if you save a Flame out again from FLAM3H after loading a Flame created with Fractorium that makes use of its color correcting curves, those curves will be lost.
    
Center:
    #id: OUT
    Where the flame is centered, think of this as the look at camera point.
    
Rotate:
    #id: OUT
    The camera rotation.
    
Scale:
    #id: OUT
    Size of the lens. Because the quality won't be raised once loaded into third-party programs such as Fractorium or Apophysis, you will need to manually alter it from within the host program, making this XML key an affordable way to achieve zoom.
    
update sensor:
    #id: OUT
    ON by default. Every change to the sensor parameters will update the sensor viewport viz. Turn this OFF to disable any sensor viewport's updates.
    
    
:box:
    #display: rounded white

    == OUT Edit: Render settings == (OUTEDITRENSETTINGS)
    
    
Quality:
    #id: OUT
    The render quality. Think of this as how many points are used inside Fractorium to render the final image. The cleaner the final image.
    
Brightness:
    #id: OUT
    The flame render setting: brightness.
    
Gamma:
    #id: OUT
    The flame render setting: gamma.
    
Highlight power:
    #id: OUT
    The flame render setting: highlight power.
    
Logscale K2:
    #id: OUT
    The flame render setting: Logscale K2.
    
Vibrancy:
    #id: OUT
    The flame render setting: vibrancy.
        
    
    



:box:
    #display: rounded white

== Preferences == (PREFS)
    
~~~
:box:
    #display: inverted teal

    *prefs:* _Tool's preferences._

display prefs:
    #id: prefs
    Display preferences.
    
:box:
    #display: round white
    
    == Prefs: General == (PREFSGENERAL)
    
flam3 compatibility (f3c):
    #id: prefs
    The behavior of the *cos, cosh, cot, coth, csc, csch, sec, sech, sin, sinh, tan* and *tanh* variations are different in flam3/Apophysis versus Chaotica.
    * *Checked*: use the Apophysis behavior.
    * *Unchecked*: use the Chaotica behavior.
    
    TIP:
        In Fractorium you can go to "Options" to find the exact same checkbox.
        
Auto correct output paths:
    #id: prefs
    ON by default. This is a simple autocorrection of the output file paths for the CP and OUT Tabs.
    
cvex precision modes:
    #id: prefs
    Switch between the default Single Precision ( 32-bit ) or Double Precision ( 64-bit ).
    
    NOTE:
        Double accuracy in 64 bits will be incredibly slow. I'll say it again: "Really slowly."
        Unless you see some significant artifacts and you genuinely adore the fractal flame you are working on, always use 32-bit.
    
:box:
    #display: rounded white

    == Prefs: Xaos == (PREFSXAOS)
        
xaos modes:
    #id: prefs
    Select to use xaos in either *xaos TO* or *xaos FROM* mode.
    
    - Switching between xaos modes will convert and reset the xaos: string values inside each iterator so that you can see how the new weights adjusted to fit the new mode.
    
    NOTE:
        XAOS FROM mode will internally be changed into XAOS TO on save and reloaded as XAOS TO when saving out Flame files.


:box:
    #display: rounded white

    == Prefs: Camera == (PREFSCAM)
            
handle:
    #id: prefs
    Display the viewport camera handle to help frame/center your fractal flame.
    On the left, you will have the FLAM3H node name, and on the right, the selected camera name.
    
    :warning:
        *TURN THIS OFF WHEN RENDERING.*

    
camera cull:
    #id: prefs
    Enable culling based on camera view.
    
cam:
    #id: prefs
    Pick a camera to use for either the handle or the culling.
    
amount:
    #id: prefs
    Culling amount.
    
:box:
    #display: rounded white

    == Prefs: Viewport == (PREFSVIEW)
    
dark:
    #id: prefs
    If it isn't already, change the viewport's color scheme to dark.
    If unchecked, it will remember the color scheme for every viewport and fall back on it.
    Checking this box has no effect if the color scheme in a viewport is already dark.
    
type:
    #id: prefs
    Set the viewport particle display mode to either points or pixels.
    
size:
    #id: prefs
    When viewport particle display is set to Points, this will control their size in the viewport.
        
    
    
:box:
    #display: rounded white

== About == (ABOUT)

~~~
:box:
    #display: inverted teal

    *About.* _Here you will find information about FLAM3H._

About:
    #id: about
    Display informations about FLAM3H. Author, code languages used, version number, code references and much more can be found inside here.

Plugins:
    #id: about
    List of plugins/variations shipped with FLAM3H.
    
Web links:
    #id: about
    A list of useful web links to check out.
    
    
    [Smallicon:opdef:.?FLAM3H_DOC_icon.svg] 
    
    Open a web browser to the FLAM3H website.
    
     
    [Smallicon:opdef:.?iconGithubBlackSVG.svg] 
    
    Open a web browser to the FLAM3H github repository.
     
     
    [Smallicon:opdef:.?iconInstagramSVG.svg] 
    
    Open a web browser to the FLAM3H instagram account. 
     
     
    [Smallicon:opdef:.?iconWhiteSVG.svg] 
    
    Open a web browser to the original "The Fractal Flame Algorithm" (FLAM3) publication's PDF. 
     
     
    [Smallicon:opdef:.?iconGithubWhiteSVG.svg] 
    
    Open a web browser to the original "The Fractal Flame Algorithm" (FLAM3) github repository. 
    
    
    



    
:box:
    #display: rounded white

@variations Variations infos

:box:
    #display: inverted seafoam

    *Variations information.* _Here you will find information about the available variations/plugins currently implemented._




:box:
    #display: rounded white
    
    == Variations: Full list == (VARDLIST)

_A list of all variations included with FLAM3H:_

- _Note that all the following are also available as PRE_ _and/or POST_ _variations._

:box:
    #display: rounded gray
    
    *Arch*, 
    *Auger*, 
    *Bent*, 
    *Bent2*, 
    *Bipolar*, 
    *Blade*, 
    *Blob*, 
    *Blur*, 
    *Boarders*, 
    *Bubble*, 
    *Butterfly*, 
    *Bwraps*, 
    *Cell*, 
    *Conic*, 
    *Cos*, 
    *Cosh*, 
    *Cosine*, 
    *Cot*, 
    *Coth*, 
    *Cpow*, 
    *Crop*, 
    *Cross*, 
    *Csc*, 
    *Csch*, 
    *Curl*, 
    *Curve*, 
    *Cylinder*, 
    *Diamond*, 
    *Disc*, 
    *Disc2*, 
    *Edisc*, 
    *Elliptic*, 
    *Escher*, 
    *Ex*, 
    *Exp*, 
    *Exponential*, 
    *Eyefish*, 
    *Fan*, 
    *Fan2*, 
    *Fisheye*, 
    *Flower*, 
    *Flux*, 
    *Foci*, 
    *Gaussian_blur*, 
    *Glynnia*, 
    *Handkerchief*, 
    *Heart*, 
    *Hemisphere*, 
    *Horseshoe*, 
    *Hyperbolic*, 
    *Julia*, 
    *JuliaN*, 
    *Juliascope*, 
    *Lazysusan*, 
    *Linear*, 
    *Log*, 
    *Loonie*, 
    *Mobius*, 
    *Modulus*, 
    *Ngon*, 
    *Noise*, 
    *Oscope*, 
    *Parabola*, 
    *Pdj*, 
    *Perspective*, 
    *Pie*, 
    *Point_symmetry*, 
    *Polar*, 
    *Polar2*, 
    *Polynomial*, 
    *Popcorn*, 
    *Popcorn2*, 
    *Power*, 
    *Pre_blur*, 
    *Radialblur*, 
    *Rays*, 
    *Rectangles*, 
    *Rings*, 
    *Rings2*, 
    *Scry*, 
    *Sec*, 
    *Secant2*, 
    *Sech*, 
    *Separation*, 
    *Sin*, 
    *Sinh*, 
    *Sinusoidal*, 
    *Spherical*, 
    *Spiral*, 
    *Split*, 
    *Splits*, 
    *Square*, 
    *Stripes*, 
    *Supershape*, 
    *Swirl*, 
    *Tan*, 
    *Tangent*, 
    *Tanh*, 
    *Twintrian*, 
    *Unpolar*, 
    *Waves*, 
    *Waves2*, 
    *Wedge*, 
    *Wedgejulia*, 
    *Wedgesph*, 
    *Whorl*




:box:
    #display: rounded white
    
    == Variations: Dependent == (VARDEPENDENT)

    
_Dependent variation's affine coefficients:_

:box:
    #display: rounded gray
    
    A dependent variation behaves similarly to a parametric variation, but uses some of the affine coefficients to determine its behavior rather than additional parameters.
    The dependent variations and the affine coefficients they employ are listed below:
    
    *_Waves_*: `O[0] X[1]   Y[1] O[1]`
    
    *_Popcorn_*: `O[0]  O[1]`
    
    *_Rings_*: `O[0]`
    
    *_Fan_*: `O[0]`



:box:
    #display: rounded white
    
    == Variations: Parametrics == (VARDLIST)

_A list of all parametric variations and their parametric parameter's names._

NOTE:
    Repeated variations names indicate distinct Houdini parameters.
    For example Mobius variation has two: *Re ABCD* and *Im ABCD*. They are two distinct *`vector4`* parameters.

:box:
    #display: rounded gray
    
    - *Auger*           ->      _Frequency, Scale, Symmetry, Weight_
    
    - *Bent2*           ->      _X, Y_
    
    - *Bipolar*         ->      _Shift_
    
    - *Blob*            ->      _Low, High, Waves_
    
    - *Bwraps*          ->      _Size, Space, Gain_
    
    - *Bwraps*          ->      _In twist, Out twist_
    
    - *Cell*            ->      _Size_
    
    - *Conic*           ->      _Eccentricity, Holes_
    
    - *Cpow*            ->      _Pow, r, i_
    
    - *Crop*            ->      _Left, Top, Right, Bottom_
    
    - *Crop*            ->      _Area, Zero_
    
    - *Curl*            ->      _C1, C2_
    
    - *Curve*           ->      _Lenght X, Lenght Y_
    
    - *Curve*           ->      _Amplitude X, Amplitude Y_
    
    - *Disc2*           ->      _Rotation, Twist_
    
    - *Escher*          ->      _Beta_
    
    - *Fan2*            ->      _X, Y_
    
    - *Flower*          ->      _Petals, Holes_
    
    - *Flux*            ->      _Spread_
    
    - *JuliaN*          ->      _Power, Distance_
    
    - *JuliaScope*      ->      _Power, Distance_
    
    - *Lazysusan*       ->      _X, Y_
    
    - *Lazysusan*       ->      _Spin, Twist, Space_
    
    - *Mobius*          ->      _Re A, Re B, Re C, Re D_
    
    - *Mobius*          ->      _Im A, Im B, Im C, Im D_
    
    - *Modulus*         ->      _X, Y_
    
    - *Ngon*            ->      _Power, Side, Corners, Circle_
    
    - *Oscope*          ->      _Frequency, Amplitude, Damping, Separation_
    
    - *Parabola*        ->      _Height, Width_
    
    - *Pdj*             ->      _w A, w B, w C, w D_
    
    - *Perspective*     ->      _Angle, Distance_
    
    - *Pie*             ->      _Slice, Thickness, Rotation_
    
    - *Polynomial*      ->      _Pow X, Pow Y_
    
    - *Polynomial*      ->      _Lc X, Lc Y_
    
    - *Polynomial*      ->      _Sc X, Sc Y_
    
    - *Point Symmetry*  ->      _Order, Center X, Center Y_
    
    - *Radial Blur*     ->      _Angle_
    
    - *Rectangles*      ->      _X, Y_
    
    - *Rings2*          ->      _Val_
    
    - *Separation*      ->      _X, Y_
    
    - *Separation*      ->      _Inside X, Inside Y_
    
    - *Split*           ->      _X, Y_
    
    - *Splits*          ->      _X, Y_
    
    - *Waves2*          ->      _Scale X, Scale Y_
    
    - *Waves2*          ->      _Frequency X, Frequency Y_
    
    - *Wedge*           ->      _Swirl, Angle, Hole, Count_
    
    - *WedgeJulia*      ->      _Power, Angle, Distance, Count_
    
    - *WedgeSph*        ->      _Swirl, Angle, Hole, Count_
    
    - *Whorl*           ->      _In, Out_


:box:
    #display: rounded white




@rendering Rendering tips

:box:
    #display: inverted pink

    *FLAM3H Rendering tips*. _A few small tips to render your fractal Flame images._


== Rendering: workflow tips == (REND)
    
:box:
    #display: rounded gray
    
    Workflow tips:
        #id: rendering
    
    You can keep the FLAM3H node live without the need to bake the processed point cloud while rendering
    and just change density values to go from low/quick renders to high/slow render times. Adjust the point size *`@pscale`* ( in Solaris: *`@widths`* ) accordingly.

    When using Karma renderer:

    - With 64gb of physical memory you will be able to render 500M points without weight much on virtual memory.
    
    - With 128gb of physical memory you will be able to render 1 billion points without weight much on virtual memory.
    
    TIP:
        When using Mantra, you can take advantage of _delayed loads_ to greatly increase the amount of points you can render, in which case you must bake those points out in a *`*.bgeo.sc`* files first.
        
        A non-deterministic random number generator was used to construct FLAM3H, and it lies at the heart of the algorithm.
        As a result, the points produced by FLAM3H nodes will always be in a little bit of a different location every time it cook.
        This is perfect for cloning FLAM3H nodes and layering them into a single fractal flame to improve the quality of the final result.


== Rendering: Point size == (REND)
    
:box:
    #display: rounded gray
    
    Point size:
        #id: rendering
    
    For simplicity, FLAM3H sets all *`@pscale`* to a value of *`0.001`*.
    Any necessary adjustments can be made using a wrangle or the upstream geometry node point size multiplier.
    It's important to keep in mind that *`@pscale`* will become *`@widths`* when importing FLAM3H into Stage/Solaris.
    
    TIP:
        As a general rule, the more points, the smaller the *`@pscale`* or *`@widths`* values need to be.


== Rendering: Helpful settings == (REND)
    
:box:
    #display: rounded gray
    
    Karma/Mantra tips:
        #id: Karma/Mantra tips
    
    - When rendering with Karma, remember to turn on the "_Simplified lighting_"/"_Disable lighting_" option to be sure to render the points with their full color values.
    
    - When rendering with Mantra, just create a constant shader that uses the *`@Cd`* attribute.
    
    It will be crucial to experiment with the CP Ramp HSV values, notably the "*S*" (Saturation) and, most crucially, the "*V*" (Value).
    The more dense portions of the flame will get brighter if the Value in HSV is increased from the default value of 1.0, bringing the appearance of the flame closer to that of a typical fractal flame.




:box:
    #display: rounded white

@Cvex

:box:
    #display: inverted pink

    *FLAM3H Cvex*: _How to Compile and update_.
    
    In this section, you will find information on how to compile and then update FLAM3H Cvex code in case you'd like to modify/extend its core functionalities.
    For example, you may want to add more variations to its current arsenal of already implemented variations ( currently there are 106 implemented ).
    
    Extending the Cvex code base, most likely require you to update/extend the Python code base as well, since both go hand in hand with many of the core algorithm functionalities.
    
NOTE:
    In order to improve speed, the Cvex code base has been scaled down to its bare minimum; this results in the least amount of code required to implement the entire algorithm.
    Be as conservative as you can if you want to add anything.


== Cvex: How to compile == (COMPILE)
    
:box:
    #display: rounded gray
    
    Compile CVEX:
        #id: CVEX
    
    *SideFX made this part very easy*:
    
    # Open a Houdini 19 or higher, Command line Tools shell
    # Navigate into the directory where the cvex source files are located
    # To compile any of the available cvex source files, run this command:
    
        {{{
        #!vex
        vcc -c cvex sourceFile.vfl -o outputFile.vex
        }}}
    
    - *vcc* is the name of the Houdini's cvex/vex compiler
    - *-c* to specify a Houdini context, in this case the context is: *cvex*
    - *-o* to specify an output filename ( *.vex* extension )
    
    The FLAM3H source files are already named as expected.
    
    - For FLAM3H, the output file name must be the same as the input source file name ( only the file extension will be different, of course ).
    
        - Source -> _TheFractalFlameAlgorithm_._*vfl*_ 
    
        - Output -> _TheFractalFlameAlgorithm_._*vex*_
    
== Cvex: How to update FLAM3H node == (UPDATE)
    
:box:
    #display: rounded gray
    
    Reload CVEX:
        #id: CVEX
    
    Inside the FLAM3H node, you will find many wrangle core nodes running a compiled Cvex file.
    
    If you end up updating the Cvex code yourself by extending it: 
    
    # Update the sourceFile.*vfl* with all the changes/additions you desire, and follow the above steps on *How to: Compile CVEX*.
    # Once you are ready, remove the old compiled Cvex file from: *FLAM3H*->*Type properties*->*extra files*.
    # Locate the new compiled Cvex file and load it back inside *FLAM3H*->*Type properties*->*extra files* section.
    # Before you click: *Add file*, remove the extension from the filename inside the "*Section name*"
        - ex: From: _*TheFractalFlameAlgorithm.vex*_ To: _*TheFractalFlameAlgorithm*_
    # Click *Apply* or *Accept* to confirm your changes.
    # Go inside the FLAM3H node and on any of the wrangle core nodes, click the:
    
        * "Reload CVEX" icon: [Smallicon:opdef:.?icon_TagORedSVG.svg]
    
    You just need to click it once, and it will reload all the compiled Cvex code files included, the Wrangle Core node you click the icon from is not important.
    
    Once clicked and as soon as FLAM3H cook again, it will Re-Compile all FLAM3H CVEX nodes. Depending on your PC configuration it can take anywhere between 30s and 1 minute. It is a one time compile process.




:box:
    #display: rounded white

@Limitations

:box:
    #display: inverted pink

    *FLAM3H: Limitations*.
    
    The following are limitations to keep in mind when authoring your flames in Fractorium or Apophysis to be loaded inside FLAM3H.
    All of those restrictions are in place to maintain performance within the CVEX language restrictions.

== Limitations: Iterator's count ==
    
:box:
    #display: rounded gray
    
    Iterator's count:
        #id: Limitations
    
    FLAM3H allows you to create as many iterators as you wish; however, When using XAOS, you are only permitted to create a maximum of 20 iterators.
    
    _This is a workaround to make XAOS work due to a Houdini bug: *Bug ID# 124486*, *SideFX Support Ticket SESI #128304*_

== Limitations: iterator's PRE, VAR and POST variations ==

:box:
    #display: rounded gray
    
    PRE variations:
        #id: Limitations
    
    Every iterator is capable of 3 PRE variations, with one ( the first one to always be executed ) being: pre_blur, followed by the other two.
    
    It is really pre_blur + 2 variations of your choice.
    
    NOTE:
        _*The weight of the PRE variations can not be negative*_ in FLAM3H.

:box:
    #display: rounded gray
    
    VAR variations:
        #id: Limitations
    
    Every iterator is capable of 4 variations.
    
:box:
    #display: rounded gray
    
    POST variations:
        #id: Limitations
    
    Every iterator is capable of 1 POST variation.
    
    NOTE:
        _*The weight of the POST variation can not be negative*_ in FLAM3H.
    
:box:
    #display: rounded gray
    
    Parametric variation parameters:
        #id: Limitations
    
    Each iterator has only one set of parametric variation parameters shared within the PRE, VAR and POST variations.
    This means if you use 2 PRE_Mobius, 4 Mobius and 1 POST_Mobius, they will all share the same *`re:abcd`* and *`im:abcd`* parameters.
    
    
    
== Limitations: FF's PRE, VAR and POST variations ==

    
:box:
    #display: rounded gray
    
    FF PRE variations:
        #id: Limitations
    
    FF iterator is capable of 1 PRE variation.
    
    NOTE:
        _*The weight of the FF PRE variations can not be negative*_ in FLAM3H.

    
:box:
    #display: rounded gray
    
    FF VAR variations:
        #id: Limitations
    
    FF iterator is capable of 2 variations.
    
    
:box:
    #display: rounded gray
    
    FF POST variations:
        #id: Limitations
    
    FF iterator is capable of 2 POST variations.
    
    NOTE:
        _*The weight of the FF POST variation can not be negative*_ in FLAM3H.
       
:box:
    #display: rounded gray
        
    FF Parametric variation parameters:
        #id: Limitations
    
    FF iterator has two sets of parametric variation parameters.
    One is shared with VAR variations.
    The second is shared within the PRE- and POST-variations.
    
    # If you use 2 Mobius in the FF VAR section, they will all share the same *`re:abcd`* and *`im:abcd`* parameters from set one ( FF: VARS Tab ).
    # If you use 1 PRE_Mobius and 2 POST_Mobius they will all share the same *`re:abcd`* and *`im:abcd`* parameters from set two ( FF: PP VARS Tab ).
    
== Limitations: FF Shader ==

:box:
    #display: rounded gray

    FF Shader:
        #id: Limitations
    
    This finalxform ( FF ) does not possess any color parameters in this implementation ( Chaotica style ).

    NOTE:
        When saving a flame out from Fractorium/Apophysis with a finalxform remember to set the Final xform color to:
        - Color -> 0.0
        - Color Speed -> 0.0 ( _this is the most important_ )
        - Direct Color -> 1.0
        
        This way, you won't add a color to the flame that FLAM3H won't be able to match.
        
        



:box:
    #display: rounded white
    
:box:
    #display: rounded white

@Author

= _Alessandro Nardini_ =

Mini bio:
    #id: Author
    
:box:
    #display: rounded gray
    
    _Alessandro Nardini is an Italian artist and developer who's spent most of his career serving the entertainment industry._
    _He served many different branches of the entertainment industry's post-production,_
    _spanning feature films, games, TV/commercials, episodic series and streaming._
