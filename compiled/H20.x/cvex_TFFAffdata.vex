;_name	TFFAxformsdata
; ModuleID = 'TFFAxformsdata'
source_filename = "TFFAxformsdata"

@0 = private constant [13 x i8] c"ffpre1weight\00"
@1 = private constant [11 x i8] c"ffpre1type\00"
@2 = private constant [11 x i8] c"ffv1weight\00"
@3 = private constant [9 x i8] c"ffv1type\00"
@4 = private constant [11 x i8] c"ffv2weight\00"
@5 = private constant [9 x i8] c"ffv2type\00"
@6 = private constant [11 x i8] c"ffp1weight\00"
@7 = private constant [9 x i8] c"ffp1type\00"
@8 = private constant [11 x i8] c"ffp2weight\00"
@9 = private constant [9 x i8] c"ffp2type\00"
@10 = private constant [4 x i8] c"ffx\00"
@11 = private constant [4 x i8] c"ffy\00"
@12 = private constant [6 x i8] c"ffang\00"
@13 = private constant [4 x i8] c"ffo\00"
@14 = private constant [9 x i8] c"ffdopost\00"
@15 = private constant [5 x i8] c"ffpx\00"
@16 = private constant [5 x i8] c"ffpy\00"
@17 = private constant [7 x i8] c"ffpang\00"
@18 = private constant [5 x i8] c"ffpo\00"
@PFF = external global i64
@fp1t = external global i64
@fv1t = external global i64
@fv2t = external global i64
@fP1t = external global i64
@fP2t = external global i64
@fp1w = external global double
@fv1w = external global double
@fv2w = external global double
@fP1w = external global double
@fP2w = external global double
@FX = external global <2 x double>
@FY = external global <2 x double>
@FO = external global <2 x double>
@PFX = external global <2 x double>
@PFY = external global <2 x double>
@PFO = external global <2 x double>
@19 = private constant [4 x i8] c"PFF\00"
@20 = private constant [5 x i8] c"fp1t\00"
@21 = private constant [5 x i8] c"fv1t\00"
@22 = private constant [5 x i8] c"fv2t\00"
@23 = private constant [5 x i8] c"fP1t\00"
@24 = private constant [5 x i8] c"fP2t\00"
@25 = private constant [5 x i8] c"fp1w\00"
@26 = private constant [5 x i8] c"fv1w\00"
@27 = private constant [5 x i8] c"fv2w\00"
@28 = private constant [5 x i8] c"fP1w\00"
@29 = private constant [5 x i8] c"fP2w\00"
@30 = private constant [3 x i8] c"FX\00"
@31 = private constant [3 x i8] c"FY\00"
@32 = private constant [3 x i8] c"FO\00"
@33 = private constant [4 x i8] c"PFX\00"
@34 = private constant [4 x i8] c"PFY\00"
@35 = private constant [4 x i8] c"PFO\00"

; Function Attrs: nounwind readnone
declare double @"div@FF"(double, double) #0

; Function Attrs: nounwind readnone
declare double @"getcomp@FUI"(<2 x double>, i64) #0

; Function Attrs: nounwind readnone
declare double @"atan2@FFF"(double, double) #0

; Function Attrs: nounwind readnone
declare double @"sqrt@FF"(double) #0

; Function Attrs: nounwind readnone
declare double @"neg@FF"(double) #0

; Function Attrs: nounwind
declare double @"clamp@FFFF"(double, double, double) #1

; Function Attrs: nounwind readnone
declare double @"tan@FF"(double) #0

; Function Attrs: nounwind readnone
declare i64 @"neg@II"(i64) #0

; Function Attrs: nounwind readnone
declare double @"floor@FF"(double) #0

; Function Attrs: nounwind readnone
declare double @"sin@FF"(double) #0

; Function Attrs: nounwind readnone
declare double @"cos@FF"(double) #0

; Function Attrs: nounwind readnone
declare <3 x double> @"setcomp@VFI"(<3 x double>, double, i64) #0

; Function Attrs: nounwind readnone
declare double @"getcomp@FVI"(<3 x double>, i64) #0

; Function Attrs: nounwind readnone
declare <2 x double> @"setcomp@UFI"(<2 x double>, double, i64) #0

; Function Attrs: nounwind
declare double @"abs@FF"(double) #1

; Function Attrs: nounwind
declare double @"nrandom@F:S"(i8*) #1

; Function Attrs: nounwind readnone
declare <2 x double> @"set@UFF"(double, double) #0

; Function Attrs: nounwind readnone
declare i64 @"isfinite@IF"(double) #0

; Function Attrs: nounwind readnone
declare i64 @"not@II"(i64) #0

; Function Attrs: nounwind readnone
declare i64 @"isnan@IF"(double) #0

; Function Attrs: nounwind readnone
declare i64 @"or@III"(i64, i64) #0

; Function Attrs: nounwind
declare double @"length@FU"(<2 x double>) #1

; Function Attrs: alwaysinline nounwind
define private void @"affineRot@2UUF"(<4 x double>* %m2, <2 x double>* %x, <2 x double>* %y, double* %ang) #2 {
__llvm_entry:
  %x1 = load <2 x double>, <2 x double>* %x
  %y2 = load <2 x double>, <2 x double>* %y
  %return = call <4 x double> @"set@2UU"(<2 x double> %x1, <2 x double> %y2)
  store <4 x double> %return, <4 x double>* %m2
  %ang4 = load double, double* %ang
  %output = call <4 x double> @"rotate@2F"(<4 x double> %return, double %ang4)
  store <4 x double> %output, <4 x double>* %m2
  ret void
}

; Function Attrs: nounwind
declare <4 x double> @"set@2UU"(<2 x double>, <2 x double>) #1

; Function Attrs: nounwind readnone
declare <4 x double> @"rotate@2F"(<4 x double>, double) #0

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #0

; Function Attrs: nounwind readnone
declare i8* @"getcomp@S[SI"(i8**, i64) #0

; Function Attrs: nounwind
declare i8** @"append@[SS"(i8**, i8*) #1

; Function Attrs: alwaysinline nounwind
define private void @"_TFFAxformsdata@IIIIIIFFFFFUUUUUU"(i64* %_bound_PFF, i64* %_bound_fp1t, i64* %_bound_fv1t, i64* %_bound_fv2t, i64* %_bound_fP1t, i64* %_bound_fP2t, double* %_bound_fp1w, double* %_bound_fv1w, double* %_bound_fv2w, double* %_bound_fP1w, double* %_bound_fP2w, <2 x double>* %_bound_FX, <2 x double>* %_bound_FY, <2 x double>* %_bound_FO, <2 x double>* %_bound_PFX, <2 x double>* %_bound_PFY, <2 x double>* %_bound_PFO) #2 {
__llvm_entry:
  %_m2 = alloca <4 x double>
  %0 = alloca <2 x double>
  %1 = alloca <2 x double>
  %2 = alloca double
  %3 = alloca <2 x double>
  %4 = alloca <2 x double>
  %5 = alloca double
  store <4 x double> zeroinitializer, <4 x double>* %_m2, !vex-initializer-store !3
  %return = call double @"chf@FS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @0, i64 0, i64 0))
  %return1 = call i64 @"chi@IS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @1, i64 0, i64 0))
  %return2 = call double @"chf@FS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @2, i64 0, i64 0))
  %return3 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @3, i64 0, i64 0))
  %return4 = call double @"chf@FS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @4, i64 0, i64 0))
  %return5 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @5, i64 0, i64 0))
  %return6 = call double @"chf@FS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @6, i64 0, i64 0))
  %return7 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @7, i64 0, i64 0))
  %return8 = call double @"chf@FS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @8, i64 0, i64 0))
  %return9 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @9, i64 0, i64 0))
  %return10 = call <2 x double> @"chu@US"(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @10, i64 0, i64 0))
  %return11 = call <2 x double> @"chu@US"(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @11, i64 0, i64 0))
  %return12 = call double @"chf@FS"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @12, i64 0, i64 0))
  %return14 = fcmp one double %return12, 0.000000e+00
  br i1 %return14, label %true, label %end

true:                                             ; preds = %__llvm_entry
  store <2 x double> %return10, <2 x double>* %0
  store <2 x double> %return11, <2 x double>* %1
  %return19 = call double @"radians@FF"(double %return12)
  %return20 = call double @"neg@FF"(double %return19)
  store double %return20, double* %2
  call void @"affineRot@2UUF"(<4 x double>* %_m2, <2 x double>* %0, <2 x double>* %1, double* %2)
  %_m221 = load <4 x double>, <4 x double>* %_m2
  %return22 = call double @"getcomp@F2II"(<4 x double> %_m221, i64 0, i64 0)
  %return24 = call double @"getcomp@F2II"(<4 x double> %_m221, i64 0, i64 1)
  %return25 = call <2 x double> @"set@UFF"(double %return22, double %return24)
  %return27 = call double @"getcomp@F2II"(<4 x double> %_m221, i64 1, i64 0)
  %return29 = call double @"getcomp@F2II"(<4 x double> %_m221, i64 1, i64 1)
  %return30 = call <2 x double> @"set@UFF"(double %return27, double %return29)
  br label %end

end:                                              ; preds = %true, %__llvm_entry
  %_x.0 = phi <2 x double> [ %return25, %true ], [ %return10, %__llvm_entry ]
  %_y.0 = phi <2 x double> [ %return30, %true ], [ %return11, %__llvm_entry ]
  %return33 = call <2 x double> @"chu@US"(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @13, i64 0, i64 0))
  %return34 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @14, i64 0, i64 0))
  %6 = icmp ne i64 %return34, 0
  br i1 %6, label %true36, label %end37

true36:                                           ; preds = %end
  %return38 = call <2 x double> @"chu@US"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @15, i64 0, i64 0))
  %return39 = call <2 x double> @"chu@US"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @16, i64 0, i64 0))
  %return40 = call double @"chf@FS"(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @17, i64 0, i64 0))
  %return42 = fcmp one double %return40, 0.000000e+00
  br i1 %return42, label %true44, label %end45

end37:                                            ; preds = %end45, %end
  %pfx.0 = phi <2 x double> [ %_x.1, %end45 ], [ zeroinitializer, %end ]
  %pfy.0 = phi <2 x double> [ %_y.1, %end45 ], [ zeroinitializer, %end ]
  %pfo.0 = phi <2 x double> [ %return63, %end45 ], [ zeroinitializer, %end ]
  store i64 %return34, i64* %_bound_PFF
  store i64 %return1, i64* %_bound_fp1t
  store i64 %return3, i64* %_bound_fv1t
  store i64 %return5, i64* %_bound_fv2t
  store i64 %return7, i64* %_bound_fP1t
  store i64 %return9, i64* %_bound_fP2t
  store double %return, double* %_bound_fp1w
  store double %return2, double* %_bound_fv1w
  store double %return4, double* %_bound_fv2w
  store double %return6, double* %_bound_fP1w
  store double %return8, double* %_bound_fP2w
  store <2 x double> %_x.0, <2 x double>* %_bound_FX
  store <2 x double> %_y.0, <2 x double>* %_bound_FY
  store <2 x double> %return33, <2 x double>* %_bound_FO
  store <2 x double> %pfx.0, <2 x double>* %_bound_PFX
  store <2 x double> %pfy.0, <2 x double>* %_bound_PFY
  store <2 x double> %pfo.0, <2 x double>* %_bound_PFO
  ret void

true44:                                           ; preds = %true36
  store <2 x double> %return38, <2 x double>* %3
  store <2 x double> %return39, <2 x double>* %4
  %return49 = call double @"radians@FF"(double %return40)
  %return50 = call double @"neg@FF"(double %return49)
  store double %return50, double* %5
  call void @"affineRot@2UUF"(<4 x double>* %_m2, <2 x double>* %3, <2 x double>* %4, double* %5)
  %_m251 = load <4 x double>, <4 x double>* %_m2
  %return52 = call double @"getcomp@F2II"(<4 x double> %_m251, i64 0, i64 0)
  %return54 = call double @"getcomp@F2II"(<4 x double> %_m251, i64 0, i64 1)
  %return55 = call <2 x double> @"set@UFF"(double %return52, double %return54)
  %return57 = call double @"getcomp@F2II"(<4 x double> %_m251, i64 1, i64 0)
  %return59 = call double @"getcomp@F2II"(<4 x double> %_m251, i64 1, i64 1)
  %return60 = call <2 x double> @"set@UFF"(double %return57, double %return59)
  br label %end45

end45:                                            ; preds = %true44, %true36
  %_x.1 = phi <2 x double> [ %return55, %true44 ], [ %return38, %true36 ]
  %_y.1 = phi <2 x double> [ %return60, %true44 ], [ %return39, %true36 ]
  %return63 = call <2 x double> @"chu@US"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @18, i64 0, i64 0))
  br label %end37
}

; Function Attrs: nounwind readnone
declare double @"chf@FS"(i8*) #0

; Function Attrs: nounwind readnone
declare i64 @"chi@IS"(i8*) #0

; Function Attrs: nounwind readnone
declare <2 x double> @"chu@US"(i8*) #0

; Function Attrs: nounwind
declare double @"radians@FF"(double) #1

; Function Attrs: nounwind readnone
declare double @"getcomp@F2II"(<4 x double>, i64, i64) #0

; Function Attrs: nounwind
define void @TFFAxformsdata(i64 %PFF, i64 %fp1t, i64 %fv1t, i64 %fv2t, i64 %fP1t, i64 %fP2t, double %fp1w, double %fv1w, double %fv2w, double %fP1w, double %fP2w, <2 x double> %FX, <2 x double> %FY, <2 x double> %FO, <2 x double> %PFX, <2 x double> %PFY, <2 x double> %PFO) #1 {
__llvm_entry:
  %"<fp1t>" = alloca i64
  %"<fv1t>" = alloca i64
  %"<fv2t>" = alloca i64
  %"<fP1t>" = alloca i64
  %"<fP2t>" = alloca i64
  %"<fp1w>" = alloca double
  %"<fv1w>" = alloca double
  %"<fv2w>" = alloca double
  %"<fP1w>" = alloca double
  %"<fP2w>" = alloca double
  %"<FX>" = alloca <2 x double>
  %"<FY>" = alloca <2 x double>
  %"<FO>" = alloca <2 x double>
  %"<PFX>" = alloca <2 x double>
  %"<PFY>" = alloca <2 x double>
  %"<PFO>" = alloca <2 x double>
  %"<PFF>" = alloca i64
  store i64 %PFF, i64* %"<PFF>"
  store i64 %fp1t, i64* %"<fp1t>"
  store i64 %fv1t, i64* %"<fv1t>"
  store i64 %fv2t, i64* %"<fv2t>"
  store i64 %fP1t, i64* %"<fP1t>"
  store i64 %fP2t, i64* %"<fP2t>"
  store double %fp1w, double* %"<fp1w>"
  store double %fv1w, double* %"<fv1w>"
  store double %fv2w, double* %"<fv2w>"
  store double %fP1w, double* %"<fP1w>"
  store double %fP2w, double* %"<fP2w>"
  store <2 x double> %FX, <2 x double>* %"<FX>"
  store <2 x double> %FY, <2 x double>* %"<FY>"
  store <2 x double> %FO, <2 x double>* %"<FO>"
  store <2 x double> %PFX, <2 x double>* %"<PFX>"
  store <2 x double> %PFY, <2 x double>* %"<PFY>"
  store <2 x double> %PFO, <2 x double>* %"<PFO>"
  call void @"_TFFAxformsdata@IIIIIIFFFFFUUUUUU"(i64* %"<PFF>", i64* %"<fp1t>", i64* %"<fv1t>", i64* %"<fv2t>", i64* %"<fP1t>", i64* %"<fP2t>", double* %"<fp1w>", double* %"<fv1w>", double* %"<fv2w>", double* %"<fP1w>", double* %"<fP2w>", <2 x double>* %"<FX>", <2 x double>* %"<FY>", <2 x double>* %"<FO>", <2 x double>* %"<PFX>", <2 x double>* %"<PFY>", <2 x double>* %"<PFO>")
  %evalue = load i64, i64* %"<PFF>"
  %gvalue = call i64 @"_export@ISI"(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @19, i64 0, i64 0), i64 %evalue) #3
  %evalue1 = load i64, i64* %"<fp1t>"
  %gvalue2 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @20, i64 0, i64 0), i64 %evalue1) #3
  %evalue3 = load i64, i64* %"<fv1t>"
  %gvalue4 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @21, i64 0, i64 0), i64 %evalue3) #3
  %evalue5 = load i64, i64* %"<fv2t>"
  %gvalue6 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @22, i64 0, i64 0), i64 %evalue5) #3
  %evalue7 = load i64, i64* %"<fP1t>"
  %gvalue8 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @23, i64 0, i64 0), i64 %evalue7) #3
  %evalue9 = load i64, i64* %"<fP2t>"
  %gvalue10 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @24, i64 0, i64 0), i64 %evalue9) #3
  %evalue11 = load double, double* %"<fp1w>"
  %gvalue12 = call double @"_export@FSF"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @25, i64 0, i64 0), double %evalue11) #3
  %evalue13 = load double, double* %"<fv1w>"
  %gvalue14 = call double @"_export@FSF"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @26, i64 0, i64 0), double %evalue13) #3
  %evalue15 = load double, double* %"<fv2w>"
  %gvalue16 = call double @"_export@FSF"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @27, i64 0, i64 0), double %evalue15) #3
  %evalue17 = load double, double* %"<fP1w>"
  %gvalue18 = call double @"_export@FSF"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @28, i64 0, i64 0), double %evalue17) #3
  %evalue19 = load double, double* %"<fP2w>"
  %gvalue20 = call double @"_export@FSF"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @29, i64 0, i64 0), double %evalue19) #3
  %evalue21 = load <2 x double>, <2 x double>* %"<FX>"
  %gvalue22 = call <2 x double> @"_export@USU"(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @30, i64 0, i64 0), <2 x double> %evalue21) #3
  %evalue23 = load <2 x double>, <2 x double>* %"<FY>"
  %gvalue24 = call <2 x double> @"_export@USU"(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @31, i64 0, i64 0), <2 x double> %evalue23) #3
  %evalue25 = load <2 x double>, <2 x double>* %"<FO>"
  %gvalue26 = call <2 x double> @"_export@USU"(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @32, i64 0, i64 0), <2 x double> %evalue25) #3
  %evalue27 = load <2 x double>, <2 x double>* %"<PFX>"
  %gvalue28 = call <2 x double> @"_export@USU"(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @33, i64 0, i64 0), <2 x double> %evalue27) #3
  %evalue29 = load <2 x double>, <2 x double>* %"<PFY>"
  %gvalue30 = call <2 x double> @"_export@USU"(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @34, i64 0, i64 0), <2 x double> %evalue29) #3
  %evalue31 = load <2 x double>, <2 x double>* %"<PFO>"
  %gvalue32 = call <2 x double> @"_export@USU"(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @35, i64 0, i64 0), <2 x double> %evalue31) #3
  store i64 %gvalue, i64* @PFF
  store i64 %gvalue2, i64* @fp1t
  store i64 %gvalue4, i64* @fv1t
  store i64 %gvalue6, i64* @fv2t
  store i64 %gvalue8, i64* @fP1t
  store i64 %gvalue10, i64* @fP2t
  store double %gvalue12, double* @fp1w
  store double %gvalue14, double* @fv1w
  store double %gvalue16, double* @fv2w
  store double %gvalue18, double* @fP1w
  store double %gvalue20, double* @fP2w
  store <2 x double> %gvalue22, <2 x double>* @FX
  store <2 x double> %gvalue24, <2 x double>* @FY
  store <2 x double> %gvalue26, <2 x double>* @FO
  store <2 x double> %gvalue28, <2 x double>* @PFX
  store <2 x double> %gvalue30, <2 x double>* @PFY
  store <2 x double> %gvalue32, <2 x double>* @PFO
  ret void
}

declare i64 @"_export@ISI"(i8*, i64)

declare double @"_export@FSF"(i8*, double)

declare <2 x double> @"_export@USU"(i8*, <2 x double>)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @TFFAxformsdata(i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, <2 x double> zeroinitializer, <2 x double> zeroinitializer, <2 x double> zeroinitializer, <2 x double> zeroinitializer, <2 x double> zeroinitializer, <2 x double> zeroinitializer)
  ret void
}

attributes #0 = { nounwind readnone }
attributes #1 = { nounwind }
attributes #2 = { alwaysinline nounwind }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"20.5.370"}
!2 = !{!"64"}
!3 = !{!""}

;_code_end
